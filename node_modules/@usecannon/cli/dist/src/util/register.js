"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForEvent = exports.isPackageRegistered = void 0;
const builder_1 = require("@usecannon/builder");
const viem = __importStar(require("viem"));
const lodash_1 = __importDefault(require("lodash"));
/**
 * Checks if a package is registered on a registry provider.
 *
 * @param {Object[]} registryProviders - An array of objects containing viem.PublicClient and array of CannonSigner.
 * @param {string} packageRef - The reference string of the package to check.
 * @param {viem.Address} contractAddress - Target registry address
 * @returns {Promise<boolean[]>} - A promise that resolves to an array of booleans, each indicating if the package is registered in the corresponding registry.
 */
const isPackageRegistered = async (registryProviders, packageRef, contractAddress) => {
    const packageName = new builder_1.PackageReference(packageRef).name;
    if (contractAddress.length !== registryProviders.length) {
        throw new Error('Registry providers and contract addresses must have the same length.');
    }
    const onChainRegistries = registryProviders.map(({ provider, signers }, index) => new builder_1.OnChainRegistry({
        signer: signers[0],
        provider,
        address: contractAddress[index],
    }));
    const packageOwners = await Promise.all(onChainRegistries.map((onChainRegistry) => onChainRegistry.getPackageOwner(packageName)));
    return !packageOwners.some((address) => viem.isAddressEqual(address, viem.zeroAddress));
};
exports.isPackageRegistered = isPackageRegistered;
/**
 * Waits until for a specific event on the Cannon Registry or a timeout occurs.
 *
 * @param {string} params.eventName - The name of the event to wait for.
 * @param {viem.Abi} params.abi - The ABI (Application Binary Interface) that includes the event.
 * @param {number} params.chainId - The chain ID of the registry.
 * @param {any} params.expectedArgs - The expected arguments of the event.
 * @returns {Promise<void>} - A promise that resolves with the event logs when the event is received or rejects with an error on timeout or if an error occurs while watching the event.
 */
const waitForEvent = ({ eventName, abi, providerUrl, expectedArgs }) => {
    const event = viem.getAbiItem({ abi, name: eventName });
    const client = viem.createPublicClient({
        transport: viem.http(providerUrl),
    });
    let timeoutId;
    return new Promise((resolve, reject) => {
        const onTimeout = () => reject(new Error(`Timed out waiting for ${eventName} event`));
        // start watching for the event
        const unwatch = client.watchEvent({
            address: builder_1.DEFAULT_REGISTRY_ADDRESS,
            event,
            onLogs: async (logs) => {
                const topics = viem.parseEventLogs({ abi, eventName, logs });
                for (const topic of topics) {
                    // check event arguments, early return if they don't match
                    if (!lodash_1.default.isEqual(topic.args, expectedArgs))
                        continue;
                    // unwatch the event
                    unwatch();
                    // clear the timeout
                    clearTimeout(timeoutId);
                    // resolve the promise
                    resolve(logs);
                }
            },
            onError: (err) => {
                // unwatch the event
                unwatch();
                // clear the timeout
                clearTimeout(timeoutId);
                // reject the promise
                reject(new Error(`Error watching for ${eventName} event: ${err}`));
            },
        });
        // Set the timeout and store its id for cancellation
        // Docs say that the timeout should be max 3 minutes, but we add 2 extra minutes to be safe
        // Ref: https://docs.optimism.io/builders/app-developers/bridging/messaging#for-l1-to-l2-transactions
        const waitTime = 180000 + 120000; // 3 + 2 = 5 minutes
        timeoutId = setTimeout(onTimeout, waitTime);
    });
};
exports.waitForEvent = waitForEvent;
//# sourceMappingURL=register.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setCannonfilePath = exports.doBuild = void 0;
const node_path_1 = __importDefault(require("node:path"));
const debug_1 = __importDefault(require("debug"));
const viem = __importStar(require("viem"));
const constants_1 = require("../constants");
const foundry_1 = require("../foundry");
const helpers_1 = require("../helpers");
const registry_1 = require("../registry");
const rpc_1 = require("../rpc");
const settings_1 = require("../settings");
const anvil_1 = require("./anvil");
const params_1 = require("./params");
const provider_1 = require("./provider");
const debug = (0, debug_1.default)('cannon:cli');
/**
 * Builds the contracts defined in the cannonfile.
 * @param cannonfile Path to the cannonfile.
 * @param settings Array of setting strings for the build process.
 * @param opts Options for the build process.
 * @returns An array containing the RPC node, package specification, chain artifacts, and chain builder runtime.
 */
async function doBuild(cannonfile, settings, opts) {
    // Set debug level
    setDebugLevel(opts);
    debug('do build called with', cannonfile, settings, (0, helpers_1.filterSettings)(opts));
    // If the first param is not a cannonfile, it should be parsed as settings
    cannonfile = setCannonfilePath(cannonfile, settings);
    const cannonfilePath = node_path_1.default.resolve(cannonfile);
    const projectDirectory = node_path_1.default.resolve(cannonfilePath);
    const cliSettings = (0, settings_1.resolveCliSettings)(opts);
    // Set up provider
    const { provider, signers, node } = await configureProvider(opts, cliSettings);
    // Set up signers
    // TODO: why are the provider types borked up here (like they are everywhere)
    const { getSigner, getDefaultSigner } = await configureSigners(opts, cliSettings, provider, signers);
    // Prepare pre-build config
    const buildConfig = await prepareBuildConfig(cannonfile, projectDirectory, opts, settings, cliSettings, provider, getSigner, getDefaultSigner);
    const { build } = await Promise.resolve().then(() => __importStar(require('../commands/build')));
    const { outputs, runtime } = await build(buildConfig);
    return [node, buildConfig.packageDefinition, outputs, runtime];
}
exports.doBuild = doBuild;
/**
 * Sets the debug level based on the provided options.
 * @param opts Options to define debug level.
 */
function setDebugLevel(opts) {
    switch (true) {
        case opts.Vvvv:
            debug_1.default.enable('cannon:*');
            break;
        case opts.Vvv:
            debug_1.default.enable('cannon:builder*');
            break;
        case opts.Vv:
            debug_1.default.enable('cannon:builder,cannon:builder:definition');
            break;
        case opts.v:
            debug_1.default.enable('cannon:builder');
            break;
    }
}
/**
 * Processes the cannonfile and updates settings if necessary.
 *
 * @param {string} cannonfile - The cannonfile parameter.
 * @param {string[]} settings - The settings array to update if necessary.
 * @returns {string} The processed cannonfile.
 */
function setCannonfilePath(cannonfile, settings) {
    if (cannonfile !== '-' && !cannonfile.endsWith('.toml')) {
        settings.unshift(cannonfile);
        cannonfile = 'cannonfile.toml';
    }
    return cannonfile;
}
exports.setCannonfilePath = setCannonfilePath;
/**
 * Configures and returns an Ethereum provider.
 * If no chain id or provider url is provided, starts a local RPC node.
 * In a dry run, it forks the mainnet using the specified provider.
 * @param opts Options for configuring the provider.
 * @param cliSettings CLI settings to use in provider configuration.
 * @returns An object containing the configured provider, signers, and an optional RPC node.
 */
async function configureProvider(opts, cliSettings) {
    let provider = undefined;
    let signers = undefined;
    let node = null;
    let chainId = undefined;
    if (!opts.chainId) {
        if ((0, provider_1.isURL)(cliSettings.providerUrl)) {
            chainId = await (0, provider_1.getChainIdFromProviderUrl)(cliSettings.providerUrl);
        }
        else {
            node = await (0, rpc_1.runRpc)({
                ...(0, anvil_1.pickAnvilOptions)(opts),
            });
            chainId = node.chainId;
            provider = (0, rpc_1.getProvider)(node);
        }
    }
    else {
        chainId = parseInt(opts.chainId);
    }
    if (!provider) {
        const _provider = await (0, provider_1.resolveWriteProvider)(cliSettings, chainId);
        provider = _provider.provider;
        signers = _provider.signers;
    }
    if (opts.dryRun) {
        node = await (0, rpc_1.runRpc)({
            ...(0, anvil_1.pickAnvilOptions)(opts),
            chainId,
        }, {
            forkProvider: provider,
        });
        provider = (0, rpc_1.getProvider)(node);
    }
    return { provider, signers, node };
}
/**
 * Configures and returns the signers for transactions. In a dry run, it impersonates a default account.
 * Otherwise, it resolves signers from the provided CLI settings.
 * @param opts Options to influence signer configuration.
 * @param chainId The chain ID for which the signers are configured.
 * @param provider The configured Ethereum provider.
 * @param signers Array of signers.
 * @returns An object containing methods to get a specific signer or the default signer.
 */
async function configureSigners(opts, cliSettings, provider, signers) {
    let getSigner = undefined;
    let getDefaultSigner = undefined;
    // Early return, we don't need to configure signers
    const isProviderUrl = (0, provider_1.isURL)(cliSettings.providerUrl);
    if (!opts.chainId && !isProviderUrl)
        return { getSigner, getDefaultSigner };
    if (opts.dryRun) {
        // Setup for dry run
        getDefaultSigner = async () => {
            const addr = signers && signers.length > 0 ? signers[0].address : constants_1.ANVIL_FIRST_ADDRESS;
            await provider.impersonateAccount({ address: addr });
            await provider.setBalance({ address: addr, value: viem.parseEther('10000') });
            return { address: addr, wallet: provider };
        };
    }
    else {
        getSigner = async (address) => {
            for (const signer of signers || []) {
                if (viem.isAddressEqual(signer.address, address)) {
                    return signer;
                }
            }
            throw new Error(`signer not found for address ${viem.getAddress(address)}. Please add the private key for this address to your command line.`);
        };
        getDefaultSigner = async () => signers[0];
    }
    return { getSigner, getDefaultSigner };
}
/**
 * Prepares and returns the build configuration by loading and parsing the cannonfile.
 * Sets up package specifications, artifact resolver, and other options like gas prices.
 * @param cannonfile Path to the cannonfile.
 * @param projectDirectory Directory of the project.
 * @param opts Options for the build configuration.
 * @param settings Array of setting strings for the build process.
 * @param cliSettings CLI settings for the build process.
 * @param provider Configured Ethereum provider.
 * @param getSigner Function to get a specific signer.
 * @param getDefaultSigner Function to get the default signer.
 * @returns The build configuration object.
 */
async function prepareBuildConfig(cannonfile, projectDirectory, opts, settings, cliSettings, provider, getSigner, getDefaultSigner) {
    const { name, version, preset, def } = await (0, helpers_1.loadCannonfile)(cannonfile);
    const packageSpecification = {
        name,
        version,
        preset,
        settings: (0, params_1.parseSettings)(settings),
    };
    // TODO: `isPublicSourceCode` on def is not the most reliable way to
    // determine if source code should be public or not
    // ideally we find out from the runtime, which is the final source. however, its unlikely this
    // will become a problem because the runtime auto deletes any sources that may be included
    // anyway, and it requires a lot of refactoring,
    // so not refactoring this
    const getArtifact = (name) => (0, foundry_1.getFoundryArtifact)(name, projectDirectory, def.isPublicSourceCode());
    const overrideResolver = opts.dryRun ? await (0, registry_1.createDryRunRegistry)(cliSettings) : undefined;
    return {
        provider,
        def,
        packageDefinition: packageSpecification,
        pkgInfo: {},
        getArtifact,
        getSigner,
        getDefaultSigner,
        upgradeFrom: opts.upgradeFrom,
        presetArg: opts.preset,
        wipe: opts.wipe,
        persist: !opts.dryRun,
        overrideResolver,
        providerUrl: cliSettings.providerUrl,
        gasPrice: opts.gasPrice,
        gasFee: opts.maxGasFee,
        priorityGasFee: opts.maxPriorityGasFee,
    };
}
//# sourceMappingURL=build.js.map
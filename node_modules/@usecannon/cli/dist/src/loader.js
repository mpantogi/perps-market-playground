"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMainLoader = exports.IPFSLoaderWithRetries = exports.CliLoader = exports.LocalLoader = void 0;
const builder_1 = require("@usecannon/builder");
const ipfs_1 = require("@usecannon/builder/dist/src/ipfs");
const crypto_1 = __importDefault(require("crypto"));
const debug_1 = __importDefault(require("debug"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const prompts_1 = __importDefault(require("prompts"));
const tty_1 = __importDefault(require("tty"));
const debug = (0, debug_1.default)('cannon:cli:loader');
const isFile = (filepath) => {
    try {
        return fs_extra_1.default.statSync(filepath).isFile();
    }
    catch (err) {
        return false;
    }
};
/**
 * @deprecated
 */
class LocalLoader {
    constructor(dir) {
        this.dir = dir;
    }
    getLabel() {
        return `local (${this.dir})`;
    }
    read(url) {
        if (!url.startsWith('file://')) {
            throw new Error('incorrect url type');
        }
        return fs_extra_1.default.readJson(path_1.default.join(this.dir, `${url.slice(7)}`));
    }
    async put(misc) {
        const dataToSave = JSON.stringify(misc);
        const hash = crypto_1.default.createHash('md5').update(dataToSave).digest('hex');
        await fs_extra_1.default.mkdirp(this.dir);
        await fs_extra_1.default.writeFile(path_1.default.join(this.dir, `${hash}.json`), dataToSave);
        return `file://${hash}.json`;
    }
    async list() {
        debug('local list');
        return (await fs_extra_1.default.readdir(this.dir)).filter((f) => f.match(/[0-9a-f]+\.json/)).map((f) => `file://${f}`);
    }
    async remove(url) {
        debug(`local remove ${url}`);
        await fs_extra_1.default.unlink(path_1.default.join(this.dir, `${url.slice(7)}`));
    }
}
exports.LocalLoader = LocalLoader;
class CliLoader {
    constructor(opts) {
        this.readIpfs = opts.readIpfs;
        this.writeIpfs = opts.writeIpfs;
        this.repo = opts.repoLoader;
        this.dir = opts.fileCacheDir;
    }
    getLabel() {
        return `cli ${(this.readIpfs ? 'READ ' + this.readIpfs.getLabel() + ' + ' : '') +
            (this.writeIpfs ? 'READ ' + this.writeIpfs.getLabel() + ' + ' : '') +
            'REPO ' +
            this.repo.getLabel()}`;
    }
    getCacheFilePath(url) {
        return path_1.default.join(this.dir, `${CliLoader.getCacheHash(url)}.json`);
    }
    async put(misc) {
        const data = JSON.stringify(misc);
        const cid = await (0, ipfs_1.getContentCID)(Buffer.from((0, ipfs_1.compress)(data)));
        const url = builder_1.IPFSLoader.PREFIX + cid;
        debug(`cli ipfs put ${url}`);
        await fs_extra_1.default.mkdirp(this.dir);
        await fs_extra_1.default.writeFile(this.getCacheFilePath(url), data);
        if (this.writeIpfs) {
            await this.writeIpfs.put(misc);
        }
        return url;
    }
    async read(url) {
        const cacheFile = this.getCacheFilePath(url);
        debug(`cli ipfs read ${url} ${cacheFile}`);
        // Check if we already have the file cached locally
        if (isFile(cacheFile)) {
            const ipfsData = fs_extra_1.default.readJson(cacheFile);
            debug('cli ipfs loaded from cache');
            return ipfsData;
        }
        // If its configured, try to get it from the settings ipfs
        const ipfsData = await (this.readIpfs || this.repo).read(url);
        await fs_extra_1.default.mkdirp(this.dir);
        // NOTE: would be nice if we could just get the raw data here so we dont have to restringify
        const rawIpfsData = JSON.stringify(ipfsData);
        await fs_extra_1.default.writeFile(this.getCacheFilePath(url), rawIpfsData);
        debug('wrote cache ipfs data', rawIpfsData.length);
        return ipfsData;
    }
    async remove(url) {
        debug(`cli ipfs remove ${url}`);
        const cacheFile = this.getCacheFilePath(url);
        // Remove from the local cache
        if (isFile(cacheFile)) {
            await fs_extra_1.default.unlink(cacheFile);
        }
        // If its configured, try to remove it from the settings ipfs
        if (this.writeIpfs) {
            return this.writeIpfs.remove(url);
        }
        // Notice: Never try to remove from the repo
    }
    async list() {
        return this.readIpfs ? this.readIpfs.list() : [];
    }
    static getCacheHash(url) {
        const qmhash = url.replace(builder_1.IPFSLoader.PREFIX, '');
        const md5 = crypto_1.default.createHash('md5').update(qmhash).digest('hex');
        // Whe need to add an md5 to make sure that there are not collisions,
        // And we CANNOT use directly the Qm... hash because files are not case sensitive.
        return `${md5}-${qmhash.toLowerCase()}`;
    }
}
exports.CliLoader = CliLoader;
class IPFSLoaderWithRetries extends builder_1.IPFSLoader {
    async put(misc) {
        try {
            return super.put(misc);
        }
        catch (err) {
            if (err.code === 'RETRY_ERROR' && tty_1.default.isatty(process.stdout.fd)) {
                const confirm = await (0, prompts_1.default)({
                    type: 'confirm',
                    name: 'value',
                    message: 'Retry?',
                });
                if (confirm.value) {
                    return super.put(misc);
                }
            }
            throw err;
        }
    }
    async read(url) {
        try {
            return super.read(url);
        }
        catch (err) {
            if (err.code === 'RETRY_ERROR' && tty_1.default.isatty(process.stdout.fd)) {
                const confirm = await (0, prompts_1.default)({
                    type: 'confirm',
                    name: 'value',
                    message: 'Retry?',
                });
                if (confirm.value) {
                    return super.read(url);
                }
            }
            throw err;
        }
    }
}
exports.IPFSLoaderWithRetries = IPFSLoaderWithRetries;
function getMainLoader(cliSettings) {
    return {
        ipfs: new CliLoader({
            readIpfs: cliSettings.ipfsUrl
                ? new IPFSLoaderWithRetries(cliSettings.ipfsUrl, {}, cliSettings.ipfsTimeout, cliSettings.ipfsRetries)
                : undefined,
            writeIpfs: cliSettings.writeIpfsUrl
                ? new IPFSLoaderWithRetries(cliSettings.writeIpfsUrl, {}, cliSettings.ipfsTimeout, cliSettings.ipfsRetries)
                : undefined,
            repoLoader: new IPFSLoaderWithRetries((0, builder_1.getCannonRepoRegistryUrl)(), {}, cliSettings.ipfsTimeout, cliSettings.ipfsRetries),
            fileCacheDir: path_1.default.join(cliSettings.cannonDirectory, 'ipfs_cache'),
        }),
        file: new LocalLoader(path_1.default.join(cliSettings.cannonDirectory, 'blobs')),
    };
}
exports.getMainLoader = getMainLoader;
//# sourceMappingURL=loader.js.map
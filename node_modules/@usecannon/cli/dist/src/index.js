"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadCannonfile = exports.getFoundryArtifact = exports.resolveCliSettings = exports.resolveProviderAndSigners = exports.createDryRunRegistry = exports.createDefaultReadRegistry = exports.getProvider = exports.runRpc = exports.setup = exports.verify = exports.run = exports.publishers = exports.unpublish = exports.publish = exports.inspect = exports.clean = exports.build = exports.alter = void 0;
const node_child_process_1 = require("node:child_process");
const node_path_1 = __importDefault(require("node:path"));
const builder_1 = require("@usecannon/builder");
const chalk_1 = require("chalk");
const commander_1 = require("commander");
const debug_1 = __importDefault(require("debug"));
const lodash_1 = __importDefault(require("lodash"));
const prompts_1 = __importDefault(require("prompts"));
const viem = __importStar(require("viem"));
const package_json_1 = __importDefault(require("../package.json"));
const interact_1 = require("./commands/interact");
const commandsConfig_1 = __importDefault(require("./commandsConfig"));
const helpers_1 = require("./helpers");
const loader_1 = require("./loader");
const plugins_1 = require("./plugins");
const registry_1 = require("./registry");
const rpc_1 = require("./rpc");
const settings_1 = require("./settings");
const anvil_1 = require("./util/anvil");
const build_1 = require("./util/build");
const contracts_recursive_1 = require("./util/contracts-recursive");
const params_1 = require("./util/params");
const provider_1 = require("./util/provider");
const register_1 = require("./util/register");
const write_deployments_1 = require("./util/write-deployments");
require("./custom-steps/run");
__exportStar(require("./types"), exports);
__exportStar(require("./constants"), exports);
__exportStar(require("./util/params"), exports);
__exportStar(require("./util/register"), exports);
__exportStar(require("./util/provider"), exports);
var alter_1 = require("./commands/alter");
Object.defineProperty(exports, "alter", { enumerable: true, get: function () { return alter_1.alter; } });
var build_2 = require("./commands/build");
Object.defineProperty(exports, "build", { enumerable: true, get: function () { return build_2.build; } });
var clean_1 = require("./commands/clean");
Object.defineProperty(exports, "clean", { enumerable: true, get: function () { return clean_1.clean; } });
var inspect_1 = require("./commands/inspect");
Object.defineProperty(exports, "inspect", { enumerable: true, get: function () { return inspect_1.inspect; } });
var publish_1 = require("./commands/publish");
Object.defineProperty(exports, "publish", { enumerable: true, get: function () { return publish_1.publish; } });
var unpublish_1 = require("./commands/unpublish");
Object.defineProperty(exports, "unpublish", { enumerable: true, get: function () { return unpublish_1.unpublish; } });
var publishers_1 = require("./commands/publishers");
Object.defineProperty(exports, "publishers", { enumerable: true, get: function () { return publishers_1.publishers; } });
var run_1 = require("./commands/run");
Object.defineProperty(exports, "run", { enumerable: true, get: function () { return run_1.run; } });
var verify_1 = require("./commands/verify");
Object.defineProperty(exports, "verify", { enumerable: true, get: function () { return verify_1.verify; } });
var setup_1 = require("./commands/setup");
Object.defineProperty(exports, "setup", { enumerable: true, get: function () { return setup_1.setup; } });
var rpc_2 = require("./rpc");
Object.defineProperty(exports, "runRpc", { enumerable: true, get: function () { return rpc_2.runRpc; } });
Object.defineProperty(exports, "getProvider", { enumerable: true, get: function () { return rpc_2.getProvider; } });
var registry_2 = require("./registry");
Object.defineProperty(exports, "createDefaultReadRegistry", { enumerable: true, get: function () { return registry_2.createDefaultReadRegistry; } });
Object.defineProperty(exports, "createDryRunRegistry", { enumerable: true, get: function () { return registry_2.createDryRunRegistry; } });
var provider_2 = require("./util/provider");
Object.defineProperty(exports, "resolveProviderAndSigners", { enumerable: true, get: function () { return provider_2.resolveProviderAndSigners; } });
var settings_2 = require("./settings");
Object.defineProperty(exports, "resolveCliSettings", { enumerable: true, get: function () { return settings_2.resolveCliSettings; } });
var foundry_1 = require("./foundry");
Object.defineProperty(exports, "getFoundryArtifact", { enumerable: true, get: function () { return foundry_1.getFoundryArtifact; } });
var helpers_2 = require("./helpers");
Object.defineProperty(exports, "loadCannonfile", { enumerable: true, get: function () { return helpers_2.loadCannonfile; } });
const program = new commander_1.Command();
program
    .name('cannon')
    .version(package_json_1.default.version)
    .description('Run a cannon package on a local node')
    .enablePositionalOptions()
    .hook('preAction', async (thisCommand) => {
    await (0, helpers_1.checkCannonVersion)(package_json_1.default.version);
    setDebugLevel(thisCommand.opts());
});
configureRun(program);
configureRun(program.command('run'));
function applyCommandsConfig(command, config) {
    if (config.description) {
        command.description(config.description);
    }
    if (config.usage) {
        command.usage(config.usage);
    }
    if (config.arguments) {
        config.arguments.map((argument) => {
            if (argument.flags === '<packageRefs...>') {
                command.argument(argument.flags, argument.description, params_1.parsePackagesArguments, argument.defaultValue);
            }
            else if (command.name() === 'interact' && argument.flags === '<packageRef>') {
                command.argument(argument.flags, argument.description, params_1.parsePackageArguments, argument.defaultValue);
            }
            else {
                command.argument(argument.flags, argument.description, argument.defaultValue);
            }
        });
    }
    if (config.anvilOptions) {
        config.anvilOptions.map((option) => {
            option.required
                ? command.requiredOption(option.flags, option.description, option.defaultValue)
                : command.option(option.flags, option.description, option.defaultValue);
        });
    }
    if (config.options) {
        config.options.map((option) => {
            option.required
                ? command.requiredOption(option.flags, option.description, option.defaultValue)
                : command.option(option.flags, option.description, option.defaultValue);
        });
    }
    return command;
}
function setDebugLevel(opts) {
    switch (true) {
        case opts.Vvvv:
            debug_1.default.enable('cannon:*');
            break;
        case opts.Vvv:
            debug_1.default.enable('cannon:builder*');
            break;
        case opts.Vv:
            debug_1.default.enable('cannon:builder,cannon:builder:definition');
            break;
        case opts.v:
            debug_1.default.enable('cannon:builder');
            break;
    }
}
function configureRun(program) {
    return applyCommandsConfig(program, commandsConfig_1.default.run).action(async function (packages, options, program) {
        console.log((0, chalk_1.bold)('Starting local node...\n'));
        const { run } = await Promise.resolve().then(() => __importStar(require('./commands/run')));
        options.port = Number.parseInt(options.port);
        const cliSettings = (0, settings_1.resolveCliSettings)(options);
        let node;
        if (options.chainId) {
            const { provider } = await (0, provider_1.resolveWriteProvider)(cliSettings, Number.parseInt(options.chainId));
            // throw an error if the chainId is not consistent with the provider's chainId
            await (0, helpers_1.ensureChainIdConsistency)(cliSettings.providerUrl, options.chainId);
            node = await (0, rpc_1.runRpc)((0, anvil_1.pickAnvilOptions)(options), {
                forkProvider: provider,
            });
        }
        else {
            if ((0, provider_1.isURL)(cliSettings.providerUrl)) {
                options.chainId = await (0, provider_1.getChainIdFromProviderUrl)(cliSettings.providerUrl);
                const { provider } = await (0, provider_1.resolveWriteProvider)(cliSettings, Number.parseInt(options.chainId));
                node = await (0, rpc_1.runRpc)((0, anvil_1.pickAnvilOptions)(options), {
                    forkProvider: provider,
                });
            }
            else {
                node = await (0, rpc_1.runRpc)((0, anvil_1.pickAnvilOptions)(options));
            }
        }
        // Override options with CLI settings
        const pickedCliSettings = lodash_1.default.pick(cliSettings, Object.keys(options));
        const mergedOptions = lodash_1.default.assign({}, options, pickedCliSettings);
        await run(packages, {
            ...mergedOptions,
            node,
            helpInformation: program.helpInformation(),
        });
    });
}
applyCommandsConfig(program.command('build'), commandsConfig_1.default.build)
    .showHelpAfterError('Use --help for more information.')
    .action(async (cannonfile, settings, options) => {
    const cannonfilePath = node_path_1.default.resolve(cannonfile);
    const projectDirectory = node_path_1.default.dirname(cannonfilePath);
    const cliSettings = (0, settings_1.resolveCliSettings)(options);
    // throw an error if the chainId is not consistent with the provider's chainId
    await (0, helpers_1.ensureChainIdConsistency)(cliSettings.providerUrl, options.chainId);
    console.log((0, chalk_1.bold)('Building the foundry project...'));
    if (!options.skipCompile) {
        let forgeBuildArgs = ['build'];
        if (await (0, helpers_1.checkForgeAstSupport)()) {
            forgeBuildArgs = [...forgeBuildArgs, '--ast'];
        }
        const forgeBuildProcess = (0, node_child_process_1.spawn)('forge', forgeBuildArgs, { cwd: projectDirectory, shell: true });
        await new Promise((resolve, reject) => {
            forgeBuildProcess.on('exit', (code) => {
                if (code === 0) {
                    console.log((0, chalk_1.gray)('forge build succeeded'));
                }
                else {
                    console.log((0, chalk_1.red)('forge build failed'));
                    console.log((0, chalk_1.red)('Make sure "forge build" runs successfully or use the --skip-compile flag.'));
                    return reject(new Error(`forge build failed with exit code "${code}"`));
                }
                resolve(null);
            });
        });
    }
    else {
        console.log((0, chalk_1.yellow)('Skipping forge build...'));
    }
    console.log(''); // Linebreak in CLI to signify end of compilation.
    // Override options with CLI settings
    const pickedCliSettings = lodash_1.default.pick(cliSettings, Object.keys(options));
    const mergedOptions = lodash_1.default.assign({}, options, pickedCliSettings);
    const [node, pkgSpec, , runtime] = await (0, build_1.doBuild)(cannonfile, settings, mergedOptions);
    if (options.keepAlive && node) {
        console.log(`Built package RPC URL available at ${node.host}`);
        const { run } = await Promise.resolve().then(() => __importStar(require('./commands/run')));
        await run([{ ...pkgSpec, settings: {} }], {
            ...mergedOptions,
            resolver: runtime.registry,
            node,
            helpInformation: program.helpInformation(),
        });
    }
    node?.kill();
});
applyCommandsConfig(program.command('verify'), commandsConfig_1.default.verify).action(async function (packageName, options) {
    const { verify } = await Promise.resolve().then(() => __importStar(require('./commands/verify')));
    // Override CLI settings with --api-key value
    options.etherscanApiKey = options.apiKey;
    const cliSettings = (0, settings_1.resolveCliSettings)(options);
    await verify(packageName, cliSettings, options.preset, parseInt(options.chainId));
});
applyCommandsConfig(program.command('alter'), commandsConfig_1.default.alter).action(async function (packageName, command, options, flags) {
    const { alter } = await Promise.resolve().then(() => __importStar(require('./commands/alter')));
    const cliSettings = (0, settings_1.resolveCliSettings)(flags);
    // throw an error if the chainId is not consistent with the provider's chainId
    await (0, helpers_1.ensureChainIdConsistency)(cliSettings.providerUrl, flags.chainId);
    // note: for command below, pkgInfo is empty because forge currently supplies no package.json or anything similar
    const newUrl = await alter(packageName, flags.subpkg ? flags.subpkg.split(',') : [], parseInt(flags.chainId), cliSettings, flags.preset, {}, command, options, {});
    console.log(newUrl);
});
applyCommandsConfig(program.command('fetch'), commandsConfig_1.default.fetch).action(async function (packageName, ipfsHash, options) {
    const { fetch } = await Promise.resolve().then(() => __importStar(require('./commands/fetch')));
    if (!options.chainId) {
        const chainIdPrompt = await (0, prompts_1.default)({
            type: 'number',
            name: 'value',
            message: 'Please provide the Chain ID for the deployment you want to fetch',
            initial: 13370,
        });
        if (!chainIdPrompt.value) {
            console.log('Chain ID is required.');
            process.exit(1);
        }
        options.chainId = chainIdPrompt.value;
    }
    await fetch(packageName, parseInt(options.chainId), ipfsHash, options.metaHash);
});
applyCommandsConfig(program.command('pin'), commandsConfig_1.default.pin).action(async function (ipfsHash, options) {
    const cliSettings = (0, settings_1.resolveCliSettings)(options);
    ipfsHash = ipfsHash.replace(/^ipfs:\/\//, '');
    const fromStorage = new builder_1.CannonStorage(await (0, registry_1.createDefaultReadRegistry)(cliSettings), (0, loader_1.getMainLoader)(cliSettings));
    const toStorage = new builder_1.CannonStorage(new builder_1.InMemoryRegistry(), {
        ipfs: new builder_1.IPFSLoader(cliSettings.publishIpfsUrl || (0, builder_1.getCannonRepoRegistryUrl)()),
    });
    console.log('Uploading package data for pinning...');
    await (0, builder_1.publishPackage)({
        packageRef: '@ipfs:' + ipfsHash,
        chainId: 13370,
        tags: [], // when passing no tags, it will only copy IPFS files, but not publish to registry
        fromStorage,
        toStorage,
    });
    console.log('Done!');
});
applyCommandsConfig(program.command('publish'), commandsConfig_1.default.publish).action(async function (packageRef, options) {
    const { publish } = await Promise.resolve().then(() => __importStar(require('./commands/publish')));
    const cliSettings = (0, settings_1.resolveCliSettings)(options);
    if (!options.chainId) {
        const chainIdPrompt = await (0, prompts_1.default)({
            type: 'number',
            name: 'value',
            message: 'Please provide the Chain ID for the package you want to publish',
            initial: 13370,
        });
        if (!chainIdPrompt.value) {
            throw new Error('A valid Chain Id is required.');
        }
        options.chainId = chainIdPrompt.value;
    }
    if (!cliSettings.privateKey) {
        const keyPrompt = await (0, prompts_1.default)({
            type: 'text',
            name: 'value',
            message: 'Enter the private key for an address that has permission to publish',
            style: 'password',
            validate: (key) => (0, helpers_1.isPrivateKey)((0, helpers_1.normalizePrivateKey)(key)) || 'Private key is not valid',
        });
        if (!keyPrompt.value) {
            throw new Error('A valid private key is required.');
        }
        cliSettings.privateKey = (0, helpers_1.checkAndNormalizePrivateKey)(keyPrompt.value);
    }
    const registryProviders = await (0, provider_1.resolveRegistryProviders)(cliSettings);
    // Initialize pickedRegistryProvider with the first provider
    let [pickedRegistryProvider] = registryProviders;
    // if it's using the default config, prompt the user to choose a registry provider
    const isDefaultSettings = lodash_1.default.isEqual(cliSettings.registries, builder_1.DEFAULT_REGISTRY_CONFIG);
    if (isDefaultSettings) {
        const choices = registryProviders.map((p) => ({
            title: `${p.provider.chain?.name ?? 'Unknown Network'} (Chain ID: ${p.provider.chain?.id})`,
            value: p,
        }));
        // Override pickedRegistryProvider with the selected provider
        pickedRegistryProvider = (await (0, prompts_1.default)([
            {
                type: 'select',
                name: 'pickedRegistryProvider',
                message: 'Which registry would you like to use? (Cannon will find the package on either.):',
                choices,
            },
        ])).pickedRegistryProvider;
    }
    else {
        // the user has customized the provider and chain id, verify inputs
        console.log(`You are about to publish a package to a custom registry on: ${pickedRegistryProvider.provider.chain?.name}`);
    }
    if (isDefaultSettings) {
        // Check if the package is already registered
        const [optimism, mainnet] = builder_1.DEFAULT_REGISTRY_CONFIG;
        const [optimismProvider, mainnetProvider] = await (0, provider_1.resolveRegistryProviders)(cliSettings);
        const isRegistered = await (0, register_1.isPackageRegistered)([mainnetProvider, optimismProvider], packageRef, [
            mainnet.address,
            optimism.address,
        ]);
        if (!isRegistered) {
            console.log();
            console.log((0, chalk_1.gray)(`Package "${packageRef.split(':')[0]}" not yet registered, please use "cannon register" to register your package first.\nYou need enough gas on Ethereum Mainnet to register the package on Cannon Registry`));
            console.log();
            const registerPrompt = await (0, prompts_1.default)({
                type: 'confirm',
                name: 'value',
                message: 'Would you like to register the package now?',
                initial: true,
            });
            if (!registerPrompt.value) {
                return process.exit(0);
            }
            const { register } = await Promise.resolve().then(() => __importStar(require('./commands/register')));
            await register({ cliSettings, options, packageRefs: [new builder_1.PackageReference(packageRef)], fromPublish: true });
        }
    }
    const overrides = {};
    if (options.maxFeePerGas) {
        overrides.maxFeePerGas = viem.parseGwei(options.maxFeePerGas);
    }
    if (options.gasLimit) {
        overrides.gasLimit = options.gasLimit;
    }
    if (options.value) {
        overrides.value = options.value;
    }
    const registryAddress = cliSettings.registries.find((registry) => registry.chainId === pickedRegistryProvider.provider.chain?.id)?.address ||
        builder_1.DEFAULT_REGISTRY_CONFIG[0].address;
    const onChainRegistry = new builder_1.OnChainRegistry({
        signer: pickedRegistryProvider.signers[0],
        provider: pickedRegistryProvider.provider,
        address: registryAddress,
        overrides,
    });
    console.log(`\nSettings:\n - Max Fee Per Gas: ${overrides.maxFeePerGas ? overrides.maxFeePerGas.toString() : 'default'}\n - Max Priority Fee Per Gas: ${overrides.maxPriorityFeePerGas ? overrides.maxPriorityFeePerGas.toString() : 'default'}\n - Gas Limit: ${overrides.gasLimit ? overrides.gasLimit : 'default'}\n` +
        " - To alter these settings use the parameters '--max-fee-per-gas', '--max-priority-fee-per-gas', '--gas-limit'.\n");
    await publish({
        packageRef,
        cliSettings,
        onChainRegistry,
        tags: options.tags ? options.tags.split(',') : undefined,
        chainId: options.chainId ? Number(options.chainId) : undefined,
        presetArg: options.preset ? options.preset : undefined,
        quiet: !!options.quiet,
        includeProvisioned: !options.excludeCloned,
        skipConfirm: !!options.skipConfirm,
    });
});
applyCommandsConfig(program.command('unpublish'), commandsConfig_1.default.unpublish).action(async function (packageRef, options) {
    const { unpublish } = await Promise.resolve().then(() => __importStar(require('./commands/unpublish')));
    const cliSettings = (0, settings_1.resolveCliSettings)(options);
    await unpublish({ cliSettings, options, packageRef });
});
applyCommandsConfig(program.command('register'), commandsConfig_1.default.register).action(async function (packageRef, options) {
    const { register } = await Promise.resolve().then(() => __importStar(require('./commands/register')));
    const cliSettings = (0, settings_1.resolveCliSettings)(options);
    await register({ cliSettings, options, packageRefs: packageRef, fromPublish: false });
});
applyCommandsConfig(program.command('publishers'), commandsConfig_1.default.publishers).action(async function (packageRef, options) {
    const { publishers } = await Promise.resolve().then(() => __importStar(require('./commands/publishers')));
    const cliSettings = (0, settings_1.resolveCliSettings)(options);
    await publishers({ cliSettings, options, packageRef });
});
applyCommandsConfig(program.command('inspect'), commandsConfig_1.default.inspect).action(async function (packageName, options) {
    const { inspect } = await Promise.resolve().then(() => __importStar(require('./commands/inspect')));
    const cliSettings = (0, settings_1.resolveCliSettings)(options);
    await inspect(packageName, cliSettings, options.chainId, options.preset, options.json, options.writeDeployments, options.sources);
});
applyCommandsConfig(program.command('prune'), commandsConfig_1.default.prune).action(async function (options) {
    const { prune } = await Promise.resolve().then(() => __importStar(require('./commands/prune')));
    const cliSettings = (0, settings_1.resolveCliSettings)(options);
    const registry = await (0, registry_1.createDefaultReadRegistry)(cliSettings);
    const loader = (0, loader_1.getMainLoader)(cliSettings);
    const storage = new builder_1.CannonStorage(registry, loader);
    console.log('Scanning for storage artifacts to prune (this may take some time)...');
    const [pruneUrls, pruneStats] = await prune(storage, options.filterPackage?.split(',') || '', options.filterVariant?.split(',') || '', options.keepAge);
    if (pruneUrls.length) {
        console.log((0, chalk_1.bold)(`Found ${pruneUrls.length} storage artifacts to prune.`));
        console.log(`Matched with Registry: ${pruneStats.matchedFromRegistry}`);
        console.log(`Not Expired: ${pruneStats.notExpired}`);
        console.log(`Not Cannon Package: ${pruneStats.notCannonPackage}`);
        if (options.dryRun) {
            process.exit(0);
        }
        if (!options.yes) {
            const verification = await (0, prompts_1.default)({
                type: 'confirm',
                name: 'confirmation',
                message: 'Delete these artifacts?',
                initial: true,
            });
            if (!verification.confirmation) {
                console.log('Cancelled');
                process.exit(1);
            }
        }
        for (const url of pruneUrls) {
            console.log(`delete ${url}`);
            try {
                await storage.deleteBlob(url);
            }
            catch (err) {
                console.error(`Failed to delete ${url}: ${err.message}`);
            }
        }
        console.log('Done!');
    }
    else {
        console.log((0, chalk_1.bold)('Nothing to prune.'));
    }
});
applyCommandsConfig(program.command('trace'), commandsConfig_1.default.trace).action(async function (packageRef, data, options) {
    const { trace } = await Promise.resolve().then(() => __importStar(require('./commands/trace')));
    const cliSettings = (0, settings_1.resolveCliSettings)(options);
    const isProviderUrl = (0, provider_1.isURL)(cliSettings.providerUrl);
    let chainId = options.chainId ? Number(options.chainId) : undefined;
    if (!chainId && isProviderUrl) {
        chainId = await (0, provider_1.getChainIdFromProviderUrl)(cliSettings.providerUrl);
    }
    // throw an error if both chainId and providerUrl are not provided
    if (!chainId && !isProviderUrl) {
        throw new Error('Please provide one of the following options: --chain-id or --provider-url');
    }
    // throw an error if the chainId is not consistent with the provider's chainId
    await (0, helpers_1.ensureChainIdConsistency)(cliSettings.providerUrl, chainId);
    await trace({
        packageRef,
        data,
        chainId: chainId, // chainId is guaranteed to be defined here
        preset: options.preset,
        cliSettings,
        from: options.from,
        to: options.to,
        value: options.value,
        block: options.blockNumber,
        json: options.json,
    });
});
applyCommandsConfig(program.command('decode'), commandsConfig_1.default.decode).action(async function (packageRef, data, options) {
    const { decode } = await Promise.resolve().then(() => __importStar(require('./commands/decode')));
    await decode({
        packageRef,
        data,
        chainId: parseInt(options.chainId || builder_1.CANNON_CHAIN_ID),
        presetArg: options.preset,
        json: options.json,
    });
});
applyCommandsConfig(program.command('test'), commandsConfig_1.default.test).action(async function (cannonfile, forgeOpts, options) {
    options.port = 0;
    const cliSettings = (0, settings_1.resolveCliSettings)(options);
    if (cliSettings.providerUrl.startsWith('https')) {
        options.dryRun = true;
    }
    // throw an error if the chainId is not consistent with the provider's chainId
    await (0, helpers_1.ensureChainIdConsistency)(cliSettings.providerUrl, options.chainId);
    const [node, , outputs] = await (0, build_1.doBuild)(cannonfile, [], options);
    // basically we need to write deployments here
    await (0, write_deployments_1.writeModuleDeployments)(node_path_1.default.join(process.cwd(), 'deployments/test'), '', outputs);
    // after the build is done we can run the forge tests for the user
    await (0, rpc_1.getProvider)(node).mine({ blocks: 1 });
    const forgeProcess = (0, node_child_process_1.spawn)('forge', [options.forgeCmd, '--fork-url', node.host, ...forgeOpts], { stdio: 'inherit' });
    await new Promise(() => {
        forgeProcess.on('close', (code) => {
            console.log(`forge exited with code ${code}`);
            node?.kill();
            process.exit(code);
        });
    });
});
applyCommandsConfig(program.command('interact'), commandsConfig_1.default.interact).action(async function (packageDefinition, options) {
    const cliSettings = (0, settings_1.resolveCliSettings)(options);
    let chainId = options.chainId ? Number(options.chainId) : undefined;
    const isProviderUrl = (0, provider_1.isURL)(cliSettings.providerUrl);
    // if chainId is not provided, get it from the provider
    if (!chainId && isProviderUrl) {
        chainId = await (0, provider_1.getChainIdFromProviderUrl)(cliSettings.providerUrl);
    }
    // throw an error if both chainId and providerUrl are not provided
    if (!chainId && !isProviderUrl) {
        throw new Error('Please provide one of the following options: --chain-id or --provider-url');
    }
    // throw an error if the chainId is not consistent with the provider's chainId
    await (0, helpers_1.ensureChainIdConsistency)(cliSettings.providerUrl, chainId);
    const { provider, signers } = await (0, provider_1.resolveWriteProvider)(cliSettings, chainId);
    const resolver = await (0, registry_1.createDefaultReadRegistry)(cliSettings);
    const [name, version] = [packageDefinition.name, packageDefinition.version];
    let preset = packageDefinition.preset;
    // Handle deprecated preset specification
    if (options.preset) {
        console.warn((0, chalk_1.yellow)((0, chalk_1.bold)('The --preset option will be deprecated soon. Reference presets in the package reference using the format name:version@preset')));
        preset = options.preset;
    }
    const fullPackageRef = builder_1.PackageReference.from(name, version, preset).fullPackageRef;
    const runtime = new builder_1.ChainBuilderRuntime({
        provider,
        chainId: chainId, // chainId is guaranteed to be defined here
        async getSigner(address) {
            // on test network any user can be conjured
            //await p.provider.impersonateAccount({ address: addr });
            //await p.provider.setBalance({ address: addr, value: viem.parseEther('10000') });
            return { address: address, wallet: provider };
        },
        snapshots: false,
        allowPartialDeploy: false,
        gasPrice: options.gasPrice,
        gasFee: options.maxGasFee,
        priorityGasFee: options.maxPriorityFee,
    }, resolver, (0, loader_1.getMainLoader)(cliSettings));
    const deployData = await runtime.readDeploy(fullPackageRef, runtime.chainId);
    if (!deployData) {
        throw new Error(`deployment not found for package: ${fullPackageRef}. please make sure it exists for the given preset and current network.`);
    }
    const outputs = await (0, builder_1.getOutputs)(runtime, new builder_1.ChainDefinition(deployData.def), deployData.state);
    if (!outputs) {
        throw new Error(`no cannon build found for chain ${chainId} with preset "${preset}". Did you mean to run the package instead?`);
    }
    const contracts = [(0, contracts_recursive_1.getContractsRecursive)(outputs)];
    const extendedProvider = provider.extend((0, builder_1.traceActions)(outputs));
    await (0, interact_1.interact)({
        packages: [packageDefinition],
        contracts,
        signer: signers[0],
        provider: extendedProvider,
    });
});
applyCommandsConfig(program.command('setup'), commandsConfig_1.default.setup).action(async function () {
    const { setup } = await Promise.resolve().then(() => __importStar(require('./commands/setup')));
    await setup();
});
applyCommandsConfig(program.command('clean'), commandsConfig_1.default.clean).action(async function ({ noConfirm }) {
    const { clean } = await Promise.resolve().then(() => __importStar(require('./commands/clean')));
    const executed = await clean(!noConfirm);
    if (executed)
        console.log('Complete!');
});
const pluginCmd = applyCommandsConfig(program.command('plugin'), commandsConfig_1.default.plugin);
applyCommandsConfig(pluginCmd.command('list'), commandsConfig_1.default.plugin.commands.list).action(async function () {
    console.log((0, chalk_1.green)((0, chalk_1.bold)('\n=============== Installed Plug-ins ===============')));
    const installedPlugins = await (0, plugins_1.listInstalledPlugins)();
    installedPlugins.forEach((plugin) => console.log((0, chalk_1.yellow)(plugin)));
});
applyCommandsConfig(pluginCmd.command('add'), commandsConfig_1.default.plugin.commands.add).action(async function (name) {
    console.log(`Installing plug-in ${name}...`);
    await (0, plugins_1.installPlugin)(name);
    console.log('Complete!');
});
applyCommandsConfig(pluginCmd.command('remove'), commandsConfig_1.default.plugin.commands.remove).action(async function (name) {
    console.log(`Removing plugin ${name}...`);
    await (0, plugins_1.removePlugin)(name);
    console.log('Complete!');
});
exports.default = program;
//# sourceMappingURL=index.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.publishers = void 0;
const builder_1 = require("@usecannon/builder");
const lodash_1 = __importDefault(require("lodash"));
const debug_1 = __importDefault(require("debug"));
const viem = __importStar(require("viem"));
const prompts_1 = __importDefault(require("prompts"));
const chalk_1 = require("chalk");
const helpers_1 = require("../helpers");
const provider_1 = require("../util/provider");
const register_1 = require("../util/register");
const debug = (0, debug_1.default)('cannon:cli:publishers');
var Network;
(function (Network) {
    Network["OP"] = "OP";
    Network["MAINNET"] = "ETH";
})(Network || (Network = {}));
async function publishers({ cliSettings, options, packageRef }) {
    // throw an error if the user has not provided any addresses
    if (!options.add && !options.remove) {
        throw new Error('Please provide either --add or --remove option');
    }
    if (cliSettings.isE2E) {
        // anvil optimism fork
        cliSettings.registries[0].providerUrl = ['http://127.0.0.1:9546'];
        // anvil mainnet fork
        cliSettings.registries[1].providerUrl = ['http://127.0.0.1:9545'];
    }
    debug('Registries list: ', cliSettings.registries);
    const publishersToAdd = options.add
        ? options.add.split(',').map((p) => viem.getAddress(p.trim()))
        : undefined;
    const publishersToRemove = options.remove
        ? options.remove.split(',').map((p) => viem.getAddress(p.trim()))
        : undefined;
    // throw an error if the user has provided invalid addresses
    if (publishersToAdd && !publishersToAdd.every((p) => viem.isAddress(p))) {
        throw new Error('Invalid address provided for --add option');
    }
    if (publishersToRemove && !publishersToRemove.every((p) => viem.isAddress(p))) {
        throw new Error('Invalid address provided for --remove option');
    }
    // Check if both options provided and addresses are the repeated
    if (publishersToAdd &&
        publishersToRemove &&
        publishersToAdd.some((p) => publishersToRemove.some((p1) => viem.isAddressEqual(p, p1)))) {
        throw new Error('Cannot add and remove the same address in one operation');
    }
    if (!cliSettings.privateKey) {
        const keyPrompt = await (0, prompts_1.default)({
            type: 'text',
            name: 'value',
            message: 'Enter the private key of the package owner',
            style: 'password',
            validate: (key) => (0, helpers_1.isPrivateKey)((0, helpers_1.normalizePrivateKey)(key)) || 'Private key is not valid',
        });
        if (!keyPrompt.value) {
            throw new Error('A valid private key is required.');
        }
        cliSettings.privateKey = (0, helpers_1.checkAndNormalizePrivateKey)(keyPrompt.value);
    }
    const isDefaultSettings = lodash_1.default.isEqual(cliSettings.registries, builder_1.DEFAULT_REGISTRY_CONFIG);
    if (!isDefaultSettings)
        throw new Error('Only default registries are supported for now');
    let selectedNetwork = '';
    if (!options.optimism && !options.mainnet) {
        selectedNetwork = (await (0, prompts_1.default)({
            type: 'select',
            name: 'value',
            message: 'Where do you want to add or remove publishers?',
            choices: [
                { title: 'Optimism', value: Network.OP },
                { title: 'Ethereum Mainnet', value: Network.MAINNET },
            ],
            initial: 0,
        })).value;
    }
    else {
        selectedNetwork = options.optimism ? Network.OP : Network.MAINNET;
    }
    const isMainnet = selectedNetwork === Network.MAINNET;
    const [optimismRegistryConfig, mainnetRegistryConfig] = cliSettings.registries;
    const [optimismRegistryProvider, mainnetRegistryProvider] = await (0, provider_1.resolveRegistryProviders)(cliSettings);
    const overrides = {};
    if (options.maxFeePerGas) {
        overrides.maxFeePerGas = viem.parseGwei(options.maxFeePerGas);
    }
    if (options.gasLimit) {
        overrides.gasLimit = options.gasLimit;
    }
    if (options.value) {
        overrides.value = options.value;
    }
    const mainnetRegistry = new builder_1.OnChainRegistry({
        signer: mainnetRegistryProvider.signers[0],
        provider: mainnetRegistryProvider.provider,
        address: mainnetRegistryConfig.address,
        overrides,
    });
    const optimismRegistry = new builder_1.OnChainRegistry({
        signer: optimismRegistryProvider.signers[0],
        provider: optimismRegistryProvider.provider,
        address: optimismRegistryConfig.address,
        overrides,
    });
    const userAddress = mainnetRegistryProvider.signers[0].address;
    const packageName = new builder_1.PackageReference(packageRef).name;
    const packageOwner = await mainnetRegistry.getPackageOwner(packageName);
    // throw an error if the package is not registered
    if (viem.isAddressEqual(packageOwner, viem.zeroAddress)) {
        throw new Error('The package is not registered already.');
    }
    // throw an error if the package is not registered by the user address
    if (!viem.isAddressEqual(packageOwner, userAddress)) {
        throw new Error(`Unauthorized: The package "${packageName}" is already registered by "${packageOwner}".`);
    }
    const [mainnetCurrentPublishers, optimismCurrentPublishers] = await Promise.all([
        mainnetRegistry.getAdditionalPublishers(packageName),
        optimismRegistry.getAdditionalPublishers(packageName),
    ]);
    const currentPublishers = isMainnet ? mainnetCurrentPublishers : optimismCurrentPublishers;
    // copy the current publishers
    let publishers = [...currentPublishers];
    // remove publisher if specified
    if (publishersToRemove) {
        publishers = publishers.filter((p) => !publishersToRemove.some((toRemove) => viem.isAddressEqual(p, toRemove)));
    }
    // add new publisher if specified
    if (publishersToAdd) {
        publishersToAdd.forEach((p) => {
            if (!publishers.some((p1) => viem.isAddressEqual(p, p1))) {
                publishers.push(p);
            }
        });
    }
    // throw an error if the publishers list is already up to date
    if (lodash_1.default.isEqual(currentPublishers, publishers)) {
        throw new Error('The publishers list is already up to date.');
    }
    console.log();
    console.log('The publishers list will be updated as follows:');
    publishers.forEach((publisher) => console.log(` - ${publisher} (${isMainnet ? 'Ethereum Mainnet' : 'OP Mainnet'})`));
    const restOfPublishers = !isMainnet ? mainnetCurrentPublishers : optimismCurrentPublishers;
    restOfPublishers.forEach((publisher) => console.log(` - ${publisher} (${!isMainnet ? 'Ethereum Mainnet' : 'OP Mainnet'})`));
    console.log();
    if (!options.skipConfirm) {
        const confirm = await (0, prompts_1.default)({
            type: 'confirm',
            name: 'confirmation',
            message: 'Proceed?',
        });
        if (!confirm.confirmation) {
            console.log('Cancelled');
            process.exit(1);
        }
    }
    const mainnetPublishers = isMainnet ? publishers : mainnetCurrentPublishers;
    const optimismPublishers = isMainnet ? optimismCurrentPublishers : publishers;
    const packageNameHex = viem.stringToHex(packageName, { size: 32 });
    const [hash] = await Promise.all([
        (async () => {
            const hash = await mainnetRegistry.setAdditionalPublishers(packageName, mainnetPublishers, optimismPublishers);
            console.log(`${(0, chalk_1.green)('Success!')} (${(0, chalk_1.blueBright)('Transaction Hash')}: ${hash})`);
            console.log('');
            console.log((0, chalk_1.gray)(`Waiting for the transaction to propagate to ${optimismRegistryConfig.name}... It may take approximately 1-3 minutes.`));
            console.log('');
            return hash;
        })(),
        (async () => {
            // this should always resolve after the first promise but we want to make sure it runs at the same time
            await Promise.all([
                (0, register_1.waitForEvent)({
                    eventName: 'PackagePublishersChanged',
                    abi: mainnetRegistry.contract.abi,
                    providerUrl: mainnetRegistryConfig.providerUrl[0],
                    expectedArgs: {
                        name: packageNameHex,
                        publisher: mainnetPublishers,
                    },
                }),
                (0, register_1.waitForEvent)({
                    eventName: 'PackagePublishersChanged',
                    abi: optimismRegistry.contract.abi,
                    providerUrl: optimismRegistryConfig.providerUrl[0],
                    expectedArgs: {
                        name: packageNameHex,
                        publisher: optimismPublishers,
                    },
                }),
            ]);
            console.log((0, chalk_1.green)('Success - The publishers list has been updated!'));
            console.log('');
        })(),
    ]);
    return hash;
}
exports.publishers = publishers;
//# sourceMappingURL=publishers.js.map
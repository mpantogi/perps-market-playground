"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderArgs = exports.stringifyWithOffset = exports.interact = void 0;
const lodash_1 = __importDefault(require("lodash"));
const viem = __importStar(require("viem"));
const prompts_1 = __importDefault(require("prompts"));
const chalk_1 = require("chalk");
const builder_1 = require("@usecannon/builder");
const helpers_1 = require("../helpers");
const chains_1 = require("../chains");
const PROMPT_BACK_OPTION = { title: '↩ BACK' };
async function interact(ctx) {
    // -----------------
    // Start interaction
    // -----------------
    await printHeader(ctx);
    let pickedPackage = -1;
    let pickedContract = null;
    let pickedFunction = null;
    let currentArgs = null;
    let txnValue = BigInt(0);
    // eslint-disable-next-line no-constant-condition
    while (true) {
        if (ctx.packages.length === 1) {
            pickedPackage = 0;
        }
        if (pickedPackage === -1) {
            pickedPackage = await pickPackage(ctx.packages);
            if (pickedPackage === -1) {
                return null;
            }
        }
        else if (!pickedContract) {
            pickedContract = await pickContract({
                contractNames: Object.keys(ctx.contracts[pickedPackage]),
                contractArtifacts: ctx.packagesArtifacts?.[pickedPackage]?.contracts,
            });
            if (!pickedContract) {
                if (ctx.packages.length === 1) {
                    return null;
                }
                pickedPackage = -1;
            }
        }
        else if (!pickedFunction) {
            await printHelpfulInfo(ctx, pickedPackage, pickedContract);
            pickedFunction = await pickFunction({
                contract: ctx.contracts[pickedPackage][pickedContract],
            });
            if (!pickedFunction) {
                pickedContract = null;
            }
        }
        else if (!currentArgs) {
            const argData = await pickFunctionArgs({
                func: pickedFunction,
            });
            if (!argData) {
                pickedFunction = null;
            }
            else {
                currentArgs = argData.args;
                txnValue = argData.value;
            }
        }
        else {
            const contract = ctx.contracts[pickedPackage][pickedContract];
            if (ctx.packagesArtifacts) {
                ctx.provider = ctx.provider.extend((0, builder_1.traceActions)(ctx.packagesArtifacts[pickedPackage]));
            }
            if (pickedFunction.stateMutability === 'view' || pickedFunction.stateMutability === 'pure') {
                await query({
                    provider: ctx.provider,
                    contract,
                    functionAbi: pickedFunction,
                    args: currentArgs,
                    blockTag: ctx.blockTag,
                });
            }
            else if (!ctx.signer) {
                console.log();
                console.log((0, chalk_1.red)('  Signer is not supplied. cannot invoke writable function.'));
                console.log();
            }
            else {
                const receipt = await execTxn({
                    provider: ctx.provider,
                    signer: ctx.signer,
                    contract,
                    functionAbi: pickedFunction,
                    args: currentArgs,
                    value: txnValue,
                });
                if (receipt?.status === 'success') {
                    await logTxSucceed(ctx, receipt);
                }
                else {
                    logTxFail('tx did not succeed');
                }
            }
            // return to function select
            pickedFunction = null;
            currentArgs = null;
        }
    }
}
exports.interact = interact;
async function printHeader(ctx) {
    // retrieve balance of the signer address
    // this isnt always necessary but it serves as a nice test that the provider is working
    // and prevents the UI from lurching later if its queried later
    const signerBalance = ctx.signer ? await ctx.provider.getBalance({ address: ctx.signer.address }) : BigInt(0);
    console.log('\n');
    console.log((0, chalk_1.gray)('================================================================================'));
    console.log((0, chalk_1.gray)('> Gas price: provider default'));
    console.log((0, chalk_1.gray)(`> Block tag: ${ctx.blockTag || 'latest'}`));
    if (ctx.signer) {
        console.log((0, chalk_1.yellow)(`> Read/Write: ${ctx.signer.address}`));
        if (signerBalance > viem.parseEther('0.01')) {
            console.log((0, chalk_1.green)(`> Signer Balance: ${viem.formatEther(signerBalance)}`));
        }
        else {
            console.log((0, chalk_1.red)(`> WARNING! Low signer balance: ${viem.formatEther(signerBalance)}`));
        }
    }
    else {
        console.log((0, chalk_1.gray)('> Read Only'));
    }
    console.log((0, chalk_1.gray)('================================================================================'));
    console.log('\n');
}
async function printHelpfulInfo(ctx, pickedPackage, pickedContract) {
    if (pickedContract) {
        console.log(chalk_1.gray.inverse(`${pickedContract} => ${ctx.contracts[pickedPackage][pickedContract].address}`));
    }
    console.log((0, chalk_1.gray)(`  * Signer: ${ctx.signer ? ctx.signer.address : 'None'}`));
    console.log('\n');
}
async function pickPackage(packages) {
    const choices = packages.map((p, i) => ({
        title: `${p.name}:${p.version}`,
        value: i,
        description: Object.entries(p.settings)
            .map(([k, v]) => `${k}=${v}`)
            .join(' | '),
    }));
    choices.unshift({ ...PROMPT_BACK_OPTION, value: -1 });
    const { pickedPackage } = await prompts_1.default.prompt([
        {
            type: 'select',
            name: 'pickedPackage',
            message: 'Pick a PACKAGE:',
            choices,
        },
    ]);
    return typeof pickedPackage === 'number' ? pickedPackage : -1;
}
async function pickContract({ contractNames, contractArtifacts, }) {
    const isHighlighted = (n) => !!contractArtifacts?.[n]?.highlight ?? false;
    const choices = lodash_1.default.sortBy(contractNames, [
        (contractName) => !isHighlighted(contractName),
        (contractName) => contractName,
    ]).map((contractName) => ({
        title: isHighlighted(contractName) ? (0, chalk_1.bold)(contractName) : contractName,
        value: contractName,
    }));
    choices.unshift(PROMPT_BACK_OPTION);
    const { pickedContract } = await prompts_1.default.prompt([
        {
            type: 'autocomplete',
            name: 'pickedContract',
            message: 'Pick a CONTRACT:',
            choices,
            suggest: suggestBySubtring,
        },
    ]);
    return pickedContract === PROMPT_BACK_OPTION.title ? null : pickedContract;
}
function assembleFunctionSignatures(abi) {
    const abiFunctions = abi.filter((v) => v.type === 'function');
    const prettyNames = abiFunctions.map(helpers_1.formatAbiFunction);
    return [abiFunctions, prettyNames];
}
async function pickFunction({ contract }) {
    const [abiFunctions, functionSignatures] = assembleFunctionSignatures(contract.abi);
    const choices = lodash_1.default.sortBy(functionSignatures).map((s) => ({ title: s }));
    choices.unshift(PROMPT_BACK_OPTION);
    const { pickedFunction } = await prompts_1.default.prompt([
        {
            type: 'autocomplete',
            name: 'pickedFunction',
            message: 'Pick a FUNCTION:',
            choices,
            suggest: suggestBySubtring,
        },
    ]);
    return pickedFunction == PROMPT_BACK_OPTION.title ? null : abiFunctions[functionSignatures.indexOf(pickedFunction)];
}
async function pickFunctionArgs({ func }) {
    const args = [];
    let value = BigInt(0);
    if (func.stateMutability === 'payable') {
        const { txnValue } = await prompts_1.default.prompt([
            {
                type: 'text',
                name: 'txnValue',
                message: 'Function is payable. ETH AMOUNT (in eth units):',
            },
        ]);
        value = viem.parseEther(txnValue);
    }
    for (const input of func.inputs) {
        const rawValue = await promptInputValue(input);
        if (lodash_1.default.isNil(rawValue)) {
            return null;
        }
        args.push(rawValue);
    }
    return { args, value };
}
async function query({ provider, contract, functionAbi, args, blockTag, }) {
    const callData = viem.encodeFunctionData({
        abi: [functionAbi],
        functionName: functionAbi.name,
        args,
    });
    console.log((0, chalk_1.gray)(`  > calldata: ${callData}`));
    let result = [];
    const callArgs = {
        address: contract.address,
        abi: [functionAbi],
        functionName: functionAbi.name,
        args,
        blockTag: blockTag,
    };
    try {
        console.log((0, chalk_1.gray)(`  > estimated gas required: ${await provider.estimateContractGas(callArgs)}`));
        const simulation = await provider.simulateContract(callArgs);
        result = simulation.result;
    }
    catch (err) {
        console.error('failed query:', err?.message && process.env.TRACE !== 'true' ? err?.message : err);
        return null;
    }
    for (let i = 0; i < functionAbi.outputs.length; i++) {
        const output = functionAbi.outputs[i];
        console.log((0, chalk_1.cyan)(`  ↪ ${output.name || ''}(${output.type}):`), renderArgs(output, functionAbi.outputs.length > 1 ? result[i] : result));
    }
    return result;
}
async function execTxn({ contract, functionAbi, args, value, provider, signer, }) {
    const callData = viem.encodeFunctionData({
        abi: [functionAbi],
        functionName: functionAbi.name,
        args,
    });
    let txn = null;
    // estimate gas
    try {
        const chain = (0, chains_1.getChainById)(await provider.getChainId());
        txn = (await provider.prepareTransactionRequest({
            account: signer.wallet.account || signer.address,
            chain,
            to: contract.address,
            data: callData,
            value: value || 0,
        }));
        console.log((0, chalk_1.gray)(`  > calldata: ${txn.data}`));
        console.log((0, chalk_1.gray)(`  > estimated gas required: ${txn.gas}`));
        console.log((0, chalk_1.gray)(`  > gas: ${JSON.stringify(lodash_1.default.mapValues(lodash_1.default.pick(txn, 'gasPrice', 'maxFeePerGas', 'maxPriorityFeePerGas'), viem.formatGwei))}`));
        console.log((0, chalk_1.green)((0, chalk_1.bold)('  ✅ txn will succeed')));
    }
    catch (err) {
        console.error((0, chalk_1.red)(`❌ txn will most likely fail: ${err.toString()}`));
    }
    if (signer != null) {
        const { confirmation } = await prompts_1.default.prompt([
            {
                type: 'confirm',
                name: 'confirmation',
                message: 'Send transaction?',
            },
        ]);
        if (!confirmation) {
            return null;
        }
        let txHash;
        try {
            txHash = await signer.wallet.sendTransaction({
                ...txn,
            });
            console.log('> hash: ', txHash);
            console.log('confirming...');
            const receipt = await provider.waitForTransactionReceipt({ hash: txHash });
            return receipt;
        }
        catch (err) {
            logTxFail(err);
            return null;
        }
    }
    else {
        console.log('not submitting transaction because in read-only mode');
    }
}
async function promptInputValue(input) {
    const name = input.name || input.type;
    const message = input.name ? `${input.name} (${input.type})` : input.type;
    for (let i = 0; i < 5; i++) {
        try {
            const answer = await prompts_1.default.prompt([
                {
                    type: 'text',
                    message,
                    name,
                },
            ]);
            // if there is a problem this will throw and user will be forced to re-enter data
            return parseInput(input, answer[name]);
        }
        catch (err) {
            console.error('invalid input: ', err);
        }
    }
}
function parseInput(input, rawValue) {
    const isTuple = input.type.includes('tuple');
    const isBytes32 = input.type.includes('bytes32');
    const isArray = input.type.includes('[]');
    const isNumber = input.type.includes('int');
    const isBoolean = input.type.includes('bool');
    let processed = isArray || isTuple ? JSON.parse(rawValue) : rawValue;
    if (isBytes32 && !viem.isHex(processed)) {
        if (isArray) {
            processed = processed.map((item) => viem.stringToHex(item, { size: 32 }));
        }
        else {
            processed = viem.stringToHex(processed, { size: 32 });
        }
    }
    if (isNumber) {
        if (isArray) {
            processed = processed.map((item) => parseWeiValue(item));
        }
        else {
            processed = parseWeiValue(processed);
        }
    }
    if (isArray) {
        processed = processed.map((value) => boolify(value));
    }
    if (isBoolean) {
        switch (processed.toLowerCase()) {
            case 'false':
            case '0':
            case 'no':
                processed = false;
                break;
            case 'true':
            case '1':
            case 'yes':
                processed = true;
                break;
            default:
                processed = null;
        }
    }
    //const processed = preprocessInput(input, type, hre);
    if (processed !== rawValue) {
        console.log((0, chalk_1.gray)(`  > processed inputs (${isArray ? processed.length : '1'}):`, processed));
    }
    // Encode user's input to validate it
    viem.encodeAbiParameters([input], [processed]);
    return processed;
}
function parseWeiValue(v) {
    if (v.includes('.')) {
        return viem.parseEther(v);
    }
    else {
        return BigInt(v);
    }
}
/**
 * Checks if a given ABI parameter is a tuple with components.
 *
 * This function acts as a type guard, allowing TypeScript to understand
 * that the parameter passed to it, if the function returns true,
 * is not just any AbiParameter, but specifically one that includes
 * the 'components' property.
 *
 * @param {viem.AbiParameter} parameter - The ABI parameter to check.
 * @returns {boolean} - True if the parameter is a tuple with components, false otherwise.
 */
function _isTupleParameter(parameter) {
    return 'components' in parameter && parameter.type.startsWith('tuple');
}
/**
 * Converts an object to a prettified JSON string with a specified indentation and offset.
 *
 * @param {any} obj - The object to be converted into a JSON string.
 * @param {number} offsetSpaces - The number of spaces to offset the entire JSON string. Default is 4.
 * @param {number} indentSpaces - The number of spaces used for indentation in the JSON string. Default is 2.
 * @returns {string} - The prettified and offset JSON string.
 */
function stringifyWithOffset(obj, offsetSpaces = 4, indentSpaces = 2) {
    const jsonString = JSON.stringify(obj, null, indentSpaces);
    const offset = ' '.repeat(offsetSpaces);
    return jsonString
        .split('\n')
        .map((line) => offset + line)
        .join('\n');
}
exports.stringifyWithOffset = stringifyWithOffset;
/**
 * Renders the arguments for a given ABI parameter and its associated value.
 * This function handles different data structures (tuples, arrays, uint, int, etc).
 *
 * @param {viem.AbiParameter} input - The ABI parameter describing the type and structure of the value.
 * @param {any} value - The value associated with the ABI parameter.
 * @param {string} offset - A string used for initial indentation, facilitating readable output formatting.
 * @returns {string} - A string representation of the argument, formatted for readability.
 */
function renderArgs(input, value, offset = ' ') {
    const lines = [];
    switch (true) {
        case _isTupleParameter(input):
            lines.push('', stringifyWithOffset(value));
            break;
        case input.type.endsWith('[]') && Array.isArray(value):
            lines.push('', stringifyWithOffset(value));
            break;
        default:
            lines.push(`${offset}${value.toString()}`);
    }
    return lines.join('\n');
}
exports.renderArgs = renderArgs;
// Avoid 'false' and '0' being interpreted as bool = true
function boolify(value) {
    if (value === 'false' || value === '0')
        return 0;
    return value;
}
async function logTxSucceed(ctx, receipt) {
    console.log((0, chalk_1.green)('  ✅ Success'));
    // console.log('receipt', JSON.stringify(receipt, null, 2));
    // Print tx hash
    console.log((0, chalk_1.gray)(`    tx hash: ${receipt.transactionHash}`));
    // Print gas used
    console.log((0, chalk_1.gray)(`    gas used: ${receipt.gasUsed.toString()}`));
    // Print emitted events
    if (receipt.logs && receipt.logs.length > 0) {
        const contractsByAddress = lodash_1.default.mapKeys(lodash_1.default.groupBy(lodash_1.default.flatten(ctx.contracts.map((contract) => lodash_1.default.toPairs(contract))), '1.address'), (v, k) => k.toLowerCase());
        for (let i = 0; i < receipt.logs.length; i++) {
            const log = receipt.logs[i];
            let foundLog = false;
            for (const [n, logContract] of contractsByAddress[log.address.toLowerCase()] || []) {
                try {
                    // find contract matching address of the log
                    const parsedLog = viem.decodeEventLog({ ...logContract, ...log });
                    foundLog = true;
                    console.log((0, chalk_1.gray)(`\n    log ${i}:`), (0, chalk_1.cyan)(parsedLog.eventName), (0, chalk_1.gray)(`\t${n}`));
                    //logContract.interface.getEvent(parsedLog.name).inputs[i]
                    // TODO: for some reason viem does not export `AbiEvent` type (even though they export other types like AbiFunction)
                    const eventAbiDef = viem.getAbiItem({ abi: logContract.abi, name: parsedLog.eventName });
                    for (const [a, arg] of (eventAbiDef.inputs || []).entries()) {
                        const output = parsedLog.args[arg.name || `${a}`];
                        console.log((0, chalk_1.cyan)(`  ↪ ${arg.name || ''}(${arg.type}):`), renderArgs(arg, output));
                    }
                    break;
                }
                catch (err) {
                    // nothing
                }
            }
            if (!foundLog) {
                console.log((0, chalk_1.gray)(`\n    log ${i}: unable to decode log - ${JSON.stringify(log)}`));
            }
        }
    }
}
function logTxFail(error) {
    console.log((0, chalk_1.red)('  ❌ Error'));
    function findReason(error) {
        if (typeof error === 'string') {
            return error;
        }
        else {
            if (lodash_1.default.get(error, 'reason')) {
                return error.reason;
            }
            else if (lodash_1.default.get(error, 'error')) {
                return findReason(error.error);
            }
        }
        return error.toString();
    }
    const reason = findReason(error);
    if (reason)
        console.log((0, chalk_1.red)(`    Reason: ${reason}`));
    console.log((0, chalk_1.gray)(JSON.stringify(error, null, 2)));
}
// filters choices by subtrings that don't have to be continuous e.g. 'ybtc' will match 'SynthsBTC'
const suggestBySubtring = (input, choices) => Promise.resolve(choices.filter((choice) => {
    const titleStr = choice.title.toLowerCase();
    let index = 0;
    for (const c of input.toLowerCase()) {
        index = titleStr.indexOf(c, index);
        if (index === -1) {
            return false; // not found
        }
        else {
            index += 1; // start from next index
        }
    }
    return true;
}));
//# sourceMappingURL=interact.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = void 0;
const axios_1 = __importDefault(require("axios"));
const debug_1 = __importDefault(require("debug"));
const viem = __importStar(require("viem"));
const chalk_1 = require("chalk");
const builder_1 = require("@usecannon/builder");
const package_1 = require("@usecannon/builder/dist/src/package");
const rpc_1 = require("../rpc");
const registry_1 = require("../registry");
const chains_1 = require("../chains");
const loader_1 = require("../loader");
const verify_1 = require("../util/verify");
const debug = (0, debug_1.default)('cannon:cli:verify');
async function verify(packageRef, cliSettings, presetArg, chainId) {
    // Handle deprecated preset specification
    if (presetArg) {
        console.warn((0, chalk_1.yellow)((0, chalk_1.bold)('The --preset option will be deprecated soon. Reference presets in the package reference using the format name:version@preset')));
        packageRef = packageRef.split('@')[0] + `@${presetArg}`;
    }
    const { fullPackageRef } = new package_1.PackageReference(packageRef);
    // create temporary provider
    // todo: really shouldn't be necessary
    const node = await (0, rpc_1.runRpc)({
        port: 30000 + Math.floor(Math.random() * 30000),
    });
    const provider = (0, rpc_1.getProvider)(node);
    const resolver = await (0, registry_1.createDefaultReadRegistry)(cliSettings);
    const runtime = new builder_1.ChainBuilderRuntime({
        provider,
        chainId: chainId,
        async getSigner(addr) {
            // on test network any user can be conjured
            return { address: addr, wallet: provider };
        },
        snapshots: false,
        allowPartialDeploy: false,
    }, resolver, (0, loader_1.getMainLoader)(cliSettings));
    const etherscanApi = cliSettings.etherscanApiUrl || (0, chains_1.getChainById)(chainId)?.blockExplorers?.default.apiUrl;
    if (!etherscanApi) {
        throw new Error(`couldn't find etherscan api url for network with ${chainId}. Please set your etherscan URL with CANNON_ETHERSCAN_API_URL`);
    }
    if (!cliSettings.etherscanApiKey) {
        throw new Error('Etherscan Api Key not supplied. Please set it with --api-key or CANNON_ETHERSCAN_API_KEY environment variable');
    }
    const guids = {};
    const verifyPackage = async (deployData) => {
        const miscData = await runtime.readBlob(deployData.miscUrl);
        debug('misc data', miscData);
        const outputs = await (0, builder_1.getOutputs)(runtime, new builder_1.ChainDefinition(deployData.def), deployData.state);
        if (!outputs) {
            throw new Error('No chain outputs found. Has the requested chain already been built?');
        }
        for (const c in outputs.contracts) {
            const contractInfo = outputs.contracts[c];
            // contracts can either be imported by just their name, or by a full path.
            // technically it may be more correct to just load by the actual name of the `artifact` property used, but that is complicated
            debug('finding contract:', contractInfo.sourceName, contractInfo.contractName);
            const contractArtifact = miscData.artifacts[contractInfo.contractName] ||
                miscData.artifacts[`${contractInfo.sourceName}:${contractInfo.contractName}`];
            if (!contractArtifact) {
                console.log(`${c}: cannot verify: no contract artifact found`);
                continue;
            }
            if (!contractArtifact.source) {
                console.log(`${c}: cannot verify: no source code recorded in deploy data`);
                continue;
            }
            if (await (0, verify_1.isVerified)(contractInfo.address, etherscanApi, cliSettings.etherscanApiKey)) {
                console.log(`✅ ${c}: Contract source code already verified`);
                continue;
            }
            try {
                // supply any linked libraries within the inputs since those are calculated at runtime
                const inputData = JSON.parse(contractArtifact.source.input);
                inputData.settings.libraries = contractInfo.linkedLibraries;
                const reqData = {
                    apikey: cliSettings.etherscanApiKey,
                    module: 'contract',
                    action: 'verifysourcecode',
                    contractaddress: contractInfo.address,
                    // need to parse to get the inner structure, then stringify again
                    sourceCode: JSON.stringify(inputData),
                    codeformat: 'solidity-standard-json-input',
                    contractname: `${contractInfo.sourceName}:${contractInfo.contractName}`,
                    compilerversion: 'v' + contractArtifact.source.solcVersion,
                    // NOTE: below: yes, the etherscan api is misspelling
                    constructorArguements: viem
                        .encodeAbiParameters(contractArtifact.abi.find((i) => i.type === 'constructor')?.inputs ?? [], contractInfo.constructorArgs || [])
                        .slice(2),
                };
                debug('verification request', reqData);
                const res = await axios_1.default.post(etherscanApi, reqData, {
                    headers: { 'content-type': 'application/x-www-form-urlencoded' },
                });
                if (res.data.status === '0') {
                    debug('etherscan failed', res.data);
                    console.log(`${c}:\tcannot verify:`, res.data.result);
                }
                else {
                    console.log(`${c}:\tsubmitted verification (${contractInfo.address})`);
                    guids[c] = res.data.result;
                }
            }
            catch (err) {
                console.log(`verification for ${c} (${contractInfo.address}) failed:`, err);
            }
            await sleep(500);
        }
        return {};
    };
    const deployData = await runtime.readDeploy(fullPackageRef, chainId);
    if (!deployData) {
        throw new Error(`deployment not found: ${fullPackageRef}. please make sure it exists for the given preset and current network.`);
    }
    // go through all the packages and sub packages and make sure all contracts are being verified
    await (0, package_1.forPackageTree)(runtime, deployData, verifyPackage);
    // at this point, all contracts should have been submitted for verification. so we are just printing status.
    for (const c in guids) {
        for (;;) {
            const res = await axios_1.default.post(etherscanApi, {
                apiKey: cliSettings.etherscanApiKey,
                module: 'contract',
                action: 'checkverifystatus',
                guid: guids[c],
            }, { headers: { 'content-type': 'application/x-www-form-urlencoded' } });
            if (res.data.status === '0') {
                if (res.data.result === 'Pending in queue') {
                    await sleep(1000);
                }
                else {
                    console.log(`❌ ${c}`, res.data.result);
                    console.log(res.data);
                    break;
                }
            }
            else {
                console.log(`✅ ${c}`);
                await sleep(500);
                break;
            }
        }
    }
    node.kill();
}
exports.verify = verify;
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
//# sourceMappingURL=verify.js.map
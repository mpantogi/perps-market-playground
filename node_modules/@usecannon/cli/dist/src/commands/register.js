"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const lodash_1 = __importDefault(require("lodash"));
const debug_1 = __importDefault(require("debug"));
const viem = __importStar(require("viem"));
const prompts_1 = __importDefault(require("prompts"));
const chalk_1 = require("chalk");
const builder_1 = require("@usecannon/builder");
const provider_1 = require("../util/provider");
const register_1 = require("../util/register");
const helpers_1 = require("../helpers");
const debug = (0, debug_1.default)('cannon:cli:register');
async function register({ cliSettings, options, packageRefs, fromPublish }) {
    if (!cliSettings.privateKey) {
        const keyPrompt = await (0, prompts_1.default)({
            type: 'text',
            name: 'value',
            message: 'Enter the private key for the signer that will register packages',
            style: 'password',
            validate: (key) => (0, helpers_1.isPrivateKey)((0, helpers_1.normalizePrivateKey)(key)) || 'Private key is not valid',
        });
        if (!keyPrompt.value) {
            throw new Error('A valid private key is required.');
        }
        cliSettings.privateKey = (0, helpers_1.checkAndNormalizePrivateKey)(keyPrompt.value);
    }
    const isDefaultSettings = lodash_1.default.isEqual(cliSettings.registries, builder_1.DEFAULT_REGISTRY_CONFIG);
    if (!isDefaultSettings)
        throw new Error('Only default registries are supported for now');
    // mock provider urls when the execution comes from e2e tests
    if (cliSettings.isE2E) {
        // anvil optimism fork
        cliSettings.registries[0].providerUrl = ['http://127.0.0.1:9546'];
        // anvil mainnet fork
        cliSettings.registries[1].providerUrl = ['http://127.0.0.1:9545'];
    }
    debug('Registries list: ', cliSettings.registries);
    const [optimismRegistryConfig, mainnetRegistryConfig] = cliSettings.registries;
    const [optimismRegistryProvider, mainnetRegistryProvider] = await (0, provider_1.resolveRegistryProviders)(cliSettings);
    // if any of the packages are registered, throw an error
    const isRegistered = await Promise.all(packageRefs.map(async (pkg) => {
        // Run the two registry checks in parallel
        const [isRegisteredOnOptimism, isRegisteredOnMainnet] = await Promise.all([
            (0, register_1.isPackageRegistered)([optimismRegistryProvider], pkg.name, [optimismRegistryConfig.address]),
            (0, register_1.isPackageRegistered)([mainnetRegistryProvider], pkg.name, [mainnetRegistryConfig.address]),
        ]);
        debug('Package name: ' +
            pkg.name +
            ' isRegisteredOnOptimism: ' +
            isRegisteredOnOptimism +
            ' isRegisteredOnMainnet: ' +
            isRegisteredOnMainnet);
        // Throw an error if the package is registered on both
        if (isRegisteredOnMainnet && isRegisteredOnOptimism) {
            throw new Error(`The package "${pkg.name}" is already registered.`);
        }
        return [isRegisteredOnOptimism, isRegisteredOnMainnet];
    }));
    const overrides = {};
    if (options.maxFeePerGas) {
        overrides.maxFeePerGas = viem.parseGwei(options.maxFeePerGas);
    }
    if (options.gasLimit) {
        overrides.gasLimit = options.gasLimit;
    }
    if (options.value) {
        overrides.value = options.value;
    }
    const mainnetRegistry = new builder_1.OnChainRegistry({
        signer: mainnetRegistryProvider.signers[0],
        provider: mainnetRegistryProvider.provider,
        address: mainnetRegistryConfig.address,
        overrides,
    });
    const userAddress = mainnetRegistryProvider.signers[0].address;
    debug('Address that will send the transaction: ', userAddress);
    const userBalance = await mainnetRegistryProvider.provider.getBalance({ address: userAddress });
    if (userBalance === BigInt(0)) {
        throw new Error(`Account "${userAddress}" does not have any funds to pay for gas.`);
    }
    const registerFee = await mainnetRegistry.getRegisterFee();
    debug('Register fee: ', viem.formatEther(registerFee));
    const transactions = await Promise.all(packageRefs.map((pkg, index) => {
        const [isRegisteredOnOptimism, isRegisteredOnMainnet] = isRegistered[index];
        const shouldNominateOwner = isRegisteredOnMainnet && !isRegisteredOnOptimism;
        debug('Should nominate owner for package: ', pkg.name, ' - ', shouldNominateOwner ? 'yes' : 'no');
        return mainnetRegistry.prepareSetPackageOwnership(pkg.name, undefined, shouldNominateOwner);
    }));
    const multicallTx = (0, builder_1.prepareMulticall)(transactions.flat());
    // Note: for some reason, estimate gas is not accurate
    // Note: if the user does not have enough gas, the estimateGasForSetPackageOwnership will throw an error
    const estimateGas = await mainnetRegistry.estimateGasForSetPackageOwnership(multicallTx);
    const cost = estimateGas + registerFee;
    if (cost > userBalance) {
        throw new Error(`Account "${userAddress}" does not have the required ${viem.formatEther(cost)} ETH for gas and registration fee`);
    }
    const currentGasPrice = await mainnetRegistryProvider.provider.getGasPrice();
    console.log('');
    console.log('You are about to register the following packages:');
    packageRefs.forEach((pkg) => console.log(' - Package:', (0, chalk_1.blueBright)(pkg.name)));
    console.log();
    console.log(`The transaction will cost ~${viem.formatEther(estimateGas * currentGasPrice)} ETH on ${mainnetRegistryConfig.name}.`);
    console.log('');
    if (!options.skipConfirm) {
        const confirm = await (0, prompts_1.default)({
            type: 'confirm',
            name: 'confirmation',
            message: 'Proceed?',
        });
        if (!confirm.confirmation) {
            console.log('Cancelled');
            process.exit(1);
        }
    }
    console.log('Submitting transaction...');
    try {
        const [hash] = await Promise.all([
            (async () => {
                const hash = await mainnetRegistry.setPackageOwnership(multicallTx);
                console.log(`${(0, chalk_1.green)('Success!')} (${(0, chalk_1.blueBright)('Transaction Hash')}: ${hash})`);
                console.log('');
                console.log((0, chalk_1.gray)(`Waiting for the transaction to propagate to ${optimismRegistryConfig.name}... It may take approximately 1-3 minutes.`));
                console.log('');
                return hash;
            })(),
            (async () => {
                // this should always resolve after the first promise but we want to make sure it runs at the same time
                return Promise.all(packageRefs.map((pkg) => {
                    const packageNameHex = viem.stringToHex(pkg.name, { size: 32 });
                    return Promise.all([
                        (0, register_1.waitForEvent)({
                            eventName: 'PackageOwnerChanged',
                            abi: mainnetRegistry.contract.abi,
                            providerUrl: optimismRegistryConfig.providerUrl[0],
                            expectedArgs: {
                                name: packageNameHex,
                                owner: userAddress,
                            },
                        }),
                        (0, register_1.waitForEvent)({
                            eventName: 'PackagePublishersChanged',
                            abi: mainnetRegistry.contract.abi,
                            providerUrl: optimismRegistryConfig.providerUrl[0],
                            expectedArgs: {
                                name: packageNameHex,
                                publisher: [userAddress],
                            },
                        }),
                    ]);
                }));
            })(),
        ]);
        if (fromPublish) {
            console.log((0, chalk_1.gray)('We will continue with the publishing process.'));
        }
        else {
            packageRefs.map(async (pkg) => {
                console.log((0, chalk_1.green)(`Success - Package "${pkg.name}" has been registered.`));
            });
        }
        return hash;
    }
    catch (e) {
        throw new Error(`Failed to register package: ${e.message}`);
    }
}
exports.register = register;
//# sourceMappingURL=register.js.map
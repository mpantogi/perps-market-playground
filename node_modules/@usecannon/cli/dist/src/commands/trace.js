"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.trace = void 0;
const builder_1 = require("@usecannon/builder");
const chalk_1 = require("chalk");
const debug_1 = __importDefault(require("debug"));
const lodash_1 = __importDefault(require("lodash"));
const viem = __importStar(require("viem"));
const package_1 = require("../package");
const rpc_1 = require("../rpc");
const provider_1 = require("../util/provider");
const constants_1 = require("../constants");
const debug = (0, debug_1.default)('cannon:cli:trace');
async function trace({ packageRef, data, chainId, cliSettings, from, to, value, block, json = false, }) {
    // data can be:
    // 1. on-chain transaction hash
    // 2. calldata (will automatically detect contract to execute on)
    //   * in which case, will figure out what to execute
    //   * additional option to override the contract
    //
    // in any case, cannon will run the transaction in anvil. afterwards, it
    // will call `trace_transaction`, and decode as much data from the trace
    // as possible, the same way that an error occurs
    // if chain id is not specified, get it from the provider
    const { provider } = await (0, provider_1.resolveWriteProvider)(cliSettings, chainId);
    const deployInfos = await (0, package_1.readDeployRecursive)(packageRef, chainId);
    const artifacts = {};
    for (const di of deployInfos) {
        lodash_1.default.merge(artifacts, (0, builder_1.getArtifacts)(new builder_1.ChainDefinition(di.def), di.state));
    }
    if (viem.isHash(data)) {
        const txHash = data;
        try {
            const txData = await provider.getTransaction({ hash: txHash });
            const txReceipt = await provider.getTransactionReceipt({ hash: txHash });
            // this is a transaction hash
            console.log((0, chalk_1.gray)('Detected transaction hash'));
            data = txData.input;
            value = value || txData.value;
            block = block || txReceipt.blockNumber.toString();
            from = from || txData.from;
            if (!to && txData.to)
                to = txData.to;
        }
        catch (err) {
            throw new Error('could not get transaction information. The transaction may not exist?');
        }
    }
    else if (!to) {
        const r = (0, builder_1.findContract)(artifacts, ({ abi }) => {
            try {
                viem.decodeFunctionData({ abi, data });
                return true;
            }
            catch (_) {
                // intentionally empty
            }
            return false;
        });
        if (r !== null) {
            to = r.contract.address;
            console.log((0, chalk_1.gray)(`Inferred contract for call: ${r.name}`));
        }
        else {
            console.log((0, chalk_1.yellow)('Could not find a contract for this call. Are you sure the call can be traced on a contract on this cannon package? Pass `--to` to set manually if necessary'));
        }
    }
    // create an anvil server
    let rpc;
    if (block) {
        // subtract one second because 1 second is added when the block is mined
        const blockInfo = await provider.getBlock((block || 'latest').match(/^[0-9]*$/) ? { blockNumber: BigInt(block) } : { blockTag: block });
        const timestamp = blockInfo.timestamp - BigInt(1);
        rpc = await (0, rpc_1.runRpc)({
            port: 0,
            forkBlockNumber: !block || block === 'latest' ? undefined : (blockInfo.number - BigInt(1)).toString(),
            timestamp,
            chainId,
        }, { forkProvider: provider });
    }
    else {
        rpc = await (0, rpc_1.runRpc)({ port: 0, chainId }, { forkProvider: provider });
    }
    const simulateProvider = (0, rpc_1.getProvider)(rpc);
    const fullTxn = {
        from: from || viem.zeroAddress,
        to: to || viem.zeroAddress,
        data,
        value,
        // set the gas limit very high to make sure the txn does not try to estimate
        gasLimit: 10000000,
    };
    debug('full txn to execute', fullTxn);
    // now we should be able to run the transaction. force it through
    let txnHash;
    try {
        const signer = (fullTxn.from || constants_1.ANVIL_FIRST_ADDRESS);
        if (fullTxn.from) {
            await simulateProvider.impersonateAccount({ address: fullTxn.from });
            await simulateProvider.setBalance({ address: fullTxn.from, value: viem.parseEther('10000') });
        }
        console.log((0, chalk_1.gray)('Simulating transaction (be patient! this could take a while...)'));
        const pushedTxn = await simulateProvider.sendTransaction({ account: signer, chain: simulateProvider.chain, ...fullTxn });
        try {
            await simulateProvider.waitForTransactionReceipt({ hash: pushedTxn });
        }
        catch {
            // intentionally empty
        }
        txnHash = pushedTxn;
    }
    catch (err) {
        throw new Error(`failed to simulate txn: ${err.toString()}`);
    }
    // once we have forced through the transaction, call `trace_transaction`
    const traces = await simulateProvider.request({ method: 'trace_transaction', params: [txnHash] });
    if (!json) {
        const traceText = (0, builder_1.renderTrace)(artifacts, traces);
        console.log(traceText);
        const receipt = await simulateProvider.getTransactionReceipt({ hash: txnHash });
        const totalGasUsed = computeGasUsed(traces, fullTxn).toLocaleString();
        console.log();
        if (receipt.status == 'success') {
            console.log((0, chalk_1.green)((0, chalk_1.bold)(`Transaction completes successfully with return value: ${traces[0].result?.output ?? 'unknown'} (${totalGasUsed} gas)`)));
        }
        else {
            console.log((0, chalk_1.red)((0, chalk_1.bold)(`Transaction completes with error: ${traces[0].result?.output ?? 'unknown'} (${totalGasUsed} gas)`)));
        }
    }
    else {
        console.log(JSON.stringify(traces, null, 2));
    }
}
exports.trace = trace;
function computeGasUsed(traces, txn) {
    // total gas required for the transaction is whatever was used by the actual txn
    // + 21000 (base transaction cost)
    // + cost of the txn calldata
    const txnData = viem.hexToBytes(txn.data || '0x');
    const zeroDataCount = txnData.filter((d) => d === 0).length;
    const nonZeroDataCount = txnData.length - zeroDataCount;
    return parseInt(traces[0].result?.gasUsed ?? '0') + 21000 + 4 * zeroDataCount + 16 * nonZeroDataCount;
}
//# sourceMappingURL=trace.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
const builder_1 = require("@usecannon/builder");
const chalk_1 = require("chalk");
const lodash_1 = __importDefault(require("lodash"));
const table_1 = require("table");
const viem = __importStar(require("viem"));
const package_json_1 = __importDefault(require("../../package.json"));
const chains_1 = require("../chains");
const helpers_1 = require("../helpers");
const loader_1 = require("../loader");
const plugins_1 = require("../plugins");
const registry_1 = require("../registry");
const settings_1 = require("../settings");
async function build({ provider, def, packageDefinition, upgradeFrom, pkgInfo, getArtifact, getSigner, getDefaultSigner, presetArg, overrideResolver, wipe = false, persist = true, plugins = true, publicSourceCode = false, providerUrl, registryPriority, gasPrice, gasFee, priorityGasFee, }) {
    if (wipe && upgradeFrom) {
        throw new Error('wipe and upgradeFrom are mutually exclusive. Please specify one or the other');
    }
    if (!persist && providerUrl) {
        console.log((0, chalk_1.yellowBright)((0, chalk_1.bold)('⚠️  This is a simulation. No changes will be made to the chain. No package data will be saved.\n')));
    }
    let stepsExecuted = false;
    const packageRef = builder_1.PackageReference.from(packageDefinition.name, packageDefinition.version, packageDefinition.preset);
    const { name, version } = packageRef;
    const preset = presetArg || packageRef.preset;
    const { fullPackageRef } = builder_1.PackageReference.from(name, version, preset);
    // Handle deprecated preset specification
    if (presetArg) {
        console.warn((0, chalk_1.yellow)((0, chalk_1.bold)('The --preset option will be deprecated soon. Reference presets in the package reference using the format name:version@preset')));
    }
    const cliSettings = (0, settings_1.resolveCliSettings)({ registryPriority });
    if (plugins) {
        await (0, plugins_1.loadPlugins)();
    }
    const chainId = await provider.getChainId();
    const chainInfo = (0, chains_1.getChainById)(chainId);
    const chainName = chainInfo?.name || 'unknown chain';
    const nativeCurrencySymbol = chainInfo?.nativeCurrency.symbol || 'ETH';
    let totalCost = BigInt(0);
    const runtimeOptions = {
        provider,
        chainId,
        getArtifact,
        getSigner: getSigner ||
            async function (addr) {
                const client = provider;
                // on test network any user can be conjured
                await client.impersonateAccount({ address: addr });
                await client.setBalance({ address: addr, value: viem.parseEther('10000') });
                return {
                    address: addr,
                    wallet: viem.createWalletClient({
                        account: addr,
                        chain: provider.chain,
                        transport: viem.custom(provider.transport),
                    }),
                };
            },
        getDefaultSigner,
        snapshots: chainId === builder_1.CANNON_CHAIN_ID,
        allowPartialDeploy: chainId !== builder_1.CANNON_CHAIN_ID && persist,
        publicSourceCode,
        gasPrice,
        gasFee,
        priorityGasFee,
    };
    const resolver = overrideResolver || (await (0, registry_1.createDefaultReadRegistry)(cliSettings));
    const runtime = new builder_1.ChainBuilderRuntime(runtimeOptions, resolver, (0, loader_1.getMainLoader)(cliSettings), 'ipfs');
    // Check for existing package
    let oldDeployData = null;
    const prevPkg = upgradeFrom || fullPackageRef;
    console.log((0, chalk_1.bold)('Checking for existing package...'));
    oldDeployData = await runtime.readDeploy(prevPkg, runtime.chainId);
    // Update pkgInfo (package.json) with information from existing package, if present
    if (oldDeployData) {
        console.log((0, chalk_1.gray)(`    ${fullPackageRef} (Chain ID: ${chainId}) found`));
        if (!wipe) {
            await runtime.restoreMisc(oldDeployData.miscUrl);
            if (!pkgInfo) {
                pkgInfo = oldDeployData.meta;
            }
        }
    }
    else {
        if (upgradeFrom) {
            throw new Error(`    ${prevPkg} (Chain ID: ${chainId}) not found`);
        }
        else {
            console.log((0, chalk_1.gray)(`    ${prevPkg} (Chain ID: ${chainId}) not found`));
        }
    }
    const resolvedSettings = lodash_1.default.pickBy(lodash_1.default.assign((!wipe && oldDeployData?.options) || {}, packageDefinition.settings));
    def = def || (oldDeployData ? new builder_1.ChainDefinition(oldDeployData.def) : undefined);
    if (!def) {
        throw new Error('no deployment definition to build');
    }
    const initialCtx = await (0, builder_1.createInitialContext)(def, pkgInfo, chainId, resolvedSettings);
    const pkgName = name || def.getName(initialCtx);
    const pkgVersion = version || def.getVersion(initialCtx);
    console.log('');
    if (oldDeployData && wipe) {
        console.log('Wiping existing package...');
        console.log((0, chalk_1.bold)('Initializing new package...'));
    }
    else if (oldDeployData && !upgradeFrom) {
        console.log((0, chalk_1.bold)('Continuing with existing package...'));
    }
    else {
        console.log((0, chalk_1.bold)('Initializing new package...'));
    }
    console.log('Name: ' + (0, chalk_1.cyanBright)(`${pkgName}`));
    console.log('Version: ' + (0, chalk_1.cyanBright)(`${pkgVersion}`));
    console.log('Preset: ' + (0, chalk_1.cyanBright)(`${preset}`) + (preset == 'main' ? (0, chalk_1.gray)(' (default)') : ''));
    console.log('Chain ID: ' + (0, chalk_1.cyanBright)(`${chainId}`));
    if (upgradeFrom) {
        console.log(`Upgrading from: ${(0, chalk_1.cyanBright)(upgradeFrom)}`);
    }
    if (publicSourceCode) {
        console.log((0, chalk_1.gray)('Source code will be included in the package'));
    }
    console.log('');
    const providerUrlMsg = provider.transport.type === 'http'
        ? provider.transport.url
        : typeof providerUrl === 'string'
            ? providerUrl.split(',')[0]
            : providerUrl;
    console.log((0, chalk_1.bold)(`Building the chain (ID ${chainId})${providerUrlMsg ? ' via ' + providerUrlMsg.replace(RegExp(/[=A-Za-z0-9_-]{32,}/), '*'.repeat(32)) : ''}...`));
    let defaultSignerAddress;
    if (getDefaultSigner) {
        const defaultSigner = await getDefaultSigner();
        if (defaultSigner) {
            defaultSignerAddress = defaultSigner.address;
            console.log(`Using ${defaultSignerAddress}`);
        }
        else {
            console.log();
            console.log((0, chalk_1.bold)((0, chalk_1.red)('Signer not found.')));
            console.log((0, chalk_1.red)('Provide a signer to execute this build. Add the --private-key option or set the env variable CANNON_PRIVATE_KEY.'));
            process.exit(1);
        }
    }
    if (!lodash_1.default.isEmpty(resolvedSettings)) {
        console.log((0, chalk_1.gray)('Overriding settings in the cannonfile with the following:'));
        for (const [key, value] of Object.entries(resolvedSettings)) {
            console.log((0, chalk_1.gray)(`  - ${key} = ${value}`));
        }
        console.log('');
    }
    if (plugins) {
        const pluginList = await (0, plugins_1.listInstalledPlugins)();
        if (pluginList.length) {
            console.log('plugins:', pluginList.join(', '), 'detected');
        }
    }
    console.log('');
    let partialDeploy = false;
    runtime.on(builder_1.Events.PreStepExecute, (t, n, _c, d) => console.log((0, chalk_1.cyanBright)(`${'  '.repeat(d)}Executing ${`[${t}.${n}]`}...`)));
    runtime.on(builder_1.Events.SkipDeploy, (n, err, d) => {
        partialDeploy = true;
        console.log((0, chalk_1.yellowBright)(`${'  '.repeat(d)}  \u26A0\uFE0F  Skipping [${n}] (${typeof err === 'object' && err.toString === Object.prototype.toString ? JSON.stringify(err) : err.toString()})`));
    });
    runtime.on(builder_1.Events.PostStepExecute, (t, n, c, ctx, o, d) => {
        for (const txnKey in o.txns) {
            const txn = o.txns[txnKey];
            console.log(`${'  '.repeat(d)}  ${(0, chalk_1.green)('\u2714')} Successfully called ${c.func}(${c?.args
                ?.map((arg) => (typeof arg === 'object' && arg !== null ? JSON.stringify(arg) : arg))
                .join(', ')})`);
            if (txn.signer != defaultSignerAddress) {
                console.log((0, chalk_1.gray)(`${'  '.repeat(d)}  Signer: ${txn.signer}`));
            }
            const contractAddress = (0, builder_1.getContractFromPath)(ctx, c.target[0])?.address;
            if (contractAddress) {
                console.log((0, chalk_1.gray)(`${'  '.repeat(d)}  Contract Address: ${contractAddress}`));
            }
            console.log((0, chalk_1.gray)(`${'  '.repeat(d)}  Transaction Hash: ${txn.hash}`));
            const cost = BigInt(txn.gasCost) * BigInt(txn.gasUsed);
            totalCost = totalCost + cost;
            console.log((0, chalk_1.gray)(`${'  '.repeat(d)}  Transaction Cost: ${viem.formatEther(cost)} ${nativeCurrencySymbol} (${txn.gasUsed.toLocaleString()} gas)`));
        }
        for (const contractKey in o.contracts) {
            const contract = o.contracts[contractKey];
            if (contract.deployTxnHash) {
                console.log(`${'  '.repeat(d)}  ${(0, chalk_1.green)('\u2714')} Successfully deployed ${contract.contractName}${c.create2 ? ' using CREATE2' : ''}`);
                console.log((0, chalk_1.gray)(`${'  '.repeat(d)}  Contract Address: ${contract.address}`));
                console.log((0, chalk_1.gray)(`${'  '.repeat(d)}  Transaction Hash: ${contract.deployTxnHash}`));
                const cost = BigInt(contract.gasCost) * BigInt(contract.gasUsed);
                totalCost = totalCost + cost;
                console.log((0, chalk_1.gray)(`${'  '.repeat(d)}  Transaction Cost: ${viem.formatEther(cost)} ${nativeCurrencySymbol} (${contract.gasUsed.toLocaleString()} gas)`));
            }
        }
        for (const setting in o.settings) {
            if (ctx.overrideSettings[setting]) {
                console.log((0, chalk_1.red)(`${'  '.repeat(d)}  Overridden Setting: ${setting} = ${ctx.overrideSettings[setting]}`));
            }
            else {
                console.log((0, chalk_1.gray)(`${'  '.repeat(d)}  Setting: ${setting} = ${o.settings[setting]}`));
            }
        }
        stepsExecuted = true;
        console.log();
    });
    runtime.on(builder_1.Events.ResolveDeploy, (packageName, preset, chainId, registry, d) => console.log((0, chalk_1.magenta)(`${'  '.repeat(d)}  Resolving ${packageName} (Chain ID: ${chainId}) via ${registry}...`)));
    runtime.on(builder_1.Events.DownloadDeploy, (hash, gateway, d) => console.log((0, chalk_1.gray)(`${'  '.repeat(d)}    Downloading ${hash} via ${gateway}`)));
    // attach control-c handler
    let ctrlcs = 0;
    const handler = () => {
        if (!runtime.isCancelled()) {
            console.log('interrupt received, finishing current operation and cancelling...');
            console.log('please be patient, or state loss may occur.');
            partialDeploy = true;
            runtime.cancel();
        }
        else if (ctrlcs < 4) {
            console.log('you really should not try to cancel the build unless you know what you are doing.');
            console.log('continue pressing control-c to FORCE, and UNCLEANLY exit cannon');
        }
        else {
            console.log('exiting uncleanly. state loss may have occured. please DO NOT raise bug reports.');
            process.exit(1234);
        }
        ctrlcs++;
    };
    if (persist && chainId != builder_1.CANNON_CHAIN_ID) {
        process.on('SIGINT', handler);
        process.on('SIGTERM', handler);
        process.on('SIGQUIT', handler);
    }
    const newState = await (0, builder_1.build)(runtime, def, oldDeployData && !wipe ? oldDeployData.state : {}, initialCtx);
    const outputs = (await (0, builder_1.getOutputs)(runtime, def, newState));
    // save the state to ipfs
    const miscUrl = await runtime.recordMisc();
    const chainDef = def.toJson();
    chainDef.version = pkgVersion;
    if (miscUrl) {
        const deployUrl = await runtime.putDeploy({
            generator: `cannon cli ${package_json_1.default.version}`,
            timestamp: Math.floor(Date.now() / 1000),
            def: chainDef,
            state: newState,
            options: resolvedSettings,
            status: partialDeploy ? 'partial' : 'complete',
            meta: pkgInfo,
            miscUrl: miscUrl,
            chainId: runtime.chainId,
        });
        const metadata = await (0, helpers_1.readMetadataCache)(`${pkgName}:${pkgVersion}`);
        const metaUrl = await runtime.putBlob(metadata);
        // locally store cannon packages (version + latest)
        await resolver.publish([fullPackageRef, `${name}:latest@${preset}`], runtime.chainId, deployUrl, metaUrl);
        // detach the process handler
        process.off('SIGINT', handler);
        process.off('SIGTERM', handler);
        process.off('SIGQUIT', handler);
        if (partialDeploy) {
            console.log((0, chalk_1.yellowBright)((0, chalk_1.bold)('\n\u26A0\uFE0F  Your deployment was not fully completed. Please inspect the issues listed above and resolve as necessary.')));
            console.log((0, chalk_1.gray)(`Total Cost: ${viem.formatEther(totalCost)} ${nativeCurrencySymbol}`));
            console.log('');
            console.log('- Rerunning the build command will attempt to execute skipped operations. It will not rerun executed operations. (To rerun executed operations, delete the partial build package generated by this run by adding the --wipe flag to the build command on the next run.)');
            if (upgradeFrom) {
                console.log((0, chalk_1.bold)('  Remove the --upgrade-from option to continue from the partial build.'));
            }
            console.log(`- Your partial deployment has been stored to ${deployUrl}`);
            console.log('- Run ' +
                (0, chalk_1.bold)(`cannon pin ${deployUrl}`) +
                ' to pin the partial deployment package on IPFS. Then use https://usecannon.com/deploy to collect signatures from a Safe for the skipped operations in the partial deployment package.');
        }
        else {
            if (chainId == 13370) {
                console.log((0, chalk_1.bold)(`💥 ${fullPackageRef} built for Cannon (Chain ID: ${chainId})`));
                console.log((0, chalk_1.gray)('This package can be run locally using the CLI and provisioned by Cannonfiles.'));
            }
            else {
                console.log((0, chalk_1.bold)(`💥 ${fullPackageRef} built on ${chainName} (Chain ID: ${chainId})`));
                console.log((0, chalk_1.gray)(`Total Cost: ${viem.formatEther(totalCost)} ${nativeCurrencySymbol}`));
            }
            console.log();
            console.log(`The following package data has been stored locally${cliSettings.writeIpfsUrl && ' and pinned to ' + cliSettings.writeIpfsUrl}`);
            console.log((0, table_1.table)([
                ['Deployment Data', deployUrl],
                ['Package Code', miscUrl],
                ['Metadata', metaUrl],
            ]));
            console.log((0, chalk_1.bold)(`Publish ${(0, chalk_1.bold)(fullPackageRef)} to the registry and pin the IPFS data to ${cliSettings.publishIpfsUrl}`));
            console.log(`> ${`cannon publish ${fullPackageRef} --chain-id ${chainId}`}`);
            console.log('');
            if (chainId == 13370) {
                console.log((0, chalk_1.bold)('Run this package'));
                console.log(`> ${`cannon ${fullPackageRef}`}`);
            }
            else {
                console.log((0, chalk_1.bold)('Verify contracts on Etherscan'));
                console.log(`> ${`cannon verify ${fullPackageRef} --chain-id ${chainId}`}`);
            }
        }
    }
    else {
        console.log((0, chalk_1.bold)((0, chalk_1.yellow)(`Chain state could not be saved via ${runtime.loaders[runtime.defaultLoaderScheme].getLabel()}. Try a writable endpoint by setting ipfsUrl through \`cannon setup\`.`)));
    }
    if (!stepsExecuted) {
        console.log((0, chalk_1.bold)('No operations were executed during the build.'));
    }
    console.log('');
    provider = provider.extend((0, builder_1.traceActions)(outputs));
    return { outputs, provider, runtime };
}
exports.build = build;
//# sourceMappingURL=build.js.map
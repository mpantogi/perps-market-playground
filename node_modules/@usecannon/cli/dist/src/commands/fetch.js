"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetch = void 0;
const chalk_1 = require("chalk");
const registry_1 = require("../registry");
const settings_1 = require("../settings");
const builder_1 = require("@usecannon/builder");
const debug_1 = __importDefault(require("debug"));
const node_fs_1 = __importDefault(require("node:fs"));
const path_1 = __importDefault(require("path"));
const util_1 = __importDefault(require("util"));
const debug = (0, debug_1.default)('cannon:cli:clean');
const mkdir = util_1.default.promisify(node_fs_1.default.mkdir);
const writeFile = util_1.default.promisify(node_fs_1.default.writeFile);
/**
  Function used to store references in the tags directory.\
  Recursively creates parent directories if they do not exist and writes to file
*/
async function storeDeployReference(filePath, content) {
    const dir = path_1.default.dirname(filePath);
    try {
        await mkdir(dir, { recursive: true });
        await writeFile(filePath, content);
    }
    catch (error) {
        throw new Error(`Error creating file: ${error}`);
    }
}
async function fetch(packageRef, chainId, hash, metaHash) {
    if (!/^Qm[1-9A-Za-z]{44}$/.test(hash)) {
        throw new Error(`"${hash}" does not match the IPFS CID v0 format`);
    }
    debug('resolving user settings');
    const cliSettings = (0, settings_1.resolveCliSettings)();
    const { name, version, preset } = new builder_1.PackageReference(packageRef);
    const localRegistry = new registry_1.LocalRegistry(cliSettings.cannonDirectory);
    const storage = new builder_1.CannonStorage(localRegistry, {
        ipfs: new builder_1.IPFSLoader(cliSettings.publishIpfsUrl || (0, builder_1.getCannonRepoRegistryUrl)()),
    });
    console.log((0, chalk_1.blueBright)('Fetching IPFS data from: '));
    console.log(`\n - ${hash}`);
    try {
        const ipfsUrl = 'ipfs://' + hash;
        debug('reading deploy from ipfs');
        // Fetching deployment info
        const deployInfo = await storage.readBlob(ipfsUrl);
        const def = new builder_1.ChainDefinition(deployInfo.def);
        const preCtx = await (0, builder_1.createInitialContext)(def, deployInfo.meta, deployInfo.chainId || chainId, deployInfo.options);
        const pkgName = `${name}:${def.getVersion(preCtx) || version}@${preset}`;
        if (!deployInfo || Object.keys(deployInfo).length === 0) {
            throw new Error(`could not find package data on IPFS using the hash: ${hash}`);
        }
        if (name !== deployInfo.def.name) {
            throw new Error(`deployment data at ${hash} does not match the specified package "${pkgName}"`);
        }
        debug('storing deploy info');
        const deployPath = localRegistry.getTagReferenceStorage(pkgName, deployInfo.chainId || chainId);
        await storeDeployReference(deployPath, ipfsUrl);
        if (metaHash) {
            if (!/^Qm[1-9A-Za-z]{44}$/.test(metaHash)) {
                throw new Error(`"${metaHash}" does not match the IPFS CID v0 format`);
            }
            const ipfsUrl = 'ipfs://' + metaHash;
            debug('reading metadata from ipfs');
            const deployMetadataPath = localRegistry.getMetaTagReferenceStorage(pkgName, chainId);
            await storeDeployReference(deployMetadataPath, ipfsUrl);
        }
        console.log(`\n\nSuccessfully fetched and saved deployment data for the following package: ${pkgName}`);
        console.log(`run 'cannon publish ${pkgName} --chain-id <CHAIN_ID> --private-key <PRIVATE_KEY>' to publish the package to the registry`);
    }
    catch (e) {
        throw new Error(`${e?.message}`);
    }
}
exports.fetch = fetch;
//# sourceMappingURL=fetch.js.map
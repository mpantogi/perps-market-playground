"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unpublish = void 0;
const builder_1 = require("@usecannon/builder");
const chalk_1 = require("chalk");
const lodash_1 = __importDefault(require("lodash"));
const prompts_1 = __importDefault(require("prompts"));
const viem = __importStar(require("viem"));
const helpers_1 = require("../helpers");
const registry_1 = require("../registry");
const provider_1 = require("../util/provider");
async function unpublish({ cliSettings, options, packageRef }) {
    if (!options.chainId) {
        const chainIdPrompt = await (0, prompts_1.default)({
            type: 'number',
            name: 'value',
            message: 'Please provide the Chain ID for the package you want to unpublish',
            initial: 13370,
        });
        if (!chainIdPrompt.value) {
            throw new Error('A valid Chain Id is required.');
        }
        options.chainId = Number(chainIdPrompt.value);
    }
    console.log();
    if (!cliSettings.privateKey) {
        const keyPrompt = await (0, prompts_1.default)({
            type: 'text',
            name: 'value',
            message: 'Enter the private key of the package owner to unpublish',
            style: 'password',
            validate: (key) => (0, helpers_1.isPrivateKey)((0, helpers_1.normalizePrivateKey)(key)) || 'Private key is not valid',
        });
        if (!keyPrompt.value) {
            throw new Error('A valid private key is required.');
        }
        cliSettings.privateKey = (0, helpers_1.checkAndNormalizePrivateKey)(keyPrompt.value);
    }
    console.log();
    const fullPackageRef = new builder_1.PackageReference(packageRef).fullPackageRef;
    // Get the package name, version, and preset without being defaulted
    const { name: packageName, version: packageVersion, preset: packagePreset } = builder_1.PackageReference.parse(packageRef);
    const overrides = {};
    if (options.maxFeePerGas) {
        overrides.maxFeePerGas = viem.parseGwei(options.maxFeePerGas);
    }
    if (options.gasLimit) {
        overrides.gasLimit = options.gasLimit;
    }
    if (options.value) {
        overrides.value = options.value;
    }
    const registryProviders = await (0, provider_1.resolveRegistryProviders)(cliSettings);
    // Initialize pickedRegistryProvider with the first provider
    let [pickedRegistryProvider] = registryProviders;
    // if it's using the default config, prompt the user to choose a registry provider
    const isDefaultSettings = lodash_1.default.isEqual(cliSettings.registries, builder_1.DEFAULT_REGISTRY_CONFIG);
    if (!isDefaultSettings)
        throw new Error('Custom registry settings are not supported yet.');
    const choices = registryProviders.reverse().map((p) => ({
        title: `${p.provider.chain?.name ?? 'Unknown Network'} (Chain ID: ${p.provider.chain?.id})`,
        value: p,
    }));
    // Override pickedRegistryProvider with the selected provider
    pickedRegistryProvider = (await (0, prompts_1.default)([
        {
            type: 'select',
            name: 'pickedRegistryProvider',
            message: 'Which registry would you like to use? (Cannon will find the package on either.):',
            choices,
        },
    ])).pickedRegistryProvider;
    const registryAddress = cliSettings.registries.find((registry) => registry.chainId === pickedRegistryProvider.provider.chain?.id)?.address ||
        builder_1.DEFAULT_REGISTRY_CONFIG[0].address;
    const onChainRegistry = new builder_1.OnChainRegistry({
        signer: pickedRegistryProvider.signers[0],
        provider: pickedRegistryProvider.provider,
        address: registryAddress,
        overrides,
    });
    const localRegistry = new registry_1.LocalRegistry(cliSettings.cannonDirectory);
    let deploys;
    if (packageName && packageVersion && packagePreset) {
        // if user has specified a full package ref, use it to fetch the deployment
        deploys = [{ name: fullPackageRef, chainId: options.chainId }];
    }
    else {
        // Check for deployments that are relevant to the provided packageRef
        deploys = await localRegistry.scanDeploys(packageRef, Number(options.chainId));
    }
    if (!deploys || deploys.length === 0) {
        throw new Error(`Could not find any deployments for ${fullPackageRef} with chain id ${options.chainId}. If you have the IPFS hash of the deployment data, use the fetch command. Otherwise, rebuild the package.`);
    }
    const onChainResults = await Promise.all(deploys.map(async (d) => {
        return [await onChainRegistry.getUrl(d.name, d.chainId), await onChainRegistry.getMetaUrl(d.name, d.chainId)];
    }));
    const publishedDeploys = deploys.reduce((acc, deploy, index) => {
        const [url, metaUrl] = onChainResults[index];
        if (url && metaUrl) {
            // note: name should be an array to be used in _preparePackageData function
            acc.push({ ...deploy, name: [deploy.name], url, metaUrl });
        }
        return acc;
    }, []);
    if (publishedDeploys.length === 0) {
        throw new Error(`Package ${packageName} has no published deployments.`);
    }
    let selectedDeploys;
    if (publishedDeploys.length > 1) {
        console.log();
        const prompt = await (0, prompts_1.default)({
            type: 'multiselect',
            message: 'Select the packages you want to unpublish:\n',
            name: 'value',
            instructions: false,
            hint: '- Space to select. Enter to submit',
            choices: publishedDeploys.map((d) => {
                const { fullPackageRef } = new builder_1.PackageReference(d.name[0]);
                return {
                    title: `${fullPackageRef} (Chain ID: ${d.chainId})`,
                    description: '',
                    value: d,
                };
            }),
        });
        if (!prompt.value) {
            console.log('You must select a package to unpublish');
            process.exit(1);
        }
        selectedDeploys = prompt.value;
    }
    else {
        selectedDeploys = publishedDeploys;
    }
    console.log();
    console.log(`\nSettings:\n - Max Fee Per Gas: ${overrides.maxFeePerGas ? overrides.maxFeePerGas.toString() : 'default'}\n - Max Priority Fee Per Gas: ${overrides.maxPriorityFeePerGas ? overrides.maxPriorityFeePerGas.toString() : 'default'}\n - Gas Limit: ${overrides.gasLimit ? overrides.gasLimit : 'default'}\n` +
        " - To alter these settings use the parameters '--max-fee-per-gas', '--max-priority-fee-per-gas', '--gas-limit'.\n");
    console.log();
    if (selectedDeploys.length > 1) {
        const [hash] = await onChainRegistry.unpublishMany(selectedDeploys);
        console.log(`${(0, chalk_1.green)('Success!')} (${(0, chalk_1.blueBright)('Transaction Hash')}: ${hash})`);
    }
    else {
        const [deploy] = selectedDeploys;
        const hash = await onChainRegistry.unpublish(deploy.name, deploy.chainId);
        console.log(`${(0, chalk_1.green)('Success!')} (${(0, chalk_1.blueBright)('Transaction Hash')}: ${hash})`);
    }
}
exports.unpublish = unpublish;
//# sourceMappingURL=unpublish.js.map
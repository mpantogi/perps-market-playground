"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readDeployRecursive = exports.readDeploy = void 0;
const debug_1 = __importDefault(require("debug"));
const builder_1 = require("@usecannon/builder");
const fastq_1 = require("fastq");
const registry_1 = require("./registry");
const settings_1 = require("./settings");
const loader_1 = require("./loader");
const debug = (0, debug_1.default)('cannon:cli:package');
async function readDeploy(packageRef, chainId) {
    debug('readDeploy', packageRef, chainId);
    const store = await _getStore();
    return await _readDeploy(store, packageRef, chainId);
}
exports.readDeploy = readDeploy;
/**
 * Get a list of all the deployments recursively that are imported by the given deployment. Keep in mind
 * that it will only return unique builds, not necessarily one per import/provision.
 */
async function readDeployRecursive(packageRef, chainId) {
    debug('readDeployTree', packageRef, chainId);
    const store = await _getStore();
    const deployInfo = await _readDeploy(store, packageRef, chainId);
    const result = new Map();
    const __readImports = async (info) => {
        const importUrls = _deployImports(info).map(({ url }) => url);
        await Promise.all(importUrls.map((url) => queue.push(url)));
    };
    const queue = (0, fastq_1.promise)(async (url) => {
        if (result.has(url))
            return;
        debug('readDeployTree child', url);
        result.set(url, null); // Avoid double fetching/recursion
        const info = (await store.readBlob(url));
        if (!info)
            throw new Error(`deployment not found: ${url}`);
        result.set(url, info); // Set fetched value
        await __readImports(info);
    }, 5);
    await __readImports(deployInfo);
    return [deployInfo, ...result.values()];
}
exports.readDeployRecursive = readDeployRecursive;
function _deployImports(deployInfo) {
    if (!deployInfo.state)
        return [];
    return Object.values(deployInfo.state).flatMap((state) => Object.values(state.artifacts.imports || {}));
}
async function _getStore() {
    const settings = (0, settings_1.resolveCliSettings)();
    const registry = await (0, registry_1.createDefaultReadRegistry)(settings);
    const loaders = (0, loader_1.getMainLoader)(settings);
    return new builder_1.CannonStorage(registry, loaders);
}
async function _readDeploy(store, packageRef, chainId) {
    const deployInfo = await store.readDeploy(packageRef, chainId);
    if (!deployInfo) {
        throw new Error(`deployment data could not be downloaded for ${packageRef} at ${chainId}`);
    }
    return deployInfo;
}
//# sourceMappingURL=package.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAndNormalizePrivateKey = exports.normalizePrivateKey = exports.isPrivateKey = exports.getSourceFromRegistry = exports.getContractsAndDetails = exports.toArgs = exports.toFlagCase = exports.readMetadataCache = exports.saveToMetadataCache = exports.ensureChainIdConsistency = exports.getChainDataFromId = exports.getChainId = exports.getChainName = exports.checkForgeAstSupport = exports.loadCannonfile = exports.checkCannonVersion = exports.resolveCannonVersion = exports.execPromise = exports.formatAbiFunction = exports.getSighash = exports.setupAnvil = exports.filterSettings = void 0;
const toml_1 = __importDefault(require("@iarna/toml"));
const builder_1 = require("@usecannon/builder");
const chalk_1 = require("chalk");
const child_process_1 = require("child_process");
const debug_1 = __importDefault(require("debug"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const prompts_1 = __importDefault(require("prompts"));
const semver_1 = __importDefault(require("semver"));
const viem = __importStar(require("viem"));
const accounts_1 = require("viem/accounts");
const chains_1 = require("./chains");
const settings_1 = require("./settings");
const is_connected_to_internet_1 = require("./util/is-connected-to-internet");
const provider_1 = require("./util/provider");
const debug = (0, debug_1.default)('cannon:cli:helpers');
async function filterSettings(settings) {
    // Filter out private key for logging
    /* eslint-disable @typescript-eslint/no-unused-vars */
    const { cannonDirectory, privateKey, etherscanApiKey, ...filteredSettings } = settings;
    // Filters out API keys
    filteredSettings.providerUrl = filteredSettings.providerUrl?.replace(RegExp(/[=A-Za-z0-9_-]{32,}/), '*'.repeat(32));
    filteredSettings.registryProviderUrl = filteredSettings.registryProviderUrl?.replace(RegExp(/[=A-Za-z0-9_-]{32,}/), '*'.repeat(32));
    filteredSettings.publishIpfsUrl = filteredSettings.publishIpfsUrl?.replace(RegExp(/[=AZa-z0-9_-]{32,}/), '*'.repeat(32));
    filteredSettings.ipfsUrl = filteredSettings.ipfsUrl?.replace(RegExp(/[=AZa-z0-9_-]{32,}/), '*'.repeat(32));
    return filteredSettings;
}
exports.filterSettings = filterSettings;
async function setupAnvil() {
    // TODO Setup anvil using https://github.com/foundry-rs/hardhat/tree/develop/packages/easy-foundryup
    //      It also works when the necessary foundry binary is not on PATH
    const versionDate = await getAnvilVersionDate();
    if (versionDate) {
        // Confirm we have a version after the anvil_loadState/anvil_dumpState functionality was added.
        if (versionDate.getTime() < 1657679573421) {
            const anvilResponse = await (0, prompts_1.default)({
                type: 'confirm',
                name: 'confirmation',
                message: 'Cannon requires a newer version of Foundry. Install it now?',
                initial: true,
            });
            if (anvilResponse.confirmation) {
                console.log((0, chalk_1.magentaBright)('Upgrading Foundry to the latest version...'));
                await execPromise('foundryup');
            }
            else {
                process.exit();
            }
        }
    }
    else {
        const response = await (0, prompts_1.default)({
            type: 'confirm',
            name: 'confirmation',
            message: 'Cannon requires Foundry. Install it now?',
            initial: true,
        });
        if (response.confirmation) {
            console.log((0, chalk_1.magentaBright)('Installing Foundry...'));
            await execPromise('curl -L https://foundry.paradigm.xyz | bash');
            await execPromise(os_1.default.homedir() + '/.foundry/bin/foundryup');
        }
        else {
            process.exit();
        }
    }
}
exports.setupAnvil = setupAnvil;
function getSighash(fragment) {
    let sighash = '';
    switch (fragment.type) {
        case 'function':
            sighash = viem.toFunctionSelector(fragment);
            break;
        case 'event':
            sighash = viem.toEventSelector(fragment);
            break;
    }
    return sighash;
}
exports.getSighash = getSighash;
function formatAbiFunction(v) {
    return `${v.type} ${v.name}(${v.inputs
        .map((param) => ` ${param.type} ${param.name}`)
        .join(',')
        .trim()})`;
}
exports.formatAbiFunction = formatAbiFunction;
async function getAnvilVersionDate() {
    try {
        const child = (0, child_process_1.spawnSync)('anvil', ['--version']);
        const output = child.stdout.toString();
        const timestamp = output.substring(output.indexOf('(') + 1, output.lastIndexOf(')')).split(' ')[1];
        return new Date(timestamp);
    }
    catch {
        return false;
    }
}
function execPromise(command) {
    return new Promise(function (resolve, reject) {
        (0, child_process_1.exec)(command, (error, stdout) => {
            if (error) {
                reject(error);
                return;
            }
            resolve(stdout.trim());
        });
    });
}
exports.execPromise = execPromise;
async function resolveCannonVersion() {
    const settings = (0, settings_1.resolveCliSettings)();
    const versionFile = settings.cannonDirectory + '/version';
    const now = Math.floor(Date.now() / 1000);
    try {
        const fileData = fs_extra_1.default.readFileSync(versionFile).toString('utf8').split(':');
        if (parseInt(fileData[1]) >= now - 86400 * 7) {
            debug('read cannon version from file', fileData);
            return fileData[0];
        }
    }
    catch (err) {
        debug('could not load version file', err);
    }
    debug('downloading version from the internet');
    if (!(await (0, is_connected_to_internet_1.isConnectedToInternet)())) {
        debug('You are offline so we dont check the latest version of cannon');
        return '';
    }
    const resolvedVersion = await execPromise('npm view @usecannon/cli version');
    await fs_extra_1.default.mkdirp(settings.cannonDirectory);
    await fs_extra_1.default.writeFile(versionFile, `${resolvedVersion}:${now}`);
    return resolvedVersion;
}
exports.resolveCannonVersion = resolveCannonVersion;
async function checkCannonVersion(currentVersion) {
    const latestVersion = await resolveCannonVersion();
    if (latestVersion && currentVersion && semver_1.default.lt(currentVersion, latestVersion)) {
        console.warn((0, chalk_1.yellowBright)(`⚠️  There is a new version of Cannon (${latestVersion})`));
        console.warn((0, chalk_1.yellow)('Upgrade with ' + (0, chalk_1.bold)('npm install -g @usecannon/cli\n')));
    }
}
exports.checkCannonVersion = checkCannonVersion;
function loadPackageJson(filepath) {
    try {
        return require(filepath);
    }
    catch (_) {
        return { name: '', version: '' };
    }
}
async function loadCannonfile(filepath) {
    let buf;
    let rawDef;
    if (filepath.endsWith('-')) {
        // credit where its due this is pretty slick
        // https://stackoverflow.com/a/56012724
        // read all data from stdin
        buf = await fs_extra_1.default.readFile(0);
        rawDef = JSON.parse(buf.toString('utf8'));
    }
    else {
        if (!fs_extra_1.default.existsSync(filepath)) {
            throw new Error(`Cannonfile '${filepath}' not found.`);
        }
        [rawDef, buf] = (await loadChainDefinitionToml(filepath, []));
    }
    // second argument ensures "sensitive" dependency verification--which ensures users are always specifying dependencies when they cant be reliably determined
    const def = new builder_1.ChainDefinition(rawDef, true);
    const pkg = loadPackageJson(path_1.default.join(path_1.default.dirname(path_1.default.resolve(filepath)), 'package.json'));
    const ctx = {
        package: pkg,
        chainId: builder_1.CANNON_CHAIN_ID,
        settings: {},
        timestamp: '0',
        contracts: {},
        txns: {},
        imports: {},
        overrideSettings: {},
    };
    const name = def.getName(ctx);
    const version = def.getVersion(ctx);
    const preset = def.getPreset(ctx);
    if (!name) {
        throw new Error('missing "name" on cannon package');
    }
    if (!version) {
        throw new Error('missing "version" on cannon package');
    }
    return { def, name, version, preset, cannonfile: buf.toString() };
}
exports.loadCannonfile = loadCannonfile;
async function loadChainDefinitionToml(filepath, trace) {
    if (!fs_extra_1.default.existsSync(filepath)) {
        throw new Error(`Chain definition TOML '${filepath}' not found. Include trace:\n${trace.map((p) => ' => ' + p).join('\n')}`);
    }
    const buf = await fs_extra_1.default.readFile(filepath);
    let rawDef;
    try {
        rawDef = toml_1.default.parse(buf.toString('utf8'));
    }
    catch (err) {
        throw new Error(`error encountered while parsing toml file ${filepath}: ${err.toString()}`);
    }
    const assembledDef = {};
    // we only want to "override" new steps with old steps. So, if we get 2 levels deep, that means we are parsing
    // a step contents, and we should just take the srcValue
    const customMerge = (_objValue, srcValue, _key, _object, _source, stack) => {
        if (stack.size === 2) {
            // cut off merge for any deeper than this
            return srcValue;
        }
    };
    for (const additionalFilepath of rawDef.include || []) {
        const abspath = path_1.default.join(path_1.default.dirname(filepath), additionalFilepath);
        lodash_1.default.mergeWith(assembledDef, (await loadChainDefinitionToml(abspath, [filepath].concat(trace)))[0], customMerge);
    }
    lodash_1.default.mergeWith(assembledDef, lodash_1.default.omit(rawDef, 'include'), customMerge);
    return [assembledDef, buf];
}
/**
 * Forge added a breaking change where it stopped returning the ast on build artifacts,
 * and the user has to add the `--ast` param to have them included.
 * This check is so we make sure to have asts regardless the user's foundry version.
 * Ref: https://github.com/foundry-rs/foundry/pull/7197
 */
async function checkForgeAstSupport() {
    try {
        const result = await execPromise('forge build --help');
        return result.toString().includes('--ast');
    }
    catch (error) {
        throw new Error('Could not determine if forge ast flag is available');
    }
}
exports.checkForgeAstSupport = checkForgeAstSupport;
function getChainName(chainId) {
    return getChainDataFromId(chainId)?.name || 'unknown';
}
exports.getChainName = getChainName;
function getChainId(chainName) {
    if (chainName == 'cannon')
        return builder_1.CANNON_CHAIN_ID;
    if (chainName == 'hardhat')
        return 31337;
    const chainData = chains_1.chains.find((c) => c.name === chainName);
    if (!chainData) {
        throw new Error(`Invalid chain "${chainName}"`);
    }
    else {
        return chainData.id;
    }
}
exports.getChainId = getChainId;
function getChainDataFromId(chainId) {
    if (chainId == builder_1.CANNON_CHAIN_ID) {
        return chains_1.cannonChain;
    }
    return chains_1.chains.find((c) => c.id == chainId) || null;
}
exports.getChainDataFromId = getChainDataFromId;
async function ensureChainIdConsistency(providerUrl, chainId) {
    // only if both are defined
    if (providerUrl && chainId) {
        const isProviderUrl = (0, provider_1.isURL)(providerUrl);
        if (isProviderUrl) {
            const providerChainId = await (0, provider_1.getChainIdFromProviderUrl)(providerUrl);
            // throw an expected error if the chainId is not consistent with the provider's chainId
            if (Number(chainId) !== Number(providerChainId)) {
                console.log((0, chalk_1.red)(`Error: The chainId (${providerChainId}) obtained from the ${(0, chalk_1.bold)('--provider-url')} does not match with ${(0, chalk_1.bold)('--chain-id')} value (${chainId}). Please ensure that the ${(0, chalk_1.bold)('--chain-id')} value matches the network your provider is connected to.`));
                process.exit(1);
            }
        }
    }
}
exports.ensureChainIdConsistency = ensureChainIdConsistency;
function getMetadataPath(packageName) {
    const cliSettings = (0, settings_1.resolveCliSettings)();
    return path_1.default.join(cliSettings.cannonDirectory, 'metadata_cache', `${packageName.replace(':', '_')}.txt`);
}
async function saveToMetadataCache(packageName, key, value) {
    const metadataCache = await readMetadataCache(packageName);
    metadataCache[key] = value;
    await fs_extra_1.default.mkdirp(path_1.default.dirname(getMetadataPath(packageName)));
    await fs_extra_1.default.writeJson(getMetadataPath(packageName), metadataCache);
}
exports.saveToMetadataCache = saveToMetadataCache;
async function readMetadataCache(packageName) {
    try {
        return await fs_extra_1.default.readJson(getMetadataPath(packageName));
    }
    catch {
        return {};
    }
}
exports.readMetadataCache = readMetadataCache;
/**
 * Converts a camelCase string to a flag case string.
 *
 * @param key The camelCase string.
 * @returns The flag case string.
 */
function toFlagCase(key) {
    return `--${key.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`)}`;
}
exports.toFlagCase = toFlagCase;
/**
 * Converts an object of options to an array of command line arguments.
 *
 * @param options The options object.
 * @returns The command line arguments.
 */
function toArgs(options) {
    return Object.entries(options).flatMap(([key, value]) => {
        if (value === undefined) {
            return [];
        }
        const flag = toFlagCase(key);
        if (value === false) {
            return [];
        }
        else if (value === true) {
            return [flag];
        }
        const stringified = value.toString();
        if (stringified === '') {
            return [flag];
        }
        return [flag, stringified];
    });
}
exports.toArgs = toArgs;
/**
 * Extracts the contract and details from the state of a deploy package
 *
 * @param state The deploy package state
 * @returns an object containing ContractData
 *
 */
function getContractsAndDetails(state) {
    const contractsAndDetails = {};
    for (const key in state) {
        const contracts = state[key]?.artifacts?.contracts;
        if (contracts) {
            for (const contractName in contracts) {
                contractsAndDetails[contractName] = contracts[contractName];
            }
        }
    }
    return contractsAndDetails;
}
exports.getContractsAndDetails = getContractsAndDetails;
/**
 *
 * @param registries The cannon registries
 * @returns The source a cannon package is loaded from
 */
function getSourceFromRegistry(registries) {
    const prioritizedRegistry = registries[0];
    return prioritizedRegistry ? prioritizedRegistry.getLabel() : undefined;
}
exports.getSourceFromRegistry = getSourceFromRegistry;
/**
 * Verifies a private key is valid
 * @param privateKey The private key to verify
 * @returns boolean If the private key is valid
 */
function isPrivateKey(privateKey) {
    try {
        (0, accounts_1.privateKeyToAccount)(privateKey);
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.isPrivateKey = isPrivateKey;
/**
 * Normalizes a private key
 * @param privateKey The private key to normalize
 * @returns The normalized private key
 */
function normalizePrivateKey(privateKey) {
    return (privateKey.startsWith('0x') ? privateKey : `0x${privateKey}`);
}
exports.normalizePrivateKey = normalizePrivateKey;
/**
 * Checks and normalizes a private key
 * @param privateKey
 * @returnsThe normalized private keys
 */
function checkAndNormalizePrivateKey(privateKey) {
    if (!privateKey)
        return undefined;
    const privateKeys = privateKey.split(',').map((pk) => pk.trim());
    const normalizedPrivateKeys = privateKeys.map((key) => normalizePrivateKey(key));
    normalizedPrivateKeys.forEach((key) => {
        if (!isPrivateKey(key)) {
            throw new Error('Invalid private key found. Please verify the CANNON_PRIVATE_KEY environment variable, review your settings file, or check the value supplied to the --private-key flag');
        }
    });
    return normalizedPrivateKeys.join(',');
}
exports.checkAndNormalizePrivateKey = checkAndNormalizePrivateKey;
//# sourceMappingURL=helpers.js.map
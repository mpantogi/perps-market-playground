"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDryRunRegistry = exports.createDefaultReadRegistry = exports.ReadOnlyOnChainRegistry = exports.LocalRegistry = void 0;
const builder_1 = require("@usecannon/builder");
const chalk_1 = require("chalk");
const debug_1 = __importDefault(require("debug"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const is_connected_to_internet_1 = require("./util/is-connected-to-internet");
const provider_1 = require("./util/provider");
const debug = (0, debug_1.default)('cannon:cli:registry');
/**
 * stores packages in the filesystem, using the filename as a key and the contents as the value. very simple is the intent.
 */
class LocalRegistry extends builder_1.CannonRegistry {
    constructor(packagesDir) {
        super();
        this.packagesDir = packagesDir;
    }
    getLabel() {
        return 'local';
    }
    getTagReferenceStorage(packageRef, chainId) {
        const { name, version, preset } = new builder_1.PackageReference(packageRef);
        const variant = `${chainId}-${preset}`;
        return path_1.default.join(this.packagesDir, 'tags', `${name}_${version}_${variant}.txt`);
    }
    getMetaTagReferenceStorage(packageRef, chainId) {
        const { name, version, preset } = new builder_1.PackageReference(packageRef);
        const variant = `${chainId}-${preset}`;
        return path_1.default.join(this.packagesDir, 'tags', `${name}_${version}_${variant}.txt.meta`);
    }
    async getUrl(packageRef, chainId) {
        const { fullPackageRef } = new builder_1.PackageReference(packageRef);
        const baseResolved = await super.getUrl(fullPackageRef, chainId);
        if (baseResolved) {
            return baseResolved;
        }
        debug('load local package link', fullPackageRef, 'at file', this.getTagReferenceStorage(fullPackageRef, chainId).replace(os_1.default.homedir(), ''));
        try {
            return (await fs_extra_1.default.readFile(this.getTagReferenceStorage(fullPackageRef, chainId))).toString().trim();
        }
        catch (err) {
            debug('could not load:', err);
            return null;
        }
    }
    async getMetaUrl(packageRef, chainId) {
        const { fullPackageRef } = new builder_1.PackageReference(packageRef);
        try {
            debug('load local meta package link', fullPackageRef, 'at file', this.getMetaTagReferenceStorage(packageRef, chainId));
            return (await fs_extra_1.default.readFile(this.getMetaTagReferenceStorage(fullPackageRef, chainId))).toString().trim();
        }
        catch (err) {
            debug('could not load:', err);
            return null;
        }
    }
    async publish(packagesNames, chainId, url, metaUrl) {
        for (const packageName of packagesNames) {
            const { fullPackageRef } = new builder_1.PackageReference(packageName);
            debug('package local link', packageName);
            const file = this.getTagReferenceStorage(fullPackageRef, chainId);
            const metaFile = this.getMetaTagReferenceStorage(fullPackageRef, chainId);
            await fs_extra_1.default.mkdirp(path_1.default.dirname(file));
            await fs_extra_1.default.writeFile(file, url);
            await fs_extra_1.default.writeFile(metaFile, metaUrl);
        }
        return [];
    }
    async scanDeploys(packageRef, chainId) {
        const ref = builder_1.PackageReference.parse(packageRef);
        const allTags = await fs_extra_1.default.readdir(path_1.default.join(this.packagesDir, 'tags'));
        debug('scanning deploys in:', path_1.default.join(this.packagesDir, 'tags'), allTags);
        debug(`looking for ${packageRef}, ${chainId}`);
        return allTags
            .filter((t) => {
            if (t.endsWith('.txt')) {
                debug(`checking ${packageRef}, ${chainId} for a match with ${t}`);
                const [tagName, tagVersion, tagVariant] = t.replace('.txt', '').split('_');
                const [tagChainId, tagPreset] = builder_1.PackageReference.parseVariant(tagVariant);
                if (chainId && tagChainId !== Number(chainId)) {
                    return false;
                }
                let tag;
                try {
                    tag = builder_1.PackageReference.from(tagName, tagVersion, tagPreset);
                }
                catch (er) {
                    return false;
                }
                if (ref.name && ref.version && ref.preset) {
                    return ref.name === tag.name && ref.version === tag.version && ref.preset === tag.preset;
                }
                else if (ref.name && ref.version) {
                    return ref.name === tag.name && ref.version === tag.version;
                }
                else {
                    return ref.name === tag.name;
                }
            }
        })
            .map((t) => {
            const [name, version, tagVariant] = t.replace('.txt', '').split('_');
            const [chainId, preset] = builder_1.PackageReference.parseVariant(tagVariant);
            return { name: `${name}:${version}@${preset}`, chainId };
        });
    }
    async getAllUrls(filterPackage, chainId) {
        if (!filterPackage) {
            return new Set();
        }
        const { name, version, preset } = new builder_1.PackageReference(filterPackage);
        const filterVariant = `${chainId}-${preset}`;
        const urls = (await fs_extra_1.default.readdir(this.packagesDir))
            .filter((f) => f.match(new RegExp(`${name || '.*'}_${version || '.*'}_${filterVariant || '.*'}`)))
            .map((f) => fs_extra_1.default.readFileSync(path_1.default.join(this.packagesDir, f)).toString('utf8'));
        return new Set(urls);
    }
}
exports.LocalRegistry = LocalRegistry;
class ReadOnlyOnChainRegistry extends builder_1.OnChainRegistry {
    async publish() {
        throw new Error('Cannot execute write operations on ReadOnlyOnChainRegistry');
    }
    async publishMany() {
        throw new Error('Cannot execute write operations on ReadOnlyOnChainRegistry');
    }
    async setPackageOwnership() {
        throw new Error('Cannot execute write operations on ReadOnlyOnChainRegistry');
    }
}
exports.ReadOnlyOnChainRegistry = ReadOnlyOnChainRegistry;
async function checkLocalRegistryOverride({ fullPackageRef, chainId, result, registry, fallbackRegistry, }) {
    const localResult = await lodash_1.default.last(fallbackRegistry.registries).getUrl(fullPackageRef, chainId);
    if (registry instanceof builder_1.OnChainRegistry && localResult && localResult != result) {
        console.log((0, chalk_1.yellowBright)(`⚠️  The package ${fullPackageRef} was found on the official on-chain registry, but you also have a local build of this package. To use this local build instead, run this command with '--registry-priority local'`));
    }
}
async function createDefaultReadRegistry(cliSettings, additionalRegistries = []) {
    const registryProviders = await (0, provider_1.resolveRegistryProviders)(cliSettings);
    const localRegistry = new LocalRegistry(cliSettings.cannonDirectory);
    const onChainRegistries = registryProviders.map((p, i) => new ReadOnlyOnChainRegistry({ provider: p.provider, address: cliSettings.registries[i].address }));
    if (cliSettings.registryPriority === 'offline') {
        debug('running in offline mode, using local registry only');
        return new builder_1.FallbackRegistry([...additionalRegistries, localRegistry]);
    }
    else if (!(await (0, is_connected_to_internet_1.isConnectedToInternet)())) {
        debug('not connected to internet, using local registry only');
        // When not connected to the internet, we don't want to check the on-chain registry version to not throw an error
        console.log((0, chalk_1.yellowBright)('⚠️  You are not connected to the internet. Using local registry only'));
        return new builder_1.FallbackRegistry([...additionalRegistries, localRegistry]);
    }
    else if (cliSettings.registryPriority === 'local') {
        debug('local registry is the priority, using local registry first');
        return new builder_1.FallbackRegistry([...additionalRegistries, localRegistry, ...onChainRegistries]);
    }
    else {
        debug('on-chain registry is the priority, using on-chain registry first');
        const fallbackRegistry = new builder_1.FallbackRegistry([...additionalRegistries, ...onChainRegistries, localRegistry]);
        if (!cliSettings.quiet) {
            fallbackRegistry.on('getUrl', checkLocalRegistryOverride).catch((err) => {
                throw err;
            });
        }
        return fallbackRegistry;
    }
}
exports.createDefaultReadRegistry = createDefaultReadRegistry;
async function createDryRunRegistry(cliSettings) {
    return createDefaultReadRegistry(cliSettings, [new builder_1.InMemoryRegistry()]);
}
exports.createDryRunRegistry = createDryRunRegistry;
//# sourceMappingURL=registry.js.map
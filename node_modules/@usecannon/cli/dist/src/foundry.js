"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFoundryArtifact = exports.buildContracts = exports.getFoundryOpts = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const helpers_1 = require("./helpers");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('cannon:cli:foundry');
async function getFoundryOpts() {
    return JSON.parse(await lodash_1.default.memoize(() => (0, helpers_1.execPromise)('forge config --json'), () => '')());
}
exports.getFoundryOpts = getFoundryOpts;
async function buildContracts() {
    await (0, helpers_1.execPromise)('forge build');
}
exports.buildContracts = buildContracts;
async function getFoundryArtifact(name, baseDir = '', includeSourceCode = true) {
    // TODO: Theres a bug that if the file has a different name than the contract it would not work
    const foundryOpts = await getFoundryOpts();
    // Finds root of the foundry project based n owhere the foundry.toml file is within the relative path
    // Linear time complexity O(n) where n is the depth of the directory structure from the initial currentPath to the project root.
    function findProjectRoot(currentPath) {
        const markerFile = 'foundry.toml';
        // append 'foundry.toml' to filepath
        const filePath = path_1.default.join(currentPath, markerFile);
        // If filepath exists it means we're already at root of the project
        // so just return currentPath
        if (fs_extra_1.default.existsSync(filePath)) {
            return currentPath;
        }
        // Reached the filesystem root without finding the marker file
        const parentPath = path_1.default.dirname(currentPath);
        if (parentPath === currentPath) {
            console.warn('Could not find foundry project, make sure your cannonfiles are stored within the root of a foundry project.');
            return parentPath;
        }
        //Otherwise loop
        return findProjectRoot(parentPath);
    }
    baseDir = findProjectRoot(baseDir);
    const artifactPath = path_1.default.join(path_1.default.join(baseDir, foundryOpts.out), `${name}.sol`, `${name}.json`);
    const artifactBuffer = await fs_extra_1.default.readFile(artifactPath);
    const artifact = JSON.parse(artifactBuffer.toString());
    // if source code is not included, we can skip here for a massive speed boost by not executing the inspect commands
    if (includeSourceCode) {
        const isAstFlagSupported = await (0, helpers_1.checkForgeAstSupport)();
        // save build metadata
        const foundryInfo = JSON.parse(await (0, helpers_1.execPromise)(`forge inspect ${name} metadata  ${baseDir ? `--root ${baseDir}` : ''} ${isAstFlagSupported ? '--ast' : ''}`));
        const evmVersionInfo = JSON.parse(await (0, helpers_1.execPromise)('forge config --json')).evm_version;
        debug('detected foundry info', foundryInfo);
        debug('evm version', evmVersionInfo);
        const solcVersion = foundryInfo.compiler.version;
        const sources = lodash_1.default.mapValues(foundryInfo.sources, (v, sourcePath) => {
            return {
                content: fs_extra_1.default.readFileSync(path_1.default.join(baseDir, sourcePath)).toString(),
            };
        });
        const source = {
            solcVersion: solcVersion,
            input: JSON.stringify({
                language: 'Solidity',
                sources,
                settings: {
                    optimizer: foundryInfo.settings.optimizer,
                    evmVersion: evmVersionInfo,
                    remappings: foundryInfo.settings.remappings,
                    outputSelection: {
                        '*': {
                            '*': ['*'],
                        },
                    },
                },
            }),
        };
        return {
            contractName: name,
            sourceName: artifact.ast.absolutePath,
            abi: artifact.abi,
            bytecode: artifact.bytecode.object,
            deployedBytecode: artifact.deployedBytecode.object,
            linkReferences: artifact.bytecode.linkReferences,
            source,
        };
    }
    return {
        contractName: name,
        sourceName: artifact.ast.absolutePath,
        abi: artifact.abi,
        bytecode: artifact.bytecode.object,
        deployedBytecode: artifact.deployedBytecode.object,
        linkReferences: artifact.bytecode.linkReferences,
    };
}
exports.getFoundryArtifact = getFoundryArtifact;
//# sourceMappingURL=foundry.js.map
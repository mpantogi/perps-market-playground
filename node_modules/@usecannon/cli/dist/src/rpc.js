"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProviderProxy = exports.getProvider = exports.runRpc = exports.versionCheck = void 0;
const node_child_process_1 = require("node:child_process");
const node_http_1 = __importDefault(require("node:http"));
const builder_1 = require("@usecannon/builder");
const chalk_1 = require("chalk");
const debug_1 = __importDefault(require("debug"));
const lodash_1 = __importDefault(require("lodash"));
const viem = __importStar(require("viem"));
const chains_1 = require("./chains");
const helpers_1 = require("./helpers");
const debug = (0, debug_1.default)('cannon:cli:rpc');
const ANVIL_OP_TIMEOUT = 10000;
// saved up here to allow for reset of existing process
let anvilInstance = null;
let anvilProvider = null;
exports.versionCheck = lodash_1.default.once(async () => {
    const anvilVersionInfo = await (0, helpers_1.execPromise)('anvil --version');
    if (anvilVersionInfo.match(/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/)[0] < '2023-06-04') {
        throw new Error("anvil version too old. please run 'foundryup' to get the latest version");
    }
});
async function runRpc(anvilOptions, rpcOptions = {}) {
    debug('run rpc', anvilOptions, rpcOptions);
    const { forkProvider } = rpcOptions;
    await (0, exports.versionCheck)();
    if (lodash_1.default.isNil(anvilOptions.chainId)) {
        anvilOptions.chainId = builder_1.CANNON_CHAIN_ID;
    }
    // reduce image size by not creating unnecessary accounts
    if (lodash_1.default.isNil(anvilOptions.accounts)) {
        anvilOptions.accounts = 1;
    }
    if (anvilOptions.forkUrl && rpcOptions.forkProvider) {
        throw new Error('Cannot set both an anvil forkUrl and a proxy provider connection');
    }
    // create a tiny proxy server (the most reliable way to make sure that the connection can work anywhere)
    if (forkProvider) {
        const url = await createProviderProxy(forkProvider);
        anvilOptions.forkUrl = url;
    }
    if (anvilInstance && anvilInstance.exitCode === null) {
        console.log('shutting down existing anvil subprocess', anvilInstance.pid);
        return viem.withTimeout(() => new Promise((resolve) => {
            anvilInstance.once('close', async () => {
                anvilInstance = null;
                resolve(await runRpc(anvilOptions, rpcOptions));
            });
            anvilInstance.kill();
        }), {
            timeout: ANVIL_OP_TIMEOUT,
            errorInstance: new Error('could not shut down previous anvil'),
        });
    }
    let opts = (0, helpers_1.toArgs)(anvilOptions);
    // Anvil fails to accept the `forkUrl` and `chainId` options on the Arbitrum network.
    // Ref: https://github.com/foundry-rs/foundry/issues/4786
    if ('forkUrl' in anvilOptions) {
        opts = (0, helpers_1.toArgs)(lodash_1.default.omit(anvilOptions, ['chainId']));
    }
    debug('starting anvil instance with options: ', anvilOptions);
    return viem.withTimeout(() => new Promise((resolve, reject) => {
        anvilInstance = (0, node_child_process_1.spawn)('anvil', opts);
        anvilInstance.port = anvilOptions.port;
        anvilInstance.forkProvider = forkProvider;
        anvilInstance.chainId = anvilOptions.chainId;
        process.once('exit', () => anvilInstance?.kill());
        let state = 'spawning';
        anvilInstance?.on('spawn', () => {
            state = 'running';
        });
        anvilInstance?.on('error', (err) => {
            if (state == 'spawning') {
                reject(new Error(`Anvil failed to start: ${err}

Though it is not necessary for your hardhat project, Foundry is required to use Cannon.

Ensure you have foundry and anvil installed by running the following commands:

curl -L https://foundry.paradigm.xyz | bash
foundryup

For more info, see https://book.getfoundry.sh/getting-started/installation.html
          `));
            }
        });
        anvilInstance?.stdout?.on('data', (rawChunk) => {
            // right now check for expected output string to connect to node
            const chunk = rawChunk.toString('utf8');
            const m = chunk.match(/Listening on (.*)/);
            if (m) {
                const host = 'http://' + m[1];
                state = 'listening';
                console.log((0, chalk_1.gray)('Anvil instance running on:', host, '\n'));
                // TODO: why is this type not working out? (something about mode being wrong?)
                anvilProvider = viem
                    .createTestClient({
                    mode: 'anvil',
                    chain: anvilOptions.chainId ? (0, chains_1.getChainById)(anvilOptions.chainId) || chains_1.cannonChain : chains_1.cannonChain,
                    transport: viem.http(host),
                })
                    .extend(viem.publicActions)
                    .extend(viem.walletActions);
                anvilInstance.host = host;
                resolve(anvilInstance);
            }
            debug(chunk);
        });
        anvilInstance.stderr?.on('data', (rawChunk) => {
            const chunk = rawChunk.toString('utf8');
            console.error(chunk.split('\n').map((m) => 'anvil: ' + m));
        });
    }), {
        timeout: ANVIL_OP_TIMEOUT,
        errorInstance: new Error('anvil failed to start'),
    });
}
exports.runRpc = runRpc;
function getProvider(expectedAnvilInstance) {
    if (anvilInstance === expectedAnvilInstance) {
        return anvilProvider;
    }
    else {
        throw new Error('anvil instance is not as expected');
    }
}
exports.getProvider = getProvider;
function createProviderProxy(provider) {
    return new Promise((resolve) => {
        const server = node_http_1.default.createServer(async (req, res) => {
            res.setHeader('Content-Type', 'application/json');
            const reqJson = JSON.parse(await streamToString(req));
            try {
                const proxiedResult = await provider.request(reqJson);
                res.writeHead(200);
                res.end(JSON.stringify({
                    jsonrpc: '2.0',
                    result: proxiedResult,
                    id: reqJson.id,
                }));
            }
            catch (err) {
                console.log('got rpc error', err);
                res.writeHead(400);
                res.end(JSON.stringify({
                    jsonrpc: '2.0',
                    error: err,
                    id: reqJson.id,
                }));
            }
        });
        server.on('listening', () => {
            const addrInfo = server.address();
            debug(`Proxied server listening on: ${addrInfo.address}:${addrInfo.port} (${addrInfo.family})`);
            resolve(`http://127.0.0.1:${addrInfo.port}`);
        });
        server.listen();
    });
}
exports.createProviderProxy = createProviderProxy;
function streamToString(stream) {
    const chunks = [];
    return new Promise((resolve, reject) => {
        stream.on('data', (chunk) => chunks.push(Buffer.from(chunk)));
        stream.on('error', (err) => reject(err));
        stream.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));
    });
}
//# sourceMappingURL=rpc.js.map
"use strict";
/* eslint-disable no-console */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OnChainRegistry = exports.FallbackRegistry = exports.InMemoryRegistry = exports.CannonRegistry = void 0;
const chalk_1 = require("chalk");
const debug_1 = __importDefault(require("debug"));
const lodash_1 = __importDefault(require("lodash"));
const promise_events_1 = __importDefault(require("promise-events"));
const viem = __importStar(require("viem"));
const CannonRegistry_1 = __importDefault(require("./abis/CannonRegistry"));
const multicall_1 = require("./multicall");
const package_1 = require("./package");
const debug = (0, debug_1.default)('cannon:builder:registry');
class CannonRegistry {
    async publishMany(toPublish) {
        const receipts = [];
        for (const pub of toPublish) {
            await this.publish(pub.packagesNames, pub.chainId, pub.url, pub.metaUrl);
        }
        return receipts;
    }
    // in general a "catchall" is that if the fullPackageRef is in format "@service:path", then
    // that is a direct service resolve
    // ex @ipfs:Qm... is ipfs://Qm...
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getUrl(serviceRef, chainId) {
        // Check if its an ipfs hash / url, if so we make sure to remove any incorrectly appended presets (like @main);
        if (serviceRef.startsWith('@')) {
            const result = serviceRef.replace(':', '://').replace('@', '');
            return result.indexOf('@') !== -1 ? result.slice(0, result.indexOf('@')) : result;
        }
        return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getMetaUrl(serviceRef, chainId) {
        return null;
    }
    // used to clean up unused resources on a loader
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getAllUrls(filterPackageRef, chainId) {
        return new Set();
    }
}
exports.CannonRegistry = CannonRegistry;
/**
 * keeps track of packages in a simple JS object
 * useful for testing and deployment dry-runs
 */
class InMemoryRegistry extends CannonRegistry {
    constructor() {
        super(...arguments);
        this.pkgs = {};
        this.metas = {};
        this.count = 0;
    }
    getLabel() {
        return 'memory';
    }
    async publish(packagesNames, chainId, url, meta) {
        const receipts = [];
        for (const rawName of packagesNames) {
            const { preset, packageRef } = new package_1.PackageReference(rawName);
            const variant = `${chainId}-${preset}`;
            debug('in memory publish', preset, packageRef, variant, rawName);
            if (!this.pkgs[packageRef]) {
                this.pkgs[packageRef] = {};
            }
            if (!this.metas[packageRef]) {
                this.metas[packageRef] = {};
            }
            this.pkgs[packageRef][variant] = url;
            if (meta) {
                this.metas[packageRef][variant] = meta;
            }
            receipts.push((++this.count).toString());
        }
        return receipts;
    }
    async getUrl(packageOrServiceRef, chainId) {
        const baseResolved = await super.getUrl(packageOrServiceRef, chainId);
        if (baseResolved)
            return baseResolved;
        const { preset, packageRef } = new package_1.PackageReference(packageOrServiceRef);
        const variant = `${chainId}-${preset}`;
        return this.pkgs[packageRef] ? this.pkgs[packageRef][variant] : null;
    }
    async getMetaUrl(packageOrServiceRef, chainId) {
        const { preset, packageRef } = new package_1.PackageReference(packageOrServiceRef);
        const variant = `${chainId}-${preset}`;
        return this.metas[packageRef] ? this.metas[packageRef][variant] : null;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getAllUrls(filterPackage, chainId) {
        return new Set();
    }
}
exports.InMemoryRegistry = InMemoryRegistry;
class FallbackRegistry extends promise_events_1.default {
    constructor(registries) {
        super();
        this.memoryCacheRegistry = new InMemoryRegistry();
        this.registries = registries;
    }
    getLabel() {
        return `${this.registries.map((r) => r.getLabel()).join(', ')}`;
    }
    async getUrl(packageRef, chainId) {
        const { fullPackageRef } = new package_1.PackageReference(packageRef);
        debug('resolving', fullPackageRef, chainId);
        for (const registry of [this.memoryCacheRegistry, ...this.registries]) {
            debug('trying registry', registry.getLabel());
            try {
                const result = await registry.getUrl(packageRef, chainId);
                if (result) {
                    debug('fallback registry: loaded from registry', registry.getLabel());
                    await this.emit('getPackageUrl', { fullPackageRef, chainId, result, registry, fallbackRegistry: this });
                    return result;
                }
            }
            catch (err) {
                debug('WARNING: error caught in registry:', err);
                if (err.error && err.error.data === '0x') {
                    throw new Error('JSON-RPC Error: This is likely an error on the RPC provider being used, ' +
                        `you can verify this if you have access to the node logs. \n\n ${err} \n ${err.error}`);
                }
            }
        }
        return null;
    }
    async getMetaUrl(packageOrServiceRef, chainId) {
        const { preset, fullPackageRef } = new package_1.PackageReference(packageOrServiceRef);
        for (const registry of this.registries) {
            try {
                const result = await registry.getMetaUrl(fullPackageRef, chainId);
                if (result) {
                    await this.emit('getMetaUrl', { fullPackageRef, preset, chainId, result, registry });
                    return result;
                }
            }
            catch (err) {
                debug('WARNING: error caught in registry:', err);
                if (err.error && err.error.data === '0x') {
                    throw new Error('JSON-RPC Error: This is likely an error on the RPC provider being used, ' +
                        `you can verify this if you have access to the node logs. \n\n ${err} \n ${err.error}`);
                }
            }
        }
        return null;
    }
    async getAllUrls(filterPackageRef, chainId) {
        const r = await Promise.all(this.registries.map((r) => r.getAllUrls(filterPackageRef, chainId)));
        // apparently converting back to an array is the most efficient way to merge sets
        return new Set(r.flatMap((s) => Array.from(s)));
    }
    async publish(packagesNames, chainId, url, metaUrl) {
        debug('publish to fallback database: ', packagesNames);
        // try to publish to any of the registries
        await this.memoryCacheRegistry.publish(packagesNames, chainId, url, metaUrl);
        // now push to other registries.
        // first one to succeed is fine.
        const errors = [];
        for (const registry of this.registries) {
            try {
                debug('try publish to registry', registry.getLabel());
                return await registry.publish(packagesNames, chainId, url, metaUrl);
            }
            catch (err) {
                debug('error caught in registry while publishing (may be normal):', err);
                errors.push(err);
            }
        }
        throw new Error('no registry succeeded in publishing:\n' + errors.map((e) => e.message).join('\n'));
    }
    async publishMany(toPublish) {
        const receipts = [];
        for (const pub of toPublish) {
            await this.publish(pub.packagesNames, pub.chainId, pub.url, pub.metaUrl);
        }
        return receipts;
    }
}
exports.FallbackRegistry = FallbackRegistry;
class OnChainRegistry extends CannonRegistry {
    constructor({ address, signer, provider, overrides = {}, }) {
        super();
        this.signer = signer;
        this.provider = provider;
        this.contract = { address, abi: CannonRegistry_1.default };
        this.overrides = overrides;
        debug(`created registry on address "${address}"`);
    }
    getLabel() {
        return `${this.contract.address}`;
    }
    /**
     * Checks if package needs to be registered before publishing.
     * @param packageName
     * @returns Boolean
     */
    async _isPackageRegistered(packageName) {
        const packageOwner = await this.getPackageOwner(packageName);
        return !viem.isAddressEqual(packageOwner, viem.zeroAddress);
    }
    async _checkPackageOwnership(packageName) {
        if (!this.signer || !this.provider) {
            throw new Error('Missing signer for executing registry operations');
        }
        const packageOwner = await this.getPackageOwner(packageName);
        const signer = viem.getAddress(this.signer.address);
        if (viem.isAddressEqual(packageOwner, viem.zeroAddress)) {
            throw new Error(`The package "${packageName}" is not registered to be owned by anyone. Please register the package before publishing for the first time.`);
        }
        if (viem.isAddressEqual(signer, packageOwner))
            return;
        const additionalPublishers = await this.getAdditionalPublishers(packageName);
        if (!additionalPublishers.some((deployer) => viem.isAddressEqual(signer, deployer))) {
            throw new Error(`Signer "${signer}" does not have publishing permissions on the "${packageName}" package`);
        }
    }
    _preparePackageData(packagesNames, chainId, url, metaUrl) {
        const refs = packagesNames.map((name) => new package_1.PackageReference(name));
        // Sanity check, all package definitions should have the same name
        if (lodash_1.default.uniq(refs.map((r) => r.name)).length !== 1) {
            throw new Error(`packages should have the same name: ${packagesNames.join(', ')}`);
        }
        // Sanity check, all package definitions should have the same preset
        if (lodash_1.default.uniq(refs.map((r) => r.preset)).length !== 1) {
            throw new Error(`packages should have the same preset: ${packagesNames.join(', ')}`);
        }
        const { name, preset } = refs[0];
        const variant = `${chainId}-${preset}`;
        const tags = refs.map((ref) => ref.version);
        console.log(`Package: ${name}`);
        if (preset !== package_1.PackageReference.DEFAULT_PRESET) {
            console.log(`Preset: ${preset}`);
        }
        console.log(`Tags: ${tags.join(', ')}`);
        if (url) {
            console.log(`Package URL: ${url}`);
        }
        if (metaUrl) {
            console.log(`Metadata URL: ${metaUrl}`);
        }
        console.log('\n');
        return { name, variant, tags, url, metaUrl };
    }
    async _unpublishPackages(packages) {
        if (!this.signer || !this.provider) {
            throw new Error('Missing signer for executing registry operations');
        }
        debug('signer', this.signer);
        const txs = packages.map((data) => ({
            abi: this.contract.abi,
            address: this.contract.address,
            functionName: 'unpublish',
            value: BigInt(0),
            args: [
                viem.stringToHex(data.name, { size: 32 }),
                viem.stringToHex(data.variant, { size: 32 }),
                data.tags.map((t) => viem.stringToHex(t, { size: 32 })),
            ],
        }));
        const txData = txs.length === 1 ? txs[0] : (0, multicall_1.prepareMulticall)(txs);
        const params = {
            ...txData,
            account: this.signer.wallet.account || this.signer.address,
            ...this.overrides,
        };
        const simulatedGas = await this.provider.estimateContractGas(params);
        await this._logEstimatedGas(simulatedGas);
        const tx = await this.provider.simulateContract(params);
        const hash = await this.signer.wallet.writeContract(tx.request);
        const receipt = await this.provider.waitForTransactionReceipt({ hash });
        return receipt.transactionHash;
    }
    async _publishPackages(packages) {
        if (!this.signer || !this.provider) {
            throw new Error('Missing signer for executing registry operations');
        }
        debug('signer', this.signer);
        const ownerAddress = this.signer.wallet.account?.address || this.signer.address;
        const publishFee = await this.getPublishFee();
        const txs = packages.map((data) => ({
            abi: this.contract.abi,
            address: this.contract.address,
            functionName: 'publish',
            value: publishFee,
            args: [
                viem.stringToHex(data.name, { size: 32 }),
                viem.stringToHex(data.variant, { size: 32 }),
                data.tags.map((t) => viem.stringToHex(t, { size: 32 })),
                data.url,
                data.metaUrl || '',
            ],
        }));
        await Promise.all(packages.map(async ({ name }) => {
            if (await this._isPackageRegistered(name)) {
                await this._checkPackageOwnership(name);
            }
            else {
                txs.unshift({
                    abi: this.contract.abi,
                    address: this.contract.address,
                    functionName: 'setPackageOwnership',
                    args: [viem.stringToHex(name, { size: 32 }), ownerAddress],
                });
            }
        }));
        const txData = txs.length === 1 ? txs[0] : (0, multicall_1.prepareMulticall)(txs);
        const params = {
            ...txData,
            account: this.signer.wallet.account || this.signer.address,
            ...this.overrides,
        };
        const simulatedGas = await this.provider.estimateContractGas(params);
        await this._logEstimatedGas(simulatedGas);
        const tx = await this.provider.simulateContract(params);
        const hash = await this.signer.wallet.writeContract(tx.request);
        const receipt = await this.provider.waitForTransactionReceipt({ hash });
        return receipt.transactionHash;
    }
    async publish(packagesNames, chainId, url, metaUrl) {
        console.log((0, chalk_1.bold)((0, chalk_1.blueBright)('\nPublishing package to the registry on-chain...\n')));
        const packageData = this._preparePackageData(packagesNames, chainId, url, metaUrl);
        return [await this._publishPackages([packageData])];
    }
    async publishMany(toPublish) {
        console.log((0, chalk_1.bold)((0, chalk_1.blueBright)('\nPublishing packages to the registry on-chain...\n')));
        const packageDatas = toPublish.map((p) => this._preparePackageData(p.packagesNames, p.chainId, p.url, p.metaUrl));
        return [await this._publishPackages(packageDatas)];
    }
    async unpublish(packagesNames, chainId) {
        console.log((0, chalk_1.bold)((0, chalk_1.blueBright)('\nUnpublishing package to the registry on-chain...\n')));
        const packageData = this._preparePackageData(packagesNames, chainId);
        return [await this._unpublishPackages([packageData])];
    }
    async unpublishMany(toUnpublish) {
        console.log((0, chalk_1.bold)((0, chalk_1.blueBright)('\nUnpublishing packages to the registry on-chain...\n')));
        const packageDatas = toUnpublish.map((p) => this._preparePackageData(p.name, p.chainId));
        return [await this._unpublishPackages(packageDatas)];
    }
    async getUrl(packageOrServiceRef, chainId) {
        if (!this.provider) {
            throw new Error('provider not given to getUrl');
        }
        const baseResolved = await super.getUrl(packageOrServiceRef, chainId);
        if (baseResolved)
            return baseResolved;
        const { name, version, preset } = new package_1.PackageReference(packageOrServiceRef);
        const variant = `${chainId}-${preset}`;
        const url = await this.provider.readContract({
            address: this.contract.address,
            abi: this.contract.abi,
            functionName: 'getPackageUrl',
            args: [
                viem.stringToHex(name, { size: 32 }),
                viem.stringToHex(version, { size: 32 }),
                viem.stringToHex(variant, { size: 32 }),
            ],
        });
        return url || null;
    }
    async getMetaUrl(packageOrServiceRef, chainId) {
        if (!this.provider) {
            throw new Error('provider not given to getUrl');
        }
        const baseResolved = await super.getUrl(packageOrServiceRef, chainId);
        if (baseResolved)
            return baseResolved;
        const { name, version, preset } = new package_1.PackageReference(packageOrServiceRef);
        const variant = `${chainId}-${preset}`;
        const url = await this.provider.readContract({
            ...this.contract,
            functionName: 'getPackageMeta',
            args: [
                viem.stringToHex(name, { size: 32 }),
                viem.stringToHex(version, { size: 32 }),
                viem.stringToHex(variant, { size: 32 }),
            ],
        });
        return url || null;
    }
    async getAllUrls(filterPackageRef, chainId) {
        if (!this.provider) {
            throw new Error('no provider');
        }
        let filterName = null;
        let filterVersion = null;
        let filterVariant = null;
        if (filterPackageRef) {
            const { name, version, preset } = new package_1.PackageReference(filterPackageRef);
            const variant = `${chainId}-${preset}`;
            filterName = name ? viem.stringToHex(name) : null;
            filterVersion = version ? viem.stringToHex(version) : null;
            filterVariant = variant ? viem.stringToHex(variant) : null;
        }
        const curBlock = Number(await this.provider.getBlockNumber());
        // most of these apis max their results at 10000
        // currently we dont see so many publishes to go over 10000 easily in a single request, but to make sure
        // we also check that the returned request items is not equal to 10000 exactly (otherwise something probably borked up)
        const BLOCK_SCAN_BATCH = filterName ? 1e10 : 50000;
        const rawEvents = [];
        for (let i = 16490000; i < curBlock; i += BLOCK_SCAN_BATCH) {
            debug(`scan events for getAllUrls ${i} -- ${i + BLOCK_SCAN_BATCH}`);
            rawEvents.push(...(await this.provider.getLogs({
                address: this.contract.address,
                event: viem.getAbiItem({ abi: this.contract.abi, name: 'PackagePublish' }),
                args: [filterName, filterVersion, filterVariant],
                fromBlock: BigInt(i),
                toBlock: BigInt(Math.min(curBlock, i + BLOCK_SCAN_BATCH)),
            })));
        }
        debug(`received ${rawEvents.length} package publish events`);
        const decodedEvents = viem.parseEventLogs({
            logs: rawEvents,
            eventName: 'PackagePublish',
            abi: this.contract.abi,
        });
        return new Set(decodedEvents.flatMap((e) => [e.args.deployUrl, e.args.metaUrl]));
    }
    async getPackageOwner(packageName) {
        if (!this.provider) {
            throw new Error('Missing signer for executing registry operations');
        }
        const packageHash = viem.stringToHex(packageName, { size: 32 });
        return this.provider.readContract({
            ...this.contract,
            functionName: 'getPackageOwner',
            args: [packageHash],
        });
    }
    async getAdditionalPublishers(packageName) {
        if (!this.provider) {
            throw new Error('Missing signer for executing registry operations');
        }
        const packageHash = viem.stringToHex(packageName, { size: 32 });
        return await this.provider?.readContract({
            ...this.contract,
            functionName: 'getAdditionalPublishers',
            args: [packageHash],
        });
    }
    async estimateGasForSetPackageOwnership(transactions) {
        if (!this.signer || !this.provider) {
            throw new Error('Missing signer for executing registry operations');
        }
        const simulatedGas = await this.provider.estimateContractGas({
            ...transactions,
            account: this.signer.wallet.account || this.signer.address,
            ...this.overrides,
        });
        return simulatedGas;
    }
    async calculatePublishingFee(packageCount) {
        if (!this.provider) {
            throw new Error('Missing provider for executing registry operations');
        }
        const publishFee = await this.getPublishFee();
        return BigInt(packageCount) * publishFee;
    }
    async getRegisterFee() {
        if (!this.provider) {
            throw new Error('Missing provider for executing registry operations');
        }
        const registerFee = (await this.provider.readContract({
            abi: this.contract.abi,
            address: this.contract.address,
            functionName: 'registerFee',
        }));
        return registerFee;
    }
    async getPublishFee() {
        if (!this.provider) {
            throw new Error('Missing provider for executing registry operations');
        }
        const publishFee = (await this.provider.readContract({
            abi: this.contract.abi,
            address: this.contract.address,
            functionName: 'publishFee',
        }));
        return publishFee;
    }
    async prepareSetPackageOwnership(packageName, packageOwner, shouldNominateOwner) {
        if (!this.signer || !this.provider) {
            throw new Error('Missing signer for executing registry operations');
        }
        const packageHash = viem.stringToHex(packageName, { size: 32 });
        const owner = packageOwner || this.signer.address;
        const registerFee = await this.getRegisterFee();
        const transactions = [];
        // first step: nominate the owner if needed
        if (shouldNominateOwner) {
            const setNominatePackageOwnerParams = {
                ...this.contract,
                functionName: 'nominatePackageOwner',
                args: [packageHash, owner],
                account: this.signer.wallet.account || this.signer.address,
            };
            transactions.push(setNominatePackageOwnerParams);
        }
        // second step: set the package ownership
        const setPackageOwnershipParams = {
            ...this.contract,
            functionName: 'setPackageOwnership',
            value: registerFee,
            args: [packageHash, owner],
            account: this.signer.wallet.account || this.signer.address,
        };
        // third step: set the additional publishers
        const setAdditionalPublishersParams = {
            ...this.contract,
            functionName: 'setAdditionalPublishers',
            // mainnet is empty, owner is set as publisher for optimism
            args: [packageHash, [], [owner]],
            account: this.signer.wallet.account || this.signer.address,
        };
        transactions.push(setPackageOwnershipParams);
        transactions.push(setAdditionalPublishersParams);
        return transactions;
    }
    async setPackageOwnership(transactions) {
        if (!this.signer || !this.provider) {
            throw new Error('Missing signer for executing registry operations');
        }
        const params = {
            ...transactions,
            account: this.signer.wallet.account || this.signer.address,
            ...this.overrides,
        };
        const simulatedGas = await this.provider.estimateContractGas(params);
        await this._logEstimatedGas(simulatedGas);
        // note: hardcoded gas to make sure the transaction goes through
        params.gas = BigInt(2500000);
        const tx = await this.provider.simulateContract(params);
        const hash = await this.signer.wallet.writeContract(tx.request);
        const receipt = await this.provider.waitForTransactionReceipt({ hash });
        if (receipt.status !== 'success') {
            throw new Error(`Something went wrong. Transaction failed: ${receipt.transactionHash}`);
        }
        return receipt.transactionHash;
    }
    async setAdditionalPublishers(packageName, mainnetPublishers, optimismPublishers) {
        if (!this.signer || !this.provider) {
            throw new Error('Missing signer for executing registry operations');
        }
        const packageHash = viem.stringToHex(packageName, { size: 32 });
        const params = {
            ...this.contract,
            functionName: 'setAdditionalPublishers',
            args: [packageHash, mainnetPublishers, optimismPublishers],
            account: this.signer.wallet.account || this.signer.address,
            ...this.overrides,
        };
        const simulatedGas = await this.provider.estimateContractGas(params);
        const userBalance = await this.provider.getBalance({ address: this.signer.address });
        // note: hardcoded gas to make sure the transaction goes through
        params.gas = BigInt(2000000);
        await this._logEstimatedGas(simulatedGas);
        const cost = simulatedGas;
        if (cost > userBalance) {
            throw new Error(`Account "${this.signer.address}" does not have the required ${viem.formatEther(cost)} ETH for gas`);
        }
        const tx = await this.provider.simulateContract(params);
        const hash = await this.signer.wallet.writeContract(tx.request);
        const rx = await this.provider.waitForTransactionReceipt({ hash });
        if (rx.status !== 'success') {
            throw new Error(`Something went wrong. Transaction failed: ${rx.transactionHash}`);
        }
        return rx.transactionHash;
    }
    async _logEstimatedGas(simulatedGas) {
        if (!this.signer || !this.provider) {
            throw new Error('Missing signer for executing registry operations');
        }
        const userBalance = await this.provider.getBalance({ address: this.signer.address });
        if (!userBalance) {
            throw new Error(`Signer at address ${this.signer.address} is not funded with ETH. Please ensure you have ETH in your wallet in order to perform the operation.`);
        }
        console.log(`\nEstimated gas: ${simulatedGas} wei`);
        const gasPrice = BigInt(this.overrides.maxFeePerGas || this.overrides.gasPrice || (await this.provider.getGasPrice()));
        console.log(`\nGas price: ${viem.formatEther(gasPrice)} ETH`);
        const transactionFeeWei = simulatedGas * gasPrice;
        console.log(`\nEstimated transaction Fee: ${viem.formatEther(transactionFeeWei)} ETH\n\n`);
        if (this.signer && userBalance < transactionFeeWei) {
            console.log((0, chalk_1.bold)((0, chalk_1.yellow)(`The address "${this.signer.address}" does not have enough funds to pay for the transaction, the transaction will likely revert.\n`)));
        }
    }
}
exports.OnChainRegistry = OnChainRegistry;
//# sourceMappingURL=registry.js.map
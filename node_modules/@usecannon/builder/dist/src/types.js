"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.combineCtx = exports.CannonHelperContext = void 0;
const viem = __importStar(require("viem"));
const lodash_1 = __importDefault(require("lodash"));
const etherUnitNames = ['wei', 'kwei', 'mwei', 'gwei', 'szabo', 'finney', 'ether'];
exports.CannonHelperContext = {
    // ethers style constants
    AddressZero: viem.zeroAddress,
    HashZero: viem.zeroHash,
    MaxUint256: viem.maxUint256,
    // ethers style utils
    defaultAbiCoder: {
        encode: (a, v) => {
            return viem.encodeAbiParameters(a.map((arg) => ({ type: arg })), v);
        },
        decode: (a, v) => {
            return viem.decodeAbiParameters(a.map((arg) => ({ type: arg })), v);
        },
    },
    zeroPad: (a, s) => viem.padHex(a, { size: s }),
    hexZeroPad: (a, s) => viem.padHex(a, { size: s }),
    hexlify: viem.toHex,
    stripZeros: viem.trim,
    formatBytes32String: (v) => viem.stringToHex(v, { size: 32 }),
    parseBytes32String: (v) => viem.hexToString(v, { size: 32 }),
    id: (v) => (v.startsWith('function ') ? viem.toFunctionSelector(v) : viem.keccak256(viem.toHex(v))),
    formatEther: viem.formatEther,
    formatUnits: (s, units) => {
        if (typeof units === 'string') {
            const index = etherUnitNames.indexOf(units);
            if (index < 0) {
                throw new Error(`formatUnits: unknown ethereum unit name: ${units}`);
            }
            units = 3 * index;
        }
        return viem.formatUnits(s, units);
    },
    parseEther: viem.parseEther,
    parseUnits: (s, units) => {
        if (typeof units === 'string') {
            const index = etherUnitNames.indexOf(units);
            if (index < 0) {
                throw new Error(`parseUnits: unknown ethereum unit name: ${units}`);
            }
            units = 3 * index;
        }
        return viem.parseUnits(s, units);
    },
    keccak256: viem.keccak256,
    sha256: viem.sha256,
    ripemd160: viem.ripemd160,
    solidityPack: viem.encodePacked,
    solidityKeccak256: (a, v) => viem.keccak256(viem.encodePacked(a, v)),
    soliditySha256: (a, v) => viem.sha256(viem.encodePacked(a, v)),
    serializeTransaction: viem.serializeTransaction,
    parseTransaction: viem.parseTransaction,
    encodeFunctionData: viem.encodeFunctionData,
    decodeFunctionData: viem.decodeFunctionData,
    encodeFunctionResult: viem.encodeFunctionResult,
    decodeFunctionResult: viem.decodeFunctionResult,
};
function combineCtx(ctxs) {
    const ctx = lodash_1.default.clone(ctxs[0]);
    ctx.timestamp = Math.floor(Date.now() / 1000).toString(); //(await this.provider.getBlock(await this.provider.getBlockNumber())).timestamp.toString();
    // merge all blockchain outputs
    for (const additionalCtx of ctxs.slice(1)) {
        ctx.contracts = { ...ctx.contracts, ...additionalCtx.contracts };
        ctx.txns = { ...ctx.txns, ...additionalCtx.txns };
        ctx.imports = { ...ctx.imports, ...additionalCtx.imports };
        ctx.settings = { ...ctx.settings, ...additionalCtx.settings };
    }
    return ctx;
}
exports.combineCtx = combineCtx;
//# sourceMappingURL=types.js.map
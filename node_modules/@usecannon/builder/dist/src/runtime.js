"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainBuilderRuntime = exports.CannonStorage = exports.Events = void 0;
const chalk_1 = require("chalk");
const debug_1 = __importDefault(require("debug"));
const viem = __importStar(require("viem"));
const events_1 = require("events");
const lodash_1 = __importDefault(require("lodash"));
const _1 = require("./");
const loader_1 = require("./loader");
const error_1 = require("./error");
const util_1 = require("./util");
const debug = (0, debug_1.default)('cannon:builder:runtime');
var Events;
(function (Events) {
    Events["PreStepExecute"] = "pre-step-execute";
    Events["PostStepExecute"] = "post-step-execute";
    Events["DeployContract"] = "deploy-contract";
    Events["DeployTxn"] = "deploy-txn";
    Events["DeployExtra"] = "deploy-extra";
    Events["SkipDeploy"] = "skip-deploy";
    Events["ResolveDeploy"] = "resolve-deploy";
    Events["DownloadDeploy"] = "download-deploy";
})(Events || (exports.Events = Events = {}));
class CannonStorage extends events_1.EventEmitter {
    constructor(registry, loaders, defaultLoaderScheme = 'ipfs') {
        super();
        this.registry = registry;
        this.defaultLoaderScheme = defaultLoaderScheme;
        this.loaders = loaders;
    }
    lookupLoader(url) {
        if (!url) {
            throw new Error('url not defined');
        }
        const loaderScheme = url.includes(':') ? url.split(':')[0] : 'ipfs';
        if (!this.loaders[loaderScheme]) {
            throw new Error(`loader scheme not configured: ${loaderScheme}`);
        }
        return this.loaders[loaderScheme];
    }
    getLabel() {
        return ` registry ${this.registry.getLabel()} loader ${Object.values(this.loaders)
            .map((loader) => loader.getLabel())
            .join(', ')}`;
    }
    readBlob(url) {
        const loader = this.lookupLoader(url);
        let loaderLabel;
        if (loader instanceof loader_1.IPFSLoader) {
            loaderLabel = loader.ipfsUrl;
        }
        else {
            loaderLabel = loader.getLabel();
        }
        this.emit(Events.DownloadDeploy, url, loaderLabel, 0);
        return loader.read(url);
    }
    putBlob(data) {
        return this.loaders[this.defaultLoaderScheme].put(data);
    }
    deleteBlob(url) {
        const loader = this.lookupLoader(url);
        if (loader.remove) {
            return loader.remove(url);
        }
    }
    async readDeploy(packageRef, chainId) {
        const registryName = this.registry.getLabel();
        const { preset } = new _1.PackageReference(packageRef);
        this.emit(Events.ResolveDeploy, packageRef, preset, chainId, registryName, 0);
        const uri = await this.registry.getUrl(packageRef, chainId);
        if (!uri)
            return null;
        const deployInfo = await this.readBlob(uri);
        return deployInfo;
    }
    async putDeploy(deployInfo) {
        return this.putBlob(deployInfo);
    }
}
exports.CannonStorage = CannonStorage;
const parseGasValue = (value) => {
    if (!value)
        return undefined;
    return viem.parseGwei(value).toString();
};
class ChainBuilderRuntime extends CannonStorage {
    constructor(info, registry, loaders = { ipfs: new loader_1.IPFSLoader('') }, defaultLoaderScheme = 'ipfs') {
        super(registry, loaders, defaultLoaderScheme);
        this.signals = { cancelled: false };
        this.loadedMisc = null;
        if (!loaders[defaultLoaderScheme]) {
            throw new Error('default loader scheme not provided as a loader');
        }
        this.provider = info.provider;
        this.chainId = info.chainId;
        this.getSigner = info.getSigner;
        this.getDefaultSigner =
            info.getDefaultSigner || lodash_1.default.partial(util_1.getExecutionSigner, this.provider);
        this.getArtifact = async (n) => {
            debug(`resolve artifact ${n}`);
            if (info.getArtifact) {
                debug('need to find artifact externally');
                this.reportContractArtifact(n, lodash_1.default.cloneDeep(await info.getArtifact(n)));
            }
            return this.misc.artifacts[n] || null;
        };
        this.snapshots = info.snapshots;
        this.allowPartialDeploy = info.allowPartialDeploy;
        this.misc = { artifacts: {} };
        if (info.priorityGasFee) {
            if (!info.gasFee) {
                throw new Error('priorityGasFee requires gasFee');
            }
        }
        this._gasFee = parseGasValue(info.gasFee);
        this._priorityGasFee = parseGasValue(info.priorityGasFee);
        if (info.gasPrice) {
            if (info.gasFee) {
                debug((0, chalk_1.yellow)('WARNING: gasPrice is ignored when gasFee is set'));
            }
            else {
                this._gasPrice = parseGasValue(info.gasPrice);
            }
        }
    }
    cancel() {
        this.signals.cancelled = true;
    }
    get gasPrice() {
        return this._gasPrice;
    }
    get gasFee() {
        return this._gasFee;
    }
    get priorityGasFee() {
        return this._priorityGasFee;
    }
    isCancelled() {
        return this.signals.cancelled;
    }
    async checkNetwork() {
        const chainId = await this.provider.getChainId();
        if (chainId !== this.chainId) {
            throw new Error(`provider network reported chainId (${chainId}) does not match configured deployment chain id (${this.chainId})`);
        }
    }
    async loadState(stateDump) {
        if (this.snapshots) {
            debug('load state', stateDump.length);
            await this.provider.loadState({ state: stateDump });
            // after loading state, sometimes block cannot be found during waitForTransactionReceipt check. So just mine a block to ensure it exists
            await this.provider.mine({ blocks: 1 });
        }
    }
    async dumpState() {
        if (this.snapshots) {
            debug('dump state');
            return await this.provider.dumpState();
        }
        return null;
    }
    async clearNode() {
        if (this.snapshots) {
            debug('clear node');
            // revert is assumed hardcoded to the beginning chainstate on a clearable node
            if (this.cleanSnapshot) {
                await this.provider.revert({ id: this.cleanSnapshot });
            }
            this.cleanSnapshot = await this.provider.snapshot();
        }
    }
    async recordMisc() {
        return await this.loaders[this.defaultLoaderScheme].put(this.misc);
    }
    async restoreMisc(url) {
        if (url === this.loadedMisc) {
            return;
        }
        this.misc = await this.readBlob(url);
        this.loadedMisc = url;
    }
    reportContractArtifact(n, artifact) {
        if (!this.publicSourceCode) {
            delete artifact.source;
        }
        debug('reported contract artifact', n, artifact);
        this.misc.artifacts[n] = artifact;
    }
    updateProviderArtifacts(artifacts) {
        this.provider = this.provider.extend((0, error_1.traceActions)(artifacts));
    }
    setPublicSourceCode(isPublic) {
        this.publicSourceCode = isPublic;
    }
    derive(overrides) {
        const newRuntime = new ChainBuilderRuntime({ ...this, ...overrides }, this.registry, this.loaders, this.defaultLoaderScheme);
        newRuntime.signals = this.signals;
        if (!overrides.gasPrice)
            newRuntime._gasPrice = this.gasPrice;
        if (!overrides.gasFee)
            newRuntime._gasFee = this.gasFee;
        if (!overrides.priorityGasFee)
            newRuntime._priorityGasFee = this.priorityGasFee;
        // forward any events which come from our child
        newRuntime.on(Events.PreStepExecute, (t, n, c, d) => this.emit(Events.PreStepExecute, t, n, c, d + 1));
        newRuntime.on(Events.PostStepExecute, (t, n, cfg, ctx, result, d) => this.emit(Events.PostStepExecute, t, n, cfg, ctx, result, d + 1));
        newRuntime.on(Events.DeployContract, (n, c, d) => this.emit(Events.DeployContract, n, c, d + 1));
        newRuntime.on(Events.DeployTxn, (n, t, d) => this.emit(Events.DeployTxn, n, t, d + 1));
        newRuntime.on(Events.DeployExtra, (n, v, d) => this.emit(Events.DeployExtra, n, v, d + 1));
        newRuntime.on(Events.SkipDeploy, (n, e, d) => this.emit(Events.SkipDeploy, n, e, d + 1));
        newRuntime.on(Events.ResolveDeploy, (packageName, preset, chainId, registry, d) => this.emit(Events.ResolveDeploy, packageName, preset, chainId, registry, d + 1));
        newRuntime.on(Events.DownloadDeploy, (hash, gateway, d) => this.emit(Events.DownloadDeploy, hash, gateway, d + 1));
        return newRuntime;
    }
}
exports.ChainBuilderRuntime = ChainBuilderRuntime;
//# sourceMappingURL=runtime.js.map
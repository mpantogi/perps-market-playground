import * as viem from 'viem';
import { ChainDefinition } from '.';
import { ChainDefinitionProblems } from './definition';
import { ChainArtifacts, CannonSigner, Contract } from './types';
/**
 * Used as the `getDefaultSigner` implementation if none is specified to the chain builder. Creates a new
 * usable signer on the fly and attempts to populate it with hardhat functions `impersonateAccount`.
 * This will fail if running on a live network, so be sure to set your own `getDefaultSigner` if that
 * situation applies to you.
 * @param provider the provider set on the chain builder
 * @param txn the transaction that is to be executed
 * @param seed additional text which can be used to execute the same transaction with different addresses
 * @returns ethers signer
 */
export declare function getExecutionSigner(provider: viem.TestClient, txn: Omit<viem.SendTransactionParameters, 'account' | 'chain'>, salt?: string): Promise<CannonSigner>;
export declare function passThroughSigner(getSigner: (addr: string) => Promise<CannonSigner | null>, addr: string): Promise<CannonSigner>;
export declare function getContractDefinitionFromPath(ctx: ChainArtifacts, path: string): import("./types").ContractData | null;
export declare function getMergedAbiFromContractPaths(ctx: ChainArtifacts, paths: string[]): any[];
export declare function getContractFromPath(ctx: ChainArtifacts, path: string): Contract | null;
export declare function getAllContractPaths(ctx: ChainArtifacts): string[];
export declare function printInternalOutputs(outputs: ChainArtifacts): string[];
export declare function printChainDefinitionProblems(problems: ChainDefinitionProblems, def?: ChainDefinition): string[];
export declare function encodeDeployData(...args: Parameters<typeof viem.encodeDeployData>): `0x${string}`;
//# sourceMappingURL=util.d.ts.map
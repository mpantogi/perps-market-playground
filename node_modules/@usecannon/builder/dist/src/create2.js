"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeArachnidCreate2Txn = exports.ensureArachnidCreate2Exists = exports.ARACHNID_DEPLOY_TXN = exports.ARACHNID_DEFAULT_DEPLOY_ADDR = void 0;
const debug_1 = __importDefault(require("debug"));
const viem = __importStar(require("viem"));
const debug = (0, debug_1.default)('cannon:builder:create2');
exports.ARACHNID_DEFAULT_DEPLOY_ADDR = '0x3fab184622dc19b6109349b94811493bf2a45362';
exports.ARACHNID_DEPLOY_TXN = '0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222';
/**
 * If arachnid create2 proxy is not already deployed, this function can deploy it.
 * @param runtime the runtime which can be used to deploy
 */
async function ensureArachnidCreate2Exists(runtime, deployer) {
    // if arachnid create2 contract is not deployed
    const proxyAddress = viem.getCreateAddress({ from: deployer, nonce: BigInt(0) });
    const detectedBytecode = await runtime.provider.getBytecode({ address: proxyAddress });
    if (!detectedBytecode || detectedBytecode === '0x') {
        debug('arachnid create2 contract not found. attempting to deploy...');
        // on local testnets the arachnid contract is not deployed,
        // but we can deploy it easily
        // first "get" the signer (which will populate it for use and with enough eth for gas)
        // if signer doesn't exist then this isnt local testing network, and this txn will fail
        let signer;
        try {
            signer = await runtime.getSigner(deployer);
        }
        catch (err) {
            debug('got arachnid signer error', err);
            throw new Error('could not populate arachnid signer address. ' +
                'This most likely means you are trying to deploy to a non-local network, but the arachnid create2 contract has not been deployed. ' +
                'Please follow the instructions to deploy arachnid create2.');
        }
        // now run the presigned deployment txn
        const hash = await signer.wallet.sendTransaction({
            account: signer.address,
            chain: runtime.provider.chain,
            data: '0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3',
        });
        await runtime.provider.waitForTransactionReceipt({ hash });
    }
    return proxyAddress;
}
exports.ensureArachnidCreate2Exists = ensureArachnidCreate2Exists;
/**
 * Returns the address generated by a CREATE2 call using the arachnid proxy
 */
function makeArachnidCreate2Txn(salt, initcode, arachnidAddress) {
    const saltHash = !viem.isHash(salt) ? viem.keccak256(viem.toBytes(salt)) : salt;
    const txn = {
        to: arachnidAddress,
        data: viem.concatHex([saltHash, initcode]),
    };
    const contractAddress = viem.getCreate2Address({ bytecode: initcode, salt: saltHash, from: arachnidAddress });
    // viem.getAddress will uppercase the address properly for checksum purposes
    return [txn, viem.getAddress(contractAddress)];
}
exports.makeArachnidCreate2Txn = makeArachnidCreate2Txn;
//# sourceMappingURL=create2.js.map
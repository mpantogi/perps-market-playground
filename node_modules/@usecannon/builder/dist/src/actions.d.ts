import { z } from 'zod';
import { ChainBuilderRuntime } from './runtime';
import { chainDefinitionSchema } from './schemas';
import { ChainArtifacts, ChainBuilderContext, ChainBuilderContextWithHelpers, PackageState } from './types';
import { AccessComputationResult } from './access-recorder';
export interface CannonAction {
    label: string;
    configInject: (ctx: ChainBuilderContextWithHelpers, config: any, packageState: PackageState) => any;
    getState: (runtime: ChainBuilderRuntime, ctx: ChainBuilderContextWithHelpers, config: any, packageState: PackageState) => Promise<any[] | null>;
    /**
     * Returns a list of state keys that this operation consumes (used for dependency inference)
     */
    getInputs?: (config: any, possibleFields: string[], packageState: PackageState) => AccessComputationResult;
    /**
     * Returns a list of state keys this operation produces (used for dependency inference)
     */
    getOutputs?: (config: any, packageState: PackageState) => string[];
    exec: (runtime: ChainBuilderRuntime, ctx: ChainBuilderContext, config: any, packageState: PackageState) => Promise<ChainArtifacts>;
    importExisting?: (runtime: ChainBuilderRuntime, ctx: ChainBuilderContext, config: any, packageState: PackageState, existingKeys: string[]) => Promise<ChainArtifacts>;
    validate: z.ZodSchema;
    timeout?: number;
}
/**
 * @internal
 * All the different types (and their implementations)
 */
export declare const ActionKinds: {
    [label: string]: CannonAction;
};
/**
 *  Available properties for top level config
 *  @public
 *  @group Base Cannonfile Config

 */
export type RawChainDefinition = z.infer<typeof chainDefinitionSchema>;
/**
 *  @internal
 *  parses the schema and performs zod validations safely with a custom error handler
 */
export declare function validateConfig(schema: z.ZodSchema, config: any): z.SafeParseReturnType<any, any>;
export declare function registerAction(action: CannonAction): void;
//# sourceMappingURL=actions.d.ts.map
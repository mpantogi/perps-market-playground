"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeDeployData = exports.printChainDefinitionProblems = exports.printInternalOutputs = exports.getAllContractPaths = exports.getContractFromPath = exports.getMergedAbiFromContractPaths = exports.getContractDefinitionFromPath = exports.passThroughSigner = exports.getExecutionSigner = void 0;
const crypto_1 = __importDefault(require("crypto"));
const viem = __importStar(require("viem"));
const buffer_1 = require("buffer");
const lodash_1 = __importDefault(require("lodash"));
/**
 * Used as the `getDefaultSigner` implementation if none is specified to the chain builder. Creates a new
 * usable signer on the fly and attempts to populate it with hardhat functions `impersonateAccount`.
 * This will fail if running on a live network, so be sure to set your own `getDefaultSigner` if that
 * situation applies to you.
 * @param provider the provider set on the chain builder
 * @param txn the transaction that is to be executed
 * @param seed additional text which can be used to execute the same transaction with different addresses
 * @returns ethers signer
 */
async function getExecutionSigner(provider, txn, salt = '') {
    const hasher = crypto_1.default.createHash('sha256');
    // create a hashable string out of relevant properties
    const seed = (txn.to || '') + txn.data + (txn.value || '') + buffer_1.Buffer.from(salt || '', 'utf8').toString('hex');
    const size = 32;
    for (let i = 0; i < seed.length; i += size) {
        hasher.update(seed.substring(i, i + size));
    }
    const hash = hasher.digest('hex');
    const address = ('0x' + hash.slice(0, 40));
    await provider.impersonateAccount({ address });
    await provider.setBalance({ address, value: viem.parseEther('10000') });
    const client = viem.createWalletClient({
        account: address,
        chain: provider.chain,
        transport: viem.custom(provider.transport),
    });
    return { wallet: client, address };
}
exports.getExecutionSigner = getExecutionSigner;
async function passThroughSigner(getSigner, addr) {
    const signer = await getSigner(addr);
    if (!signer) {
        throw new Error(`signer not provided for address ${addr}

This error occurs because your cannonfile is requesting to sign a transaction, but the corresponding signer has not been made
available in your configuration. Please double check your configuration & integrations and try again.`);
    }
    return signer;
}
exports.passThroughSigner = passThroughSigner;
function getContractDefinitionFromPath(ctx, path) {
    const pathPieces = path.split('.');
    let importsBase = ctx;
    for (const p of pathPieces.slice(0, -1)) {
        importsBase = importsBase.imports[p];
    }
    const c = importsBase?.contracts?.[pathPieces[pathPieces.length - 1]];
    return c || null;
}
exports.getContractDefinitionFromPath = getContractDefinitionFromPath;
function getMergedAbiFromContractPaths(ctx, paths) {
    return paths
        .flatMap((contractPath) => {
        const c = getContractDefinitionFromPath(ctx, contractPath);
        if (!c) {
            throw new Error(`previously deployed contract with identifier "${contractPath}" for factory not found`);
        }
        if (!Array.isArray(c.abi)) {
            throw new Error(`Contract definition for "${contractPath}" does not have a valid abi`);
        }
        return c.abi;
    })
        .filter((a, index, abi) => {
        if (index === 0)
            return true;
        const alreadyExists = abi.slice(0, index).some((b) => {
            return lodash_1.default.isEqual(a, b);
        });
        return !alreadyExists;
    });
}
exports.getMergedAbiFromContractPaths = getMergedAbiFromContractPaths;
function getContractFromPath(ctx, path) {
    const contract = getContractDefinitionFromPath(ctx, path);
    if (contract) {
        return { address: contract.address, abi: contract.abi };
    }
    return null;
}
exports.getContractFromPath = getContractFromPath;
function getAllContractPaths(ctx) {
    return [
        ...Object.keys(ctx.contracts || {}),
        ...lodash_1.default.sortBy(lodash_1.default.flatMap(ctx.imports, (v, k) => getAllContractPaths(v).map((c) => `${k}.${c}`))),
    ];
}
exports.getAllContractPaths = getAllContractPaths;
function printInternalOutputs(outputs) {
    const str = [];
    for (const c in outputs.contracts) {
        str.push(`deployed\t${c} at ${outputs.contracts[c].address} (${outputs.contracts[c].deployTxnHash})`);
    }
    for (const t in outputs.txns) {
        const txn = outputs.txns[t];
        str.push(`execed\t${t} (${txn.hash})`);
        // decode events
        for (const n in txn.events) {
            for (const e of txn.events[n]) {
                str.push(`\t-> ${n}(${e.args.map((s) => s.toString()).join(',')})`);
            }
        }
        str.push('');
    }
    return str;
}
exports.printInternalOutputs = printInternalOutputs;
function printChainDefinitionProblems(problems, def) {
    let counter = 1;
    const str = [];
    for (const missing of problems.missing) {
        str.push(`${counter}: In operation "${missing.action}", the dependency "${missing.dependency}" is not defined elsewhere.`);
        counter++;
    }
    if (problems.missing.length && def) {
        str.push(`HELP: The following is the full list of known operations:
${def.allActionNames.join('\n')}`);
    }
    for (const cycle of problems.cycles) {
        str.push(`${counter}: The operations ${cycle.join(', ')} form a dependency cycle and therefore cannot be deployed.`);
        counter++;
    }
    return str;
}
exports.printChainDefinitionProblems = printChainDefinitionProblems;
// Noticed that viem is not adding the '0x' at the beggining, contratry to what
// the docs say, so just keeping the check in case is needed in the future.
function encodeDeployData(...args) {
    const data = viem.encodeDeployData(...args);
    return data.startsWith('0x') ? data : `0x${data}`;
}
exports.encodeDeployData = encodeDeployData;
//# sourceMappingURL=util.js.map
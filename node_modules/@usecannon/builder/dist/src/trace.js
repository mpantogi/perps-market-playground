"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderResult = exports.parseContractErrorReason = exports.decodeTxError = exports.findContract = exports.parseFunctionData = exports.renderTraceEntry = exports.renderTrace = exports.CONSOLE_LOG_ADDRESS = void 0;
const consoleLog_1 = require("./consoleLog");
const viem = __importStar(require("viem"));
const viem_1 = require("viem");
const chalk_1 = require("chalk");
exports.CONSOLE_LOG_ADDRESS = '0x000000000000000000636f6e736f6c652e6c6f67';
function renderTrace(ctx, traces) {
    return traces.map((t) => renderTraceEntry(ctx, t)).join('\n');
}
exports.renderTrace = renderTrace;
function renderTraceEntry(ctx, trace) {
    let str;
    switch (trace.type) {
        case 'call':
            const callTraceAction = trace.action;
            const { contractName, parsedInput, parsedOutput } = parseFunctionData(ctx, callTraceAction.to, callTraceAction.input, trace.result?.output ?? '0x');
            const actionStr = (0, chalk_1.bold)(`${callTraceAction.callType.toUpperCase()} `);
            const gasStr = (0, chalk_1.grey)(` (${parseInt(callTraceAction.gas).toLocaleString()} gas)`);
            const txStr = (contractName || callTraceAction.to) +
                '.' +
                (parsedInput || callTraceAction.input) +
                (parsedOutput ? ' => ' + parsedOutput : '');
            str = actionStr + (contractName ? (0, chalk_1.green)(txStr) : txStr) + gasStr;
            break;
        case 'create':
            //const createTraceAction = trace.action as CreateTraceAction;
            str = 'CREATE'; // TODO: find matching bytecode
            break;
        default:
            str = `UNKNOWN ${trace.type}`;
    }
    return ' '.repeat(2 * (trace.traceAddress.length + 1)) + str;
}
exports.renderTraceEntry = renderTraceEntry;
function parseFunctionData(ctx, contractAddress, input, output) {
    let parsedInput, parsedOutput;
    let contractName = '';
    let isReverted = false;
    // input
    if (contractAddress.toLowerCase() == exports.CONSOLE_LOG_ADDRESS) {
        // this is the "well known" console log address
        contractName = 'console';
        parsedInput =
            'log' +
                renderResult((0, viem_1.decodeAbiParameters)(consoleLog_1.ConsoleLogs[parseInt(input.slice(0, 10))].map((v) => ({ type: v })), ('0x' + input.slice(10))));
        // console logs have no output
        parsedOutput = '';
    }
    else {
        const info = findContract(ctx, (contract) => {
            if (viem.isAddressEqual(contract.address, contractAddress)) {
                try {
                    viem.decodeFunctionData({ ...contract, data: input });
                    return true;
                }
                catch {
                    return false;
                }
            }
            return false;
        }) || findContract(ctx, ({ address }) => address.toLowerCase() === contractAddress.toLowerCase());
        if (info) {
            contractName = info.name;
            let decodedInput;
            try {
                decodedInput = viem.decodeFunctionData({ ...info.contract, data: input });
                parsedInput = decodedInput.functionName + renderResult(decodedInput.args || []);
                // its actually easier to start by trying to parse the output first
                try {
                    const abiItem = viem.getAbiItem({ ...info.contract, name: decodedInput.functionName });
                    const decodedOutput = viem.decodeFunctionResult({
                        abi: [abiItem],
                        data: output,
                    });
                    parsedOutput = renderResult(abiItem.outputs.length > 1 ? decodedOutput : [decodedOutput]);
                }
                catch (err) {
                    // if we found an address but the transaction cannot be parsed, it could be decodable error
                    try {
                        parsedOutput = (0, chalk_1.bold)((0, chalk_1.red)(parseContractErrorReason(info.contract, output)));
                        isReverted = true;
                    }
                    catch (err) {
                        parsedOutput = output;
                    }
                }
            }
            catch (err) {
                // this shouldn't happen unless the ABI is incomplete or the contract is non-conformant
                parsedInput = `<unknown function ${input.slice(0, 10)}>`;
                parsedOutput = output;
            }
        }
        else {
            parsedInput = input;
            parsedOutput = output;
        }
    }
    return {
        contractName,
        parsedInput,
        parsedOutput,
        isReverted,
    };
}
exports.parseFunctionData = parseFunctionData;
function findContract(ctx, condition, prefix = '') {
    for (const name in ctx.contracts) {
        if (condition(ctx.contracts[name])) {
            return {
                name: prefix + name,
                contract: ctx.contracts[name],
            };
        }
    }
    for (const name in ctx.imports) {
        const result = findContract(ctx.imports[name], condition, `${prefix}${name}.`);
        if (result) {
            return result;
        }
    }
    return null;
}
exports.findContract = findContract;
// TODO: viem probably makes most of this code unnecessary now
function decodeTxError(data, abis = []) {
    if (data.startsWith(viem.toFunctionSelector('Panic(uint256)'))) {
        // this is the `Panic` builtin opcode
        const reason = viem.decodeAbiParameters(viem.parseAbiParameters('uint256'), ('0x' + data.slice(10)))[0];
        switch (Number(reason)) {
            case 0x00:
                return 'Panic("generic/unknown error")';
            case 0x01:
                return 'Panic("assertion failed")';
            case 0x11:
                return 'Panic("unchecked underflow/overflow")';
            case 0x12:
                return 'Panic("division by zero")';
            case 0x21:
                return 'Panic("invalid number to enum conversion")';
            case 0x22:
                return 'Panic("access to incorrect storage byte array")';
            case 0x31:
                return 'Panic("pop() empty array")';
            case 0x32:
                return 'Panic("out of bounds array access")';
            case 0x41:
                return 'Panic("out of memory")';
            case 0x51:
                return 'Panic("invalid internal function")';
            default:
                return 'Panic("unknown")';
        }
    }
    else if (data.startsWith(viem.toFunctionSelector('Error(string)'))) {
        // this is the `Error` builtin opcode
        const reason = viem.decodeAbiParameters(viem.parseAbiParameters('string'), ('0x' + data.slice(10)));
        return `Error("${reason}")`;
    }
    for (const abi of abis) {
        try {
            const error = viem.decodeErrorResult({ data, abi });
            return error.errorName + renderResult(error.args || []);
        }
        catch (err) {
            // intentionally empty
        }
    }
    return null;
}
exports.decodeTxError = decodeTxError;
function parseContractErrorReason(contract, data) {
    const result = decodeTxError(data);
    if (result) {
        return result;
    }
    if (contract) {
        try {
            const error = viem.decodeErrorResult({ data, ...contract });
            return error.errorName + renderResult(error.args || []);
        }
        catch (err) {
            // intentionally empty
        }
    }
    return data;
}
exports.parseContractErrorReason = parseContractErrorReason;
function renderResult(result) {
    return ('(' +
        result
            .map((v) => {
            if (typeof v === 'object') {
                return JSON.stringify(v);
            }
            else {
                return v.toString ? '"' + v.toString() + '"' : v;
            }
        })
            .join(', ') +
        ')');
}
exports.renderResult = renderResult;
//# sourceMappingURL=trace.js.map
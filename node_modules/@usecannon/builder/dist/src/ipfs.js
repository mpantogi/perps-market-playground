"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchIPFSAvailability = exports.listPinsIpfs = exports.deleteIpfs = exports.writeIpfs = exports.readIpfs = exports.isIpfsGateway = exports.setAxiosRetries = exports.getContentCID = exports.uncompress = exports.compress = void 0;
const axios_1 = __importDefault(require("axios"));
const axios_retry_1 = __importDefault(require("axios-retry"));
const buffer_1 = require("buffer");
const debug_1 = __importDefault(require("debug"));
const form_data_1 = __importDefault(require("form-data"));
const pako_1 = __importDefault(require("pako"));
const typestub_ipfs_only_hash_1 = __importDefault(require("typestub-ipfs-only-hash"));
const debug = (0, debug_1.default)('cannon:builder:ipfs');
function compress(data) {
    return pako_1.default.deflate(data);
}
exports.compress = compress;
function uncompress(data) {
    return pako_1.default.inflate(data, { to: 'string' });
}
exports.uncompress = uncompress;
async function getContentCID(value) {
    return typestub_ipfs_only_hash_1.default.of(value);
}
exports.getContentCID = getContentCID;
function setAxiosRetries(totalRetries = 3) {
    (0, axios_retry_1.default)(axios_1.default, {
        retries: totalRetries,
        shouldResetTimeout: true,
        onRetry: (currentRetry, error) => {
            debug('Failed with error:', error);
            debug('Retrying...');
            if (currentRetry == totalRetries) {
                error.code = 'RETRY_ERROR';
                throw error;
            }
        },
    });
}
exports.setAxiosRetries = setAxiosRetries;
// eslint-disable-next-line
async function isIpfsGateway(ipfsUrl, _customHeaders) {
    debug(`is-gateway ${ipfsUrl} false`);
    return false;
}
exports.isIpfsGateway = isIpfsGateway;
async function readIpfs(ipfsUrl, hash, customHeaders = {}, isGateway, timeout, retries = 3) {
    debug(`downloading content from ${hash}`);
    setAxiosRetries(retries);
    let result;
    try {
        if (isGateway) {
            result = await axios_1.default.get(ipfsUrl + `/ipfs/${hash}`, {
                responseType: 'arraybuffer',
                responseEncoding: 'application/octet-stream',
                headers: customHeaders,
                timeout,
            });
        }
        else {
            // the +ipfs extension used to indicate a gateway is not recognized by
            // axios even though its just regular https
            // so we remove it if it exists
            result = await axios_1.default.post(ipfsUrl.replace('+ipfs', '') + `/api/v0/cat?arg=${hash}`, {}, {
                responseEncoding: 'application/octet-stream',
                responseType: 'arraybuffer',
                headers: customHeaders,
                timeout,
            });
        }
    }
    catch (err) {
        let errMsg = `could not download cannon package data from "${hash}": ${err.toString()}`;
        if (ipfsUrl.includes('infura')) {
            errMsg +=
                '\n\nNOTE: it appears you are using infura for IPFS. Please note that infura tends to be problematic when downloading IPFS artifacts outside of infura itself. Please consider using a different IPFS service.';
        }
        throw new Error(errMsg);
    }
    try {
        return JSON.parse(uncompress(result.data));
    }
    catch (err) {
        throw new Error(`could not decode cannon package data: ${err.toString()}`);
    }
}
exports.readIpfs = readIpfs;
async function writeIpfs(ipfsUrl, info, customHeaders = {}, isGateway, timeout, retries = 3) {
    setAxiosRetries(retries);
    const data = JSON.stringify(info);
    const buf = compress(data);
    const cid = await getContentCID(buffer_1.Buffer.from(buf));
    if (isGateway) {
        throw new Error('unable to upload to ipfs: the IPFS url you have configured is either read-only (ie a gateway), or invalid. please double check your configuration.');
    }
    debug('upload to ipfs:', buf.length, buffer_1.Buffer.from(buf).length);
    const formData = new form_data_1.default();
    // This check is needed for proper functionality in the browser, as the Buffer is not correctly concatenated
    // But, for node we still wanna keep using Buffer
    const content = typeof window !== 'undefined' && typeof Blob !== 'undefined' ? new Blob([buf]) : buffer_1.Buffer.from(buf);
    formData.append('data', content);
    let result;
    try {
        result = await axios_1.default.post(ipfsUrl.replace('+ipfs', '') + '/api/v0/add?local=true&to-files=%2F' + cid, formData, {
            headers: customHeaders,
            timeout,
        });
    }
    catch (err) {
        throw new Error('Failed to upload to IPFS. Make sure you have a local IPFS daemon running and run `cannon setup` to confirm your configuration is set properly. ' +
            err);
    }
    debug('upload', result.statusText, result.data.Hash);
    if (cid !== result.data.Hash) {
        throw new Error('Invalid CID generated locally');
    }
    return cid;
}
exports.writeIpfs = writeIpfs;
async function deleteIpfs(ipfsUrl, hash, customHeaders = {}, isGateway, timeout) {
    if (isGateway) {
        // cannot write to IPFS on gateway
        throw new Error('Cannot delete from IPFS gateway');
    }
    debug('delete from ipfs:', hash);
    try {
        await axios_1.default.post(ipfsUrl.replace('+ipfs', '') + '/api/v0/pin/rm?arg=' + hash, {}, { headers: customHeaders, timeout });
    }
    catch (err) {
        throw new Error('Failed to delete from IPFS. ' + err);
    }
}
exports.deleteIpfs = deleteIpfs;
async function listPinsIpfs(ipfsUrl, customHeaders = {}, isGateway) {
    if (isGateway) {
        throw new Error('Cannot list pinned IPFS files on a gateway endpoint');
    }
    debug('list ipfs pins');
    try {
        const result = await axios_1.default.post(ipfsUrl.replace('+ipfs', '') + '/api/v0/pin/ls', { headers: customHeaders });
        return Object.keys(result.data.Keys).map((key) => 'ipfs://' + key);
    }
    catch (err) {
        throw new Error('Failed to list ipfs artifacts' + err);
    }
}
exports.listPinsIpfs = listPinsIpfs;
async function isIPFSRunningLocally(ipfsUrl) {
    try {
        const response = await axios_1.default.post(`${ipfsUrl}/api/v0/id`, {}, { timeout: 2000 });
        if (response.status === 200)
            return true;
    }
    catch (error) {
        return false;
    }
    return false;
}
async function getIPFSAvailabilityScoreLocally(ipfsUrl, cid) {
    try {
        const response = await axios_1.default.post(`${ipfsUrl}/api/v0/dht/findprovs?arg=${cid}`, {}, { timeout: 2000 });
        const lines = response.data.split('\n').filter(Boolean);
        let total = 0;
        for (const line of lines) {
            const obj = JSON.parse(line);
            if (obj.Type === 4 && Array.isArray(obj.Responses)) {
                total += obj.Responses.length;
            }
        }
        return total;
    }
    catch (error) {
        return 0;
    }
}
async function fetchIPFSAvailability(ipfsUrl, cid) {
    if (!ipfsUrl) {
        return undefined;
    }
    if (await isIPFSRunningLocally(ipfsUrl)) {
        const score = await getIPFSAvailabilityScoreLocally(ipfsUrl, cid);
        return score;
    }
    else {
        debug('local ipfs unavailable, returning null for ipfs availability. Cannot fetch availability score.');
        return undefined;
    }
}
exports.fetchIPFSAvailability = fetchIPFSAvailability;
//# sourceMappingURL=ipfs.js.map
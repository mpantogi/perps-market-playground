"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const lodash_1 = __importDefault(require("lodash"));
const viem = __importStar(require("viem"));
const access_recorder_1 = require("../access-recorder");
const schemas_1 = require("../schemas");
const create2_1 = require("../create2");
const util_1 = require("../util");
const error_1 = require("../error");
const debug = (0, debug_1.default)('cannon:builder:contract');
function resolveBytecode(artifactData, config) {
    let injectedBytecode = artifactData.bytecode;
    const linkedLibraries = {};
    for (const file in artifactData.linkReferences) {
        for (const lib in artifactData.linkReferences[file]) {
            // get the lib from the config
            const libraryAddress = lodash_1.default.get(config, `libraries.${lib}`);
            if (!libraryAddress) {
                throw new Error(`library not defined: ${lib}`);
            }
            debug('lib ref', lib, libraryAddress);
            // afterwards, inject link references
            const linkReferences = artifactData.linkReferences[file][lib];
            for (const ref of linkReferences) {
                injectedBytecode = (injectedBytecode.substring(0, 2 + ref.start * 2) +
                    libraryAddress.substring(2) +
                    injectedBytecode.substring(2 + (ref.start + ref.length) * 2));
                lodash_1.default.set(linkedLibraries, [file, lib], libraryAddress);
            }
        }
    }
    return [injectedBytecode, linkedLibraries];
}
function generateOutputs(config, ctx, artifactData, deployTxn, deployAddress, currentLabel) {
    const [, linkedLibraries] = resolveBytecode(artifactData, config);
    let abi = artifactData.abi;
    // override abi?
    if (config.abi) {
        if (config.abi.trimStart().startsWith('[')) {
            // Allow to pass in a literal abi string
            abi = JSON.parse(config.abi);
        }
        else {
            // Load the abi from another contract
            const implContract = (0, util_1.getContractDefinitionFromPath)(ctx, config.abi);
            if (!implContract) {
                throw new Error(`previously deployed contract with name ${config.abi} for abi not found`);
            }
            abi = implContract.abi;
        }
    }
    else if (config.abiOf) {
        abi = (0, util_1.getMergedAbiFromContractPaths)(ctx, config.abiOf);
    }
    return {
        contracts: {
            [currentLabel.split('.')[1] || '']: {
                address: viem.getAddress(deployAddress),
                abi,
                constructorArgs: config.args || [],
                linkedLibraries,
                deployTxnHash: deployTxn?.transactionHash || '',
                sourceName: artifactData.sourceName,
                contractName: artifactData.contractName,
                deployedOn: currentLabel,
                highlight: config.highlight,
                gasUsed: Number(deployTxn?.gasUsed) || 0,
                gasCost: deployTxn?.effectiveGasPrice.toString() || '0',
            },
        },
    };
}
// ensure the specified contract is already deployed
// if not deployed, deploy the specified hardhat contract with specfied options, export address, abi, etc.
// if already deployed, reexport deployment options for usage downstream and exit with no changes
const deploySpec = {
    label: 'deploy',
    validate: lodash_1.default.cloneDeep(schemas_1.deploySchema),
    async getState(runtime, ctx, config) {
        const parsedConfig = this.configInject(ctx, config);
        return [
            {
                bytecode: resolveBytecode(await runtime.getArtifact(parsedConfig.artifact), parsedConfig)[0],
                args: parsedConfig.args?.map((v) => (typeof v === 'string' ? v : JSON.stringify(v))) || [],
                salt: parsedConfig.salt,
                value: parsedConfig.value || [],
            },
        ];
    },
    configInject(ctx, config) {
        config = lodash_1.default.cloneDeep(config);
        config.from = lodash_1.default.template(config.from)(ctx);
        config.nonce = lodash_1.default.template(config.nonce)(ctx);
        config.artifact = lodash_1.default.template(config.artifact)(ctx);
        config.value = lodash_1.default.template(config.value)(ctx);
        config.abi = lodash_1.default.template(config.abi)(ctx);
        if (config.abiOf) {
            config.abiOf = lodash_1.default.map(config.abiOf, (v) => lodash_1.default.template(v)(ctx));
        }
        if (config.args) {
            config.args = lodash_1.default.map(config.args, (a) => {
                // just convert it to a JSON string when. This will allow parsing of complicated nested structures
                return JSON.parse(lodash_1.default.template(JSON.stringify(a))(ctx));
            });
        }
        if (config.libraries) {
            config.libraries = lodash_1.default.mapValues(config.libraries, (a) => {
                return lodash_1.default.template(a)(ctx);
            });
        }
        if (config.salt) {
            config.salt = lodash_1.default.template(config.salt)(ctx);
        }
        if (config?.overrides?.gasLimit) {
            config.overrides.gasLimit = lodash_1.default.template(config.overrides.gasLimit)(ctx);
        }
        return config;
    },
    getInputs(config, possibleFields) {
        let accesses = (0, access_recorder_1.computeTemplateAccesses)(config.from);
        accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(config.nonce, possibleFields));
        accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(config.artifact, possibleFields));
        accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(config.value, possibleFields));
        accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(config.abi, possibleFields));
        accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(config.salt, possibleFields));
        if (config.abiOf) {
            lodash_1.default.forEach(config.abiOf, (v) => (accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(v, possibleFields))));
        }
        if (config.args) {
            lodash_1.default.forEach(config.args, (v) => (accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(JSON.stringify(v), possibleFields))));
        }
        if (config.libraries) {
            lodash_1.default.forEach(config.libraries, (v) => (accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(v, possibleFields))));
        }
        if (config?.overrides?.gasLimit) {
            accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(config.overrides.gasLimit, possibleFields));
        }
        return accesses;
    },
    getOutputs(_, packageState) {
        return [`contracts.${packageState.currentLabel.split('.')[1]}`, `${packageState.currentLabel.split('.')[1]}`];
    },
    async exec(runtime, ctx, config, packageState) {
        debug('exec', config);
        // sanity check that any connected libraries are bytecoded
        for (const lib in config.libraries || {}) {
            if ((await runtime.provider.getBytecode({ address: config.libraries[lib] })) === '0x') {
                throw new Error(`library ${lib} has no bytecode. This is most likely a missing dependency or bad state.`);
            }
        }
        const artifactData = await runtime.getArtifact(config.artifact);
        if (!artifactData) {
            throw new Error(`bytecode/abi for artifact ${config.artifact} not found. please double check the contract name and your build configuration`);
        }
        const [injectedBytecode] = resolveBytecode(artifactData, config);
        // finally, deploy
        const txn = {
            data: (0, util_1.encodeDeployData)({
                abi: artifactData.abi,
                bytecode: injectedBytecode,
                args: config.args || [],
            }),
        };
        const overrides = {}; // TODO
        if (config.overrides?.gasLimit) {
            overrides.gasLimit = config.overrides.gasLimit;
        }
        if (runtime.gasPrice) {
            overrides.gasPrice = runtime.gasPrice;
        }
        if (runtime.gasFee) {
            overrides.maxFeePerGas = runtime.gasFee;
        }
        if (runtime.priorityGasFee) {
            overrides.maxPriorityFeePerGas = runtime.priorityGasFee;
        }
        let receipt = null;
        let deployAddress;
        try {
            if (config.create2) {
                const arachnidDeployerAddress = await (0, create2_1.ensureArachnidCreate2Exists)(runtime, typeof config.create2 === 'string' ? config.create2 : create2_1.ARACHNID_DEFAULT_DEPLOY_ADDR);
                debug('performing arachnid create2');
                const [create2Txn, addr] = (0, create2_1.makeArachnidCreate2Txn)(config.salt || '', txn.data, arachnidDeployerAddress);
                debug(`create2: deploy ${addr} by ${arachnidDeployerAddress}`);
                const bytecode = await runtime.provider.getBytecode({ address: addr });
                if (bytecode && bytecode !== '0x') {
                    debug('create2 contract already completed');
                    // our work is done for us. unfortunately, its not easy to figure out what the transaction hash was
                }
                else {
                    const signer = config.from
                        ? await runtime.getSigner(config.from)
                        : await runtime.getDefaultSigner(txn, config.salt);
                    const fullCreate2Txn = lodash_1.default.assign(create2Txn, overrides, { account: signer.wallet.account || signer.address });
                    debug('final create2 txn', fullCreate2Txn);
                    const preparedTxn = await runtime.provider.prepareTransactionRequest(fullCreate2Txn);
                    const hash = await signer.wallet.sendTransaction(preparedTxn);
                    receipt = await runtime.provider.waitForTransactionReceipt({ hash });
                    debug('arachnid create2 complete', receipt);
                }
                deployAddress = addr;
            }
            else {
                const curAccountNonce = config.from
                    ? await runtime.provider.getTransactionCount({ address: config.from })
                    : 0;
                if (config.from && config.nonce?.length && parseInt(config.nonce) < curAccountNonce) {
                    const contractAddress = viem.getContractAddress({
                        from: config.from,
                        nonce: BigInt(config.nonce),
                    });
                    debug(`contract appears already deployed to address ${contractAddress} (nonce too high)`);
                    // check that the contract bytecode that was deployed matches the requested
                    const actualBytecode = await runtime.provider.getBytecode({ address: contractAddress });
                    // we only check the length because solidity puts non-substantial changes (ex. comments) in bytecode and that
                    // shouldn't trigger any significant change. And also this is just kind of a sanity check so just verifying the
                    // length should be sufficient
                    if (!actualBytecode || artifactData.deployedBytecode.length !== actualBytecode.length) {
                        debug('bytecode does not match up', artifactData.deployedBytecode, actualBytecode);
                        // this can happen normally. for now lets just disable it for now
                        /*throw new Error(
                        `the address at ${config.from!} should have deployed a contract at nonce ${config.nonce!} at address ${contractAddress}, but the bytecode does not match up. actual bytecode length: ${
                          (actualBytecode || '').length
                        }`
                      );*/
                    }
                    deployAddress = contractAddress;
                }
                else {
                    const signer = config.from
                        ? await runtime.getSigner(config.from)
                        : await runtime.getDefaultSigner(txn, config.salt);
                    const preparedTxn = await runtime.provider.prepareTransactionRequest(lodash_1.default.assign(txn, overrides, { account: signer.wallet.account || signer.address }));
                    const hash = await signer.wallet.sendTransaction(preparedTxn);
                    receipt = await runtime.provider.waitForTransactionReceipt({ hash });
                    deployAddress = receipt.contractAddress;
                }
            }
        }
        catch (error) {
            // we need to get the contract artifact to decode the error
            const contractArtifact = generateOutputs(config, ctx, artifactData, receipt, 
            // note: send zero address since there is no contract address
            viem.zeroAddress, packageState.currentLabel);
            return await (0, error_1.handleTxnError)(contractArtifact, runtime.provider, error);
        }
        return generateOutputs(config, ctx, artifactData, receipt, deployAddress, packageState.currentLabel);
    },
    async importExisting(runtime, ctx, config, packageState, existingKeys) {
        if (existingKeys.length != 1) {
            throw new Error('a contract can only be deployed on one transaction, so you can only supply one hash transaction to import');
        }
        const artifactData = await runtime.getArtifact(config.artifact);
        const txn = await runtime.provider.getTransactionReceipt({ hash: existingKeys[0] });
        if (!txn.contractAddress) {
            throw new Error('imported txn does not appear to deploy a contract');
        }
        return generateOutputs(config, ctx, artifactData, txn, txn.contractAddress, packageState.currentLabel);
    },
};
exports.default = deploySpec;
//# sourceMappingURL=deploy.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const lodash_1 = __importDefault(require("lodash"));
const access_recorder_1 = require("../access-recorder");
const builder_1 = require("../builder");
const definition_1 = require("../definition");
const package_1 = require("../package");
const schemas_1 = require("../schemas");
const debug = (0, debug_1.default)('cannon:builder:import');
// ensure the specified contract is already deployed
// if not deployed, deploy the specified hardhat contract with specfied options, export address, abi, etc.
// if already deployed, reexport deployment options for usage downstream and exit with no changes
const pullSpec = {
    label: 'pull',
    validate: schemas_1.pullSchema,
    async getState(runtime, ctx, config) {
        const cfg = this.configInject(ctx, config);
        const source = cfg.source;
        const chainId = cfg.chainId ?? runtime.chainId;
        debug('resolved pkg', source, chainId);
        const url = await runtime.registry.getUrl(source, chainId);
        return [
            {
                url,
            },
        ];
    },
    configInject(ctx, config) {
        config = lodash_1.default.cloneDeep(config);
        const packageRef = new package_1.PackageReference(lodash_1.default.template(config.source)(ctx));
        config.source = packageRef.fullPackageRef;
        config.preset = lodash_1.default.template(config.preset)(ctx) || packageRef.preset;
        return config;
    },
    getInputs(config, possibleFields) {
        let accesses = (0, access_recorder_1.computeTemplateAccesses)(config.source, possibleFields);
        accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(config.preset, possibleFields));
        return accesses;
    },
    getOutputs(_, packageState) {
        return [`imports.${packageState.currentLabel.split('.')[1]}`, `${packageState.currentLabel.split('.')[1]}`];
    },
    async exec(runtime, ctx, config, packageState) {
        const importLabel = packageState.currentLabel?.split('.')[1] || '';
        debug('exec', config);
        const source = config.source;
        const preset = config.preset;
        const chainId = config.chainId ?? runtime.chainId;
        // try to load the chain definition specific to this chain
        // otherwise, load the top level definition
        const deployInfo = await runtime.readDeploy(source, chainId);
        if (!deployInfo) {
            throw new Error(`deployment not found: ${source}. please make sure it exists for the cannon network and ${preset} preset.`);
        }
        if (deployInfo.status === 'partial') {
            throw new Error(`deployment status is incomplete for ${source}. cannot generate artifacts safely. please complete deployment to continue import.`);
        }
        return {
            imports: {
                [importLabel]: {
                    url: (await runtime.registry.getUrl(source, chainId)), // todo: duplication
                    ...(await (0, builder_1.getOutputs)(runtime, new definition_1.ChainDefinition(deployInfo.def), deployInfo.state)),
                },
            },
        };
    },
};
exports.default = pullSpec;
//# sourceMappingURL=pull.js.map
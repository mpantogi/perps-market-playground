"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const lodash_1 = __importDefault(require("lodash"));
const viem = __importStar(require("viem"));
const access_recorder_1 = require("../access-recorder");
const schemas_1 = require("../schemas");
const util_1 = require("../util");
const debug = (0, debug_1.default)('cannon:builder:router');
// ensure the specified contract is already deployed
// if not deployed, deploy the specified hardhat contract with specfied options, export
// address, abi, etc.
// if already deployed, reexport deployment options for usage downstream and exit with no changes
const routerStep = {
    label: 'router',
    validate: schemas_1.routerSchema,
    async getState(runtime, ctx, config) {
        const newConfig = this.configInject(ctx, config);
        const contractAbis = {};
        const contractAddresses = {};
        for (const n of newConfig.contracts) {
            const contract = (0, util_1.getContractDefinitionFromPath)(ctx, n);
            if (!contract) {
                throw new Error(`contract not found: ${n}`);
            }
            contractAbis[n] = contract.abi;
            contractAddresses[n] = contract.address;
        }
        return [
            {
                contractAbis,
                contractAddresses,
                config: newConfig,
            },
        ];
    },
    configInject(ctx, config) {
        config = lodash_1.default.cloneDeep(config);
        config.contracts = lodash_1.default.map(config.contracts, (n) => lodash_1.default.template(n)(ctx));
        if (config.from) {
            config.from = lodash_1.default.template(config.from)(ctx);
        }
        if (config.salt) {
            config.salt = lodash_1.default.template(config.salt)(ctx);
        }
        return config;
    },
    getInputs(config, possibleFields) {
        let accesses = (0, access_recorder_1.computeTemplateAccesses)(config.from);
        accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(config.salt, possibleFields));
        accesses.accesses.push(...config.contracts.map((c) => (c.includes('.') ? `imports.${c.split('.')[0]}` : `contracts.${c}`)));
        return accesses;
    },
    getOutputs(_, packageState) {
        return [`contracts.${packageState.currentLabel.split('.')[1]}`, `${packageState.currentLabel.split('.')[1]}`];
    },
    async exec(runtime, ctx, config, packageState) {
        const { generateRouter, getCompileInput, compileContract } = await Promise.resolve().then(() => __importStar(require('@synthetixio/router')));
        debug('exec', config);
        const contracts = config.contracts.map((n) => {
            const contract = (0, util_1.getContractDefinitionFromPath)(ctx, n);
            if (!contract) {
                throw new Error(`contract not found: ${n}`);
            }
            return {
                constructorArgs: contract.constructorArgs,
                abi: contract.abi,
                deployedAddress: contract.address ? viem.getAddress(contract.address) : contract.address, // Make sure address is checksum encoded
                deployTxnHash: contract.deployTxnHash,
                contractName: contract.contractName,
                sourceName: contract.sourceName,
                contractFullyQualifiedName: `${contract.sourceName}:${contract.contractName}`,
            };
        });
        const contractName = packageState.currentLabel.slice('router.'.length);
        const sourceCode = generateRouter({
            contractName,
            contracts: contracts,
            canReceivePlainETH: config.includeReceive,
        });
        debug('router source code', sourceCode);
        // On Mainnet, use default local solc evmVersion, for everything else, 'paris'
        const evmVersion = [1, 5, 11155111].includes(runtime.chainId) ? undefined : 'paris';
        const inputData = getCompileInput(contractName, sourceCode, evmVersion);
        const solidityInfo = await compileContract(contractName, sourceCode, evmVersion);
        // the abi is entirely basedon the fallback call so we have to generate ABI here
        const routableAbi = (0, util_1.getMergedAbiFromContractPaths)(ctx, config.contracts);
        runtime.reportContractArtifact(`${contractName}.sol:${contractName}`, {
            contractName,
            sourceName: `${contractName}.sol`,
            abi: routableAbi,
            bytecode: solidityInfo.bytecode,
            deployedBytecode: solidityInfo.deployedBytecode,
            linkReferences: {},
            source: {
                solcVersion: solidityInfo.solcVersion,
                input: JSON.stringify(inputData),
            },
        });
        const signer = config.from
            ? await runtime.getSigner(config.from)
            : await runtime.getDefaultSigner({ data: solidityInfo.bytecode }, config.salt);
        debug('using deploy signer with address', signer.address);
        const preparedTxn = await signer.wallet.prepareTransactionRequest({
            account: signer.wallet.account || signer.address,
            data: (0, util_1.encodeDeployData)({
                abi: solidityInfo.abi,
                bytecode: solidityInfo.bytecode,
            }),
            chain: undefined,
        });
        const hash = await signer.wallet.sendTransaction(preparedTxn);
        const receipt = await runtime.provider.waitForTransactionReceipt({ hash });
        return {
            contracts: {
                [contractName]: {
                    address: receipt.contractAddress,
                    abi: routableAbi,
                    deployedOn: packageState.currentLabel,
                    deployTxnHash: receipt.transactionHash,
                    contractName,
                    sourceName: contractName + '.sol',
                    gasUsed: Number(receipt.gasUsed),
                    gasCost: receipt.effectiveGasPrice.toString(),
                },
            },
        };
    },
};
exports.default = routerStep;
//# sourceMappingURL=router.js.map
import { z } from 'zod';
import { deploySchema } from '../schemas';
import { ChainArtifacts, ChainBuilderContext, ChainBuilderContextWithHelpers, ChainBuilderRuntimeInfo, PackageState } from '../types';
/**
 *  Available properties for contract operation
 *  @public
 *  @group Contract
 */
export type Config = z.infer<typeof deploySchema>;
export interface ContractOutputs {
    abi: string;
    address: string;
    deployTxnHash: string;
}
declare const deploySpec: {
    label: string;
    validate: z.ZodObject<z.objectUtil.extendShape<{
        artifact: z.ZodEffects<z.ZodString, string, string>;
    }, {
        highlight: z.ZodOptional<z.ZodBoolean>;
        create2: z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodEffects<z.ZodString, string, string>]>>;
        from: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        nonce: z.ZodOptional<z.ZodEffects<z.ZodEffects<z.ZodUnion<[z.ZodString, z.ZodNumber]>, string | number, string | number>, string, string | number>>;
        abi: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        abiOf: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
        args: z.ZodOptional<z.ZodArray<z.ZodLazy<any>, "many">>;
        libraries: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
        salt: z.ZodOptional<z.ZodString>;
        value: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        overrides: z.ZodOptional<z.ZodObject<{
            gasLimit: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            gasLimit?: string | undefined;
        }, {
            gasLimit?: string | undefined;
        }>>;
        depends: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
    }>, "strip", z.ZodTypeAny, {
        artifact: string;
        value?: string | undefined;
        highlight?: boolean | undefined;
        create2?: string | boolean | undefined;
        from?: string | undefined;
        nonce?: string | undefined;
        abi?: string | undefined;
        abiOf?: string[] | undefined;
        args?: any[] | undefined;
        libraries?: Record<string, string> | undefined;
        salt?: string | undefined;
        overrides?: {
            gasLimit?: string | undefined;
        } | undefined;
        depends?: string[] | undefined;
    }, {
        artifact: string;
        value?: string | undefined;
        highlight?: boolean | undefined;
        create2?: string | boolean | undefined;
        from?: string | undefined;
        nonce?: string | number | undefined;
        abi?: string | undefined;
        abiOf?: string[] | undefined;
        args?: any[] | undefined;
        libraries?: Record<string, string> | undefined;
        salt?: string | undefined;
        overrides?: {
            gasLimit?: string | undefined;
        } | undefined;
        depends?: string[] | undefined;
    }>;
    getState(runtime: ChainBuilderRuntimeInfo, ctx: ChainBuilderContextWithHelpers, config: Config): Promise<{
        bytecode: `0x${string}`;
        args: string[];
        salt: string | undefined;
        value: string | never[];
    }[]>;
    configInject(ctx: ChainBuilderContextWithHelpers, config: Config): {
        artifact: string;
        value?: string | undefined;
        highlight?: boolean | undefined;
        create2?: string | boolean | undefined;
        from?: string | undefined;
        nonce?: string | undefined;
        abi?: string | undefined;
        abiOf?: string[] | undefined;
        args?: any[] | undefined;
        libraries?: Record<string, string> | undefined;
        salt?: string | undefined;
        overrides?: {
            gasLimit?: string | undefined;
        } | undefined;
        depends?: string[] | undefined;
    };
    getInputs(config: Config, possibleFields: string[]): import("../access-recorder").AccessComputationResult;
    getOutputs(_: Config, packageState: PackageState): string[];
    exec(runtime: ChainBuilderRuntimeInfo, ctx: ChainBuilderContext, config: Config, packageState: PackageState): Promise<ChainArtifacts>;
    importExisting(runtime: ChainBuilderRuntimeInfo, ctx: ChainBuilderContext, config: Config, packageState: PackageState, existingKeys: string[]): Promise<ChainArtifacts>;
};
export default deploySpec;
//# sourceMappingURL=deploy.d.ts.map
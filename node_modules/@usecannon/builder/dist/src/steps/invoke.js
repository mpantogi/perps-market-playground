"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatAbiFunction = void 0;
const debug_1 = __importDefault(require("debug"));
const viem = __importStar(require("viem"));
const lodash_1 = __importDefault(require("lodash"));
const access_recorder_1 = require("../access-recorder");
const schemas_1 = require("../schemas");
const util_1 = require("../util");
const debug = (0, debug_1.default)('cannon:builder:invoke');
function formatAbiFunction(v) {
    return `${v.name}(${v.inputs.map((i) => i.type).join(',')})`;
}
exports.formatAbiFunction = formatAbiFunction;
// we need this function because viem does not seem to have the ability to distinguish between overloaded functions the way ethers can
function assembleFunctionSignatures(abi) {
    const abiFunctions = abi.filter((v) => v.type === 'function');
    const prettyNames = abiFunctions.map(formatAbiFunction);
    // type detection is bad here
    return lodash_1.default.zip(abiFunctions, prettyNames);
}
async function runTxn(runtime, config, contract, signer, packageState) {
    let txn;
    // sanity check the contract we are calling has code defined
    // we check here because a missing contract will not revert when provided with data, leading to confusing situations
    // if invoke calls succeeding when no action was actually performed.
    if ((await runtime.provider.getBytecode({ address: contract.address })) === '0x') {
        throw new Error(`contract ${contract.address} for ${packageState.currentLabel} has no bytecode. This is most likely a missing dependency or bad state.`);
    }
    const overrides = {};
    if (config.overrides?.gasLimit) {
        overrides.gasLimit = config.overrides.gasLimit;
    }
    if (config.value) {
        overrides.value = config.value;
    }
    if (runtime.gasPrice) {
        overrides.gasPrice = runtime.gasPrice;
    }
    if (runtime.gasFee) {
        overrides.maxFeePerGas = runtime.gasFee;
    }
    if (runtime.priorityGasFee) {
        overrides.maxPriorityFeePerGas = runtime.priorityGasFee;
    }
    // Attempt to encode data so that if any arguments have any type mismatches, we can catch them and present them to the user.
    const functionList = assembleFunctionSignatures(contract.abi);
    const neededFuncAbi = functionList.find((f) => config.func == f[1] || config.func == f[1].split('(')[0])?.[0];
    if (!neededFuncAbi) {
        throw new Error(`contract ${contract.address} for ${packageState.currentLabel} does not contain the function "${config.func}". List of recognized functions is:\n${functionList
            .map((v) => v[1])
            .join('\n')}\n\nIf this is a proxy contract, make sure you’ve specified abiOf for the contract action in the cannonfile that deploys it. If you’re calling an overloaded function, update func to include parentheses.`);
    }
    if (config.fromCall && config.fromCall.func) {
        debug('resolve from address', contract.address);
        const neededOwnerFuncAbi = functionList.find((f) => config.fromCall.func == f[1] || config.fromCall.func == f[1].split('(')[0])?.[0];
        if (!neededOwnerFuncAbi) {
            throw new Error(`contract ${contract.address} for ${packageState.currentLabel} does not contain the function "${config.func}" to determine owner. List of recognized functions is:\n${Object.keys(contract.abi.filter((v) => v.type === 'function').map((v) => v.name)).join('\n')}\n\nIf this is a proxy contract, make sure you’ve specified abiOf for the contract action in the cannonfile that deploys it.`);
        }
        const addressCall = await runtime.provider.simulateContract({
            address: contract.address,
            abi: [neededOwnerFuncAbi],
            functionName: neededOwnerFuncAbi.name,
            args: config.fromCall.args,
        });
        const address = addressCall.result;
        debug('owner for call', address);
        const callSigner = await runtime.getSigner(address);
        const preparedTxn = await runtime.provider.prepareTransactionRequest({
            account: callSigner.wallet.account || callSigner.address,
            to: contract.address,
            data: viem.encodeFunctionData({ abi: [neededFuncAbi], functionName: neededFuncAbi.name, args: config.args }),
            value: config.value,
            ...overrides,
        });
        txn = await callSigner.wallet.sendTransaction(preparedTxn);
    }
    else {
        const preparedTxn = await runtime.provider.prepareTransactionRequest({
            account: signer.wallet.account || signer.address,
            to: contract.address,
            data: viem.encodeFunctionData({ abi: [neededFuncAbi], functionName: neededFuncAbi.name, args: config.args }),
            value: config.value,
            ...overrides,
        });
        txn = await signer.wallet.sendTransaction(preparedTxn);
    }
    const receipt = await runtime.provider.waitForTransactionReceipt({ hash: txn });
    debug('got receipt', receipt);
    // get events
    const txnEvents = lodash_1.default.groupBy(viem.parseEventLogs({ ...contract, logs: receipt.logs }).map((l) => {
        const eventAbi = viem.getAbiItem({ abi: contract.abi, name: l.eventName });
        return { name: l.eventName, args: eventAbi.inputs.map((i) => l.args[i.name]) };
    }), 'name');
    debug('decoded events', txnEvents);
    return [receipt, txnEvents];
}
function parseEventOutputs(config, txnEvents) {
    const vals = {};
    let expectedEvent = '';
    if (config) {
        for (const n in txnEvents) {
            for (const [name, varData] of Object.entries(config)) {
                const events = lodash_1.default.entries(txnEvents[n][varData.event]);
                // Check for an event defined in the cannonfile
                if (Object.prototype.hasOwnProperty.call(config, name) &&
                    Object.prototype.hasOwnProperty.call(config[name], 'event')) {
                    expectedEvent = config[name].event;
                }
                if (!config[name].allowEmptyEvents) {
                    if (events.length === 0) {
                        throw new Error(`Event specified in cannonfile:\n\n ${expectedEvent} \n\ndoesn't exist or match an event emitted by the invoked function of the contract.`);
                    }
                }
                for (const [i, e] of events) {
                    let label = name;
                    if (txnEvents.length > 1) {
                        label += '_' + n;
                    }
                    if (events.length > 1) {
                        label += '_' + i;
                    }
                    const v = e.args[varData.arg];
                    vals[label] = typeof v == 'bigint' ? v.toString() : v;
                }
            }
        }
    }
    return vals;
}
async function importTxnData(runtime, ctx, config, packageState, txns) {
    const contracts = {};
    if (config.factory) {
        for (const [k, contractAddress] of lodash_1.default.entries(parseEventOutputs(config.factory, lodash_1.default.map(txns, 'events')))) {
            const topLabel = k.split('_')[0];
            const factoryInfo = config.factory[topLabel];
            if (!contractAddress || !viem.isAddress(contractAddress)) {
                throw new Error(`address is not valid in ${topLabel}. Ensure "arg" parameter is correct`);
            }
            let abi;
            let sourceName;
            let contractName;
            if (factoryInfo.artifact) {
                const artifact = await runtime.getArtifact(factoryInfo.artifact);
                abi = artifact.abi;
                sourceName = artifact.sourceName;
                contractName = artifact.contractName;
            }
            else if (factoryInfo.abiOf) {
                abi = (0, util_1.getMergedAbiFromContractPaths)(ctx, factoryInfo.abiOf);
                sourceName = ''; // TODO: might cause a problem, might be able to load from the resolved contract itself. update `getContractFromPath`
                contractName = '';
            }
            else {
                throw new Error(`factory."${topLabel}": must specify at least one of "artifact" or "abiOf" to resolve the contract ABI for the created contract`);
            }
            contracts[k] = {
                address: contractAddress,
                abi,
                //deployTxnHash: txns[0].hash, // TODO: find the hash for the actual txn we are reading?
                deployTxnHash: '',
                constructorArgs: factoryInfo.constructorArgs,
                sourceName: sourceName,
                contractName: contractName,
                deployedOn: packageState.currentLabel,
                // contract was deployed as part of another transaction that was alreayd counted for gas usage, so we mark gas cost/usage as 0 here
                gasUsed: 0,
                gasCost: '0',
            };
            if (factoryInfo.highlight) {
                contracts[k].highlight = true;
            }
        }
    }
    const settings = parseEventOutputs(config.var || config.extra, lodash_1.default.map(txns, 'events'));
    return {
        contracts,
        txns,
        settings,
    };
}
// ensure the specified contract is already deployed
// if not deployed, deploy the specified hardhat contract with specfied options, export address, abi, etc.
// if already deployed, reexport deployment options for usage downstream and exit with no changes
const invokeSpec = {
    label: 'invoke',
    validate: schemas_1.invokeSchema,
    async getState(_runtime, ctx, config) {
        const cfg = this.configInject(ctx, config);
        if (typeof cfg.target === 'string') {
            cfg.target = [cfg.target];
        }
        return [
            {
                to: cfg.target?.map((t) => (0, util_1.getContractFromPath)(ctx, t)?.address),
                func: cfg.func,
                args: cfg.args?.map((v) => JSON.stringify(v)),
                value: cfg.value || '0',
                factory: cfg.factory,
                var: cfg.var || cfg.extra,
            },
            {
                to: cfg.target?.map((t) => (0, util_1.getContractFromPath)(ctx, t)?.address),
                func: cfg.func,
                args: cfg.args?.map((v) => JSON.stringify(v)),
                value: cfg.value || '0',
                factory: cfg.factory,
                extra: cfg.var || cfg.extra,
            },
            {
                to: cfg.target?.map((t) => (0, util_1.getContractFromPath)(ctx, t)?.address),
                func: cfg.func,
                args: cfg.args?.map((v) => JSON.stringify(v)),
                value: cfg.value || '0',
            },
        ];
    },
    configInject(ctx, config) {
        config = lodash_1.default.cloneDeep(config);
        if (typeof config.target === 'string') {
            config.target = [config.target];
        }
        if (config.target) {
            // [string, ...string[]] refers to a nonempty array
            config.target = config.target.map((v) => lodash_1.default.template(v)(ctx));
        }
        if (config.abi) {
            config.abi = lodash_1.default.template(config.abi)(ctx);
        }
        config.func = lodash_1.default.template(config.func)(ctx);
        if (config.args) {
            config.args = lodash_1.default.map(config.args, (a) => {
                // just convert it to a JSON string when. This will allow parsing of complicated nested structures
                return JSON.parse(lodash_1.default.template(JSON.stringify(a))(ctx));
            });
        }
        if (config.from) {
            config.from = lodash_1.default.template(config.from)(ctx);
        }
        if (config.fromCall) {
            config.fromCall.func = lodash_1.default.template(config.fromCall.func)(ctx);
            config.fromCall.args = lodash_1.default.map(config.fromCall.args, (a) => {
                // just convert it to a JSON string when. This will allow parsing of complicated nested structures
                return JSON.parse(lodash_1.default.template(JSON.stringify(a))(ctx));
            });
        }
        if (config.value) {
            config.value = lodash_1.default.template(config.value)(ctx);
        }
        if (config?.overrides?.gasLimit) {
            config.overrides.gasLimit = lodash_1.default.template(config.overrides.gasLimit)(ctx);
        }
        for (const name in config.factory) {
            const f = config.factory[name];
            f.event = lodash_1.default.template(f.event)(ctx);
            if (f.artifact) {
                f.artifact = lodash_1.default.template(f.artifact)(ctx);
            }
            if (f.abiOf) {
                f.abiOf = lodash_1.default.map(f.abiOf, (v) => lodash_1.default.template(v)(ctx));
            }
        }
        const varsConfig = config.var || config.extra;
        for (const name in varsConfig) {
            const f = varsConfig[name];
            f.event = lodash_1.default.template(f.event)(ctx);
        }
        return config;
    },
    getInputs(config, possibleFields) {
        let accesses = (0, access_recorder_1.computeTemplateAccesses)(config.abi, possibleFields);
        accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(config.func, possibleFields));
        accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(config.from, possibleFields));
        accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(config.value, possibleFields));
        for (const target of config.target) {
            if (!viem.isAddress(target)) {
                if (target.includes('.')) {
                    accesses.accesses.push(`imports.${target.split('.')[0]}`);
                }
                else {
                    accesses.accesses.push(`contracts.${target}`);
                }
            }
        }
        if (config.args) {
            lodash_1.default.forEach(config.args, (a) => (accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(JSON.stringify(a), possibleFields))));
        }
        if (config.fromCall) {
            accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(config.fromCall.func, possibleFields));
            lodash_1.default.forEach(config.fromCall.args, (a) => (accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(JSON.stringify(a), possibleFields))));
        }
        if (config?.overrides) {
            accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(config.overrides.gasLimit, possibleFields));
        }
        for (const name in config.factory) {
            const f = config.factory[name];
            accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(f.event, possibleFields));
            accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(f.artifact, possibleFields));
            lodash_1.default.forEach(f.abiOf, (a) => (accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(a, possibleFields))));
        }
        const varsConfig = config.var || config.extra;
        for (const name in varsConfig) {
            const f = varsConfig[name];
            accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(f.event, possibleFields));
        }
        return accesses;
    },
    getOutputs(config, packageState) {
        const outputs = [`txns.${packageState.currentLabel.split('.')[1]}`];
        // factories can output contracts, and var can output vars
        if (config.factory) {
            for (const k in config.factory) {
                if ((config.factory[k].expectCount || 1) > 1) {
                    for (let i = 0; i < config.factory[k].expectCount; i++) {
                        outputs.push(`contracts.${k}_${i}`);
                        outputs.push(`${k}_${i}`);
                    }
                }
                else {
                    outputs.push(`contracts.${k}`);
                    outputs.push(k);
                }
            }
        }
        const varsConfig = config.var || config.extra;
        if (varsConfig) {
            for (const k in varsConfig) {
                if ((varsConfig[k].expectCount || 1) > 1) {
                    for (let i = 0; i < varsConfig[k].expectCount; i++) {
                        outputs.push(`settings.${k}_${i}`);
                        // backwards compatibility
                        outputs.push(`extras.${k}_${i}`);
                    }
                }
                else {
                    outputs.push(`settings.${k}`);
                    //backwards compatibility
                    outputs.push(`extras.${k}`);
                }
            }
        }
        return outputs;
    },
    async exec(runtime, ctx, config, packageState) {
        debug('exec', config);
        const txns = {};
        const mainSigner = config.from
            ? await runtime.getSigner(config.from)
            : await runtime.getDefaultSigner({}, '');
        const customAbi = typeof config.abi === 'string'
            ? config.abi.startsWith('[')
                ? JSON.parse(config.abi)
                : (0, util_1.getContractDefinitionFromPath)(ctx, config.abi)?.abi
            : null;
        for (const t of config.target || []) {
            let contract;
            debug('get contract for target: ', t);
            if (viem.isAddress(t)) {
                if (!customAbi) {
                    throw new Error('abi must be defined if addresses is used for target');
                }
                contract = { address: t, abi: customAbi };
            }
            else {
                contract = (0, util_1.getContractFromPath)(ctx, t);
                if (contract && customAbi) {
                    contract.abi = customAbi;
                }
            }
            if (!contract) {
                throw new Error(`field "target": contract with name '${t}' not found. The valid list of recognized contracts is:
${(0, util_1.getAllContractPaths)(ctx).join('\n')}`);
            }
            const [receipt, txnEvents] = await runTxn(runtime, config, contract, mainSigner, packageState);
            const splitLabel = packageState.currentLabel.split('.')[1];
            const label = config.target?.length === 1 ? splitLabel || '' : `${splitLabel}_${t}`;
            debug('ran txn', label);
            debug('got events', txnEvents);
            txns[label] = {
                hash: receipt.transactionHash,
                events: txnEvents,
                deployedOn: packageState.currentLabel,
                gasUsed: Number(receipt.gasUsed),
                gasCost: receipt.effectiveGasPrice.toString(),
                signer: viem.getAddress(receipt.from),
            };
        }
        return importTxnData(runtime, ctx, config, packageState, txns);
    },
    async importExisting(runtime, ctx, config, packageState, existingKeys) {
        const txns = {};
        for (let i = 0; i < existingKeys.length; i++) {
            const key = existingKeys[i];
            const splitLabel = packageState.currentLabel.split('.')[1];
            const label = config.target?.length === 1 ? splitLabel || '' : `${splitLabel}_${i}`;
            const customAbi = typeof config.abi === 'string'
                ? config.abi.startsWith('[')
                    ? JSON.parse(config.abi)
                    : (0, util_1.getContractDefinitionFromPath)(ctx, config.abi)?.abi
                : null;
            debug('resolved contract abi for txn decode', customAbi, config);
            let contract;
            if (viem.isAddress(config.target[i])) {
                if (!customAbi) {
                    throw new Error('abi must be defined if addresses is used for target');
                }
                contract = { address: config.target[i], abi: customAbi };
            }
            else {
                contract = (0, util_1.getContractFromPath)(ctx, config.target[i]);
                if (customAbi && contract) {
                    contract.abi = customAbi;
                }
            }
            if (!contract) {
                throw new Error('target contract not found');
            }
            const receipt = await runtime.provider.getTransactionReceipt({ hash: key });
            const txnEvents = lodash_1.default.groupBy(viem.parseEventLogs({ ...contract, logs: receipt.logs }).map((l) => {
                const eventAbi = viem.getAbiItem({ abi: contract.abi, name: l.eventName });
                return { name: l.eventName, args: eventAbi.inputs.map((i) => l.args[i.name]) };
            }), 'name');
            txns[label] = {
                hash: key,
                events: txnEvents,
                deployedOn: packageState.currentLabel,
                gasUsed: Number(receipt.gasUsed),
                gasCost: receipt.effectiveGasPrice.toString(),
                signer: viem.getAddress(receipt.from),
            };
        }
        return importTxnData(runtime, ctx, config, packageState, txns);
    },
};
exports.default = invokeSpec;
//# sourceMappingURL=invoke.js.map
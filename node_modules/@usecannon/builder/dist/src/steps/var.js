"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const lodash_1 = __importDefault(require("lodash"));
const access_recorder_1 = require("../access-recorder");
const schemas_1 = require("../schemas");
const debug = (0, debug_1.default)('cannon:builder:var');
// ensure the specified contract is already deployed
// if not deployed, deploy the specified hardhat contract with specfied options, export address, abi, etc.
// if already deployed, reexport deployment options for usage downstream and exit with no changes
const varSpec = {
    label: 'var',
    validate: schemas_1.varSchema,
    async getState(runtime, ctx, config) {
        const cfg = this.configInject(ctx, config);
        return [lodash_1.default.omit(cfg, 'depends')];
    },
    configInject(ctx, config) {
        config = lodash_1.default.cloneDeep(config);
        for (const c in lodash_1.default.omit(config, 'depends')) {
            config[c] = lodash_1.default.template(config[c])(ctx);
        }
        return config;
    },
    getInputs(config, possibleFields) {
        let accesses = (0, access_recorder_1.computeTemplateAccesses)('', possibleFields);
        for (const c in lodash_1.default.omit(config, 'depends')) {
            accesses = (0, access_recorder_1.mergeTemplateAccesses)(accesses, (0, access_recorder_1.computeTemplateAccesses)(config[c], possibleFields));
        }
        return accesses;
    },
    getOutputs(config, packageState) {
        if (packageState.currentLabel.startsWith('setting.')) {
            return [`settings.${packageState.currentLabel.split('.')[1]}`];
        }
        return Object.keys(config)
            .filter((k) => k !== 'depends')
            .map((k) => `settings.${k}`);
    },
    async exec(runtime, ctx, config, packageState) {
        const varLabel = packageState.currentLabel?.split('.')[1] || '';
        debug('exec', config, ctx);
        // backwards compatibility
        if (packageState.currentLabel.startsWith('setting.')) {
            const stepName = packageState.currentLabel.split('.')[1];
            let value = config.value || config.defaultValue || ctx.overrideSettings[stepName];
            if (!value) {
                value = '';
            }
            return {
                settings: {
                    [varLabel]: value,
                },
            };
        }
        else {
            const settings = {};
            for (const c in lodash_1.default.omit(config, 'depends')) {
                settings[c] = config[c];
            }
            return { settings };
        }
    },
};
exports.default = varSpec;
//# sourceMappingURL=var.js.map
import { CannonStorage } from './runtime';
import { BundledOutput, ChainArtifacts, DeploymentInfo } from './types';
interface PartialRefValues {
    name: string;
    version?: string;
    preset?: string;
}
type CopyPackageOpts = {
    packageRef: string;
    chainId: number;
    tags: string[];
    fromStorage: CannonStorage;
    toStorage: CannonStorage;
    recursive?: boolean;
    preset?: string;
    includeProvisioned?: boolean;
};
export interface PackagePublishCall {
    packagesNames: string[];
    chainId: number;
    url: string;
    metaUrl: string;
}
/**
 * Used to format any reference to a cannon package and split it into it's core parts
 */
export declare class PackageReference {
    static DEFAULT_TAG: string;
    static DEFAULT_PRESET: string;
    static PACKAGE_REGEX: RegExp;
    /**
     * Anything before the colon or an @ (if no version is present) is the package name.
     */
    name: string;
    /**
     *  Anything between the colon and the @ is the package version.
     *  Defaults to 'latest' if not specified in reference
     */
    version: string;
    /**
     * Anything after the @ is the package preset.
     */
    preset: string;
    /**
     * Convenience parameter for returning packageRef with interpolated version and preset like name:version@preset
     */
    get fullPackageRef(): string;
    get packageRef(): string;
    /**
     * Parse package reference without normalizing it
     */
    static parse(ref: string): PartialRefValues;
    static isValid(ref: string): boolean;
    static from(name: string, version?: string, preset?: string): PackageReference;
    /**
     * Parse variant string into chainId and preset
     * @param variant string
     * @returns chainId and preset
     */
    static parseVariant(variant: string): [number, string];
    constructor(ref: string);
}
/**
 * Iterate Depth-First-Search over the given DeploymentInfo and its dependencies, and execute the given `action` function. Postfix execution (aka, `action` is only executed after dependants are completed).
 * Each package executes one at a time. No paralellization.
 * @param loader The loader to use for downloading sub-packages
 * @param deployInfo The head node of the tree, which will be executed on `action` last
 * @param action The action to execute
 * @param onlyResultProvisioned Only return results for packages that were provisioned. Useful when publishing. Does not prevent execution of action.
 */
export declare function forPackageTree<T extends {
    url?: string;
    artifacts?: ChainArtifacts;
}>(store: CannonStorage, deployInfo: DeploymentInfo, action: (deployInfo: DeploymentInfo, context: BundledOutput | null) => Promise<T>, context?: BundledOutput | null, onlyResultProvisioned?: boolean): Promise<T[]>;
export declare function preparePublishPackage({ packageRef, tags, chainId, fromStorage, toStorage, includeProvisioned, }: CopyPackageOpts): Promise<PackagePublishCall[]>;
/**
 * Copies package info from one storage medium to another (usually local to IPFS) and publishes it to the registry.
 */
export declare function publishPackage({ packageRef, tags, chainId, fromStorage, toStorage, includeProvisioned, }: CopyPackageOpts): Promise<string[]>;
export {};
//# sourceMappingURL=package.d.ts.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeTemplateAccesses = exports.computeTemplateAccesses = exports.AccessRecorder = void 0;
const lodash_1 = __importDefault(require("lodash"));
const types_1 = require("./types");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('cannon:builder:access-recorder');
class ExtendableProxy {
    constructor() {
        this.accessed = new Map();
        return new Proxy(this, {
            get: (obj, prop) => {
                if (prop === 'accessed' || prop === 'getAccesses') {
                    return obj[prop];
                }
                if (!this.accessed.has(prop)) {
                    this.accessed.set(prop, new AccessRecorder());
                }
                if (typeof prop === 'symbol') {
                    return () => '';
                }
                else if (types_1.CannonHelperContext[prop]) {
                    // return a dummy function which returns nothing.
                    // this increases the probability that an expression will work out in the template
                    return lodash_1.default.noop;
                }
                return this.accessed.get(prop);
            },
        });
    }
}
class AccessRecorder extends ExtendableProxy {
    getAccesses(depth, cur = 1) {
        if (cur == depth) {
            return Array.from(this.accessed.keys());
        }
        const acc = [];
        for (const k in this.accessed.keys()) {
            acc.push(k);
            acc.push(...this.accessed
                .get(k)
                .getAccesses(depth, (cur || 1) + 1)
                .map((a) => `${k}.${a}`));
        }
        return acc;
    }
}
exports.AccessRecorder = AccessRecorder;
function computeTemplateAccesses(str, possibleNames = []) {
    if (!str) {
        return { accesses: [], unableToCompute: false };
    }
    const recorders = {
        contracts: new AccessRecorder(),
        imports: new AccessRecorder(),
        extras: new AccessRecorder(),
        txns: new AccessRecorder(),
        settings: new AccessRecorder(),
    };
    for (const n in types_1.CannonHelperContext) {
        if (typeof types_1.CannonHelperContext[n] === 'function') {
            // the types have been a massive unsolvableseeming pain here
            recorders[n] = lodash_1.default.noop;
        }
        recorders[n] = types_1.CannonHelperContext[n];
    }
    for (const n of possibleNames) {
        recorders[n] = new AccessRecorder();
    }
    const baseTemplate = lodash_1.default.template(str, {
        imports: recorders,
    });
    let unableToCompute = false;
    try {
        baseTemplate();
    }
    catch (err) {
        debug('ran into template processing error, mark unable to compute', err);
        unableToCompute = true;
    }
    const accesses = [];
    for (const recorder of lodash_1.default.difference(Object.keys(recorders), Object.keys(types_1.CannonHelperContext))) {
        if (recorders[recorder] instanceof AccessRecorder) {
            if (possibleNames.includes(recorder) && recorders[recorder].accessed.size > 0) {
                accesses.push(recorder);
            }
            else {
                accesses.push(...Array.from(recorders[recorder].accessed.keys()).map((a) => `${recorder}.${a}`));
            }
        }
    }
    return { accesses, unableToCompute };
}
exports.computeTemplateAccesses = computeTemplateAccesses;
function mergeTemplateAccesses(r1, r2) {
    return {
        accesses: [...r1.accesses, ...r2.accesses],
        unableToCompute: r1.unableToCompute || r2.unableToCompute,
    };
}
exports.mergeTemplateAccesses = mergeTemplateAccesses;
//# sourceMappingURL=access-recorder.js.map
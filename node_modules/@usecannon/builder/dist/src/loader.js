"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryLoader = exports.IPFSLoader = void 0;
const debug_1 = __importDefault(require("debug"));
const ipfs_1 = require("./ipfs");
const debug = (0, debug_1.default)('cannon:builder:loader');
class IPFSLoader {
    constructor(ipfsUrl, customHeaders = {}, timeout = 300000, retries = 3) {
        this.gatewayChecked = false;
        this.isGateway = false;
        this.customHeaders = {};
        this.ipfsUrl = ipfsUrl.replace('+ipfs://', '://');
        this.customHeaders = customHeaders;
        this.timeout = timeout;
        this.retries = retries;
    }
    async checkGateway() {
        if (this.gatewayChecked)
            return;
        this.isGateway = await (0, ipfs_1.isIpfsGateway)(this.ipfsUrl, this.customHeaders);
        this.gatewayChecked = true;
    }
    getLabel() {
        debug(`IPFSLoader.getLabel() ${this.ipfsUrl}`);
        return this.ipfsUrl;
    }
    async put(misc) {
        await this.checkGateway();
        debug('ipfs put');
        const hash = await (0, ipfs_1.writeIpfs)(this.ipfsUrl, misc, this.customHeaders, this.isGateway, this.timeout, this.retries);
        return IPFSLoader.PREFIX + hash;
    }
    async read(url) {
        await this.checkGateway();
        debug('ipfs read', url);
        return await (0, ipfs_1.readIpfs)(this.ipfsUrl, url.replace(IPFSLoader.PREFIX, ''), this.customHeaders, this.isGateway, this.timeout, this.retries);
    }
    async remove(url) {
        await this.checkGateway();
        debug('ipfs remove', url);
        const hash = url.replace(IPFSLoader.PREFIX, '');
        await (0, ipfs_1.deleteIpfs)(this.ipfsUrl, hash, this.customHeaders, this.isGateway, this.timeout);
    }
    async list() {
        await this.checkGateway();
        debug('ipfs list');
        return (0, ipfs_1.listPinsIpfs)(this.ipfsUrl, this.customHeaders, this.isGateway);
    }
}
exports.IPFSLoader = IPFSLoader;
IPFSLoader.PREFIX = 'ipfs://';
class InMemoryLoader {
    constructor(space) {
        this.datas = new Map();
        this.idx = 0;
        this.space = space;
    }
    getLabel() {
        return 'in memory';
    }
    async read(url) {
        return JSON.parse(this.datas.get(url) || 'null');
    }
    async put(misc) {
        const k = `mem://${this.space}/${this.idx++}`;
        this.datas.set(k, JSON.stringify(misc));
        return k;
    }
}
exports.InMemoryLoader = InMemoryLoader;
//# sourceMappingURL=loader.js.map
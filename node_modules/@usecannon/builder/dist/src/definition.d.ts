import { RawChainDefinition } from './actions';
import { ChainBuilderRuntime } from './runtime';
import { ChainBuilderContext } from './types';
export type ChainDefinitionProblems = {
    invalidSchema: any;
    missing: {
        action: string;
        dependency: string;
    }[];
    cycles: string[][];
};
export type StateLayers = {
    [key: string]: {
        actions: string[];
        depends: string[];
    };
};
export declare function validatePackageName(n: string): void;
export declare function validatePackageVersion(v: string): void;
export declare class ChainDefinition {
    private raw;
    private sensitiveDependencies;
    readonly allActionNames: string[];
    readonly roots: Set<string>;
    readonly leaves: Set<string>;
    private cachedLayers;
    readonly cachedActionDepths: Map<string, number>;
    readonly dependencyFor: Map<string, string>;
    readonly resolvedDependencies: Map<string, string[]>;
    constructor(def: RawChainDefinition, sensitiveDependencies?: boolean);
    getName(ctx: ChainBuilderContext): string;
    getVersion(ctx: ChainBuilderContext): string;
    getPreset(ctx: ChainBuilderContext): string;
    isPublicSourceCode(): boolean;
    getConfig(n: string, ctx: ChainBuilderContext): any;
    /**
     * Used to determine if a state needs to be re-run or not
     * @param n action name
     * @param ctx context used to generate configuration for the action
     * @returns string representing the current state of the action
     */
    getState(n: string, runtime: ChainBuilderRuntime, ctx: ChainBuilderContext, tainted: boolean): Promise<string[] | null>;
    /**
     * Returns a list of imported cannon packages which would be needed to successfully build this package
     * @param ctx context used for interpolation
     * @returns list of required imported cannon charts
     */
    getRequiredImports(ctx: ChainBuilderContext): {
        source: string;
        chainId: number;
        preset: string;
    }[];
    /**
     * Get direct dependencies for a given node
     * @param node action to get dependencies for
     * @returns direct dependencies for the specified node
     */
    computeDependencies(node: string): string[];
    getDependencies(node: string): string[];
    /**
     * @note deps returned in topological order
     * @returns all dependencies reachable from the specfied node, and the depth of the iteration required
     */
    getDependencyTree: (node: string) => [string[], number];
    get topologicalActions(): string[];
    checkAll(): ChainDefinitionProblems | null;
    /**
     * Checks for any dependency actions which aren't defined among the given list of dependencies to check
     * @param actions which actions to check for missing dependencies
     * @returns a list of missing dependencies
     */
    checkMissing(actions?: string[]): {
        action: string;
        dependency: string;
    }[];
    /**
     * Determines if the nodes reachable from the given list of actions have any cycles.
     *
     * If any cycles exist, an array of all the nodes involved in the cycle will be returned
     */
    checkCycles(actions?: string[], seenNodes?: Set<string>, currentPath?: Set<string>): string[] | null;
    /**
     * Runs `checkExtraneousdependenciesOnNode` for all actions, effectively checking the whole
     * chain definition for any extraneous dependencies.
     * @note according to wikipidea, this is allegedly the fastest algorithm to verify a transitive reduction
     * @returns list of extraneous dependencies found
     */
    checkExtraneousDependencies(): {
        node: string;
        extraneous: string;
        inDep: string;
    }[];
    /**
     * Determines if the given node has any extraneous dependencies (that is, a dependency which is also contained in one of its children).
     *
     * If any extraneous dependencies are found, they are returned.
     *
     * @param node the node to start verifying from
     * @returns list of extraneous dependencies found
     */
    checkExtraneousDependenciesOnNode(node: string): {
        node: string;
        extraneous: string;
        inDep: string;
    }[];
    getLayerDependencyTree(n: string, layers: StateLayers): string[];
    getStateLayers(): StateLayers;
    private getPrintLinesUsed;
    printPartialTopology(n: string, layers?: StateLayers, line?: number): string;
    /**
     * returns human-readable representation of the dag dependency graph of this chain definition
     * @returns array of lines to print
     */
    printTopology(nodes?: string[]): string[];
    toJson(): RawChainDefinition;
}
//# sourceMappingURL=definition.d.ts.map
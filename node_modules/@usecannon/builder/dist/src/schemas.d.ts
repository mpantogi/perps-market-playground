import { z } from 'zod';
export declare const deploySchema: z.ZodObject<z.objectUtil.extendShape<{
    /**
     *    Artifact name of the target contract
     */
    artifact: z.ZodEffects<z.ZodString, string, string>;
}, {
    highlight: z.ZodOptional<z.ZodBoolean>;
    create2: z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodEffects<z.ZodString, string, string>]>>;
    from: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
    nonce: z.ZodOptional<z.ZodEffects<z.ZodEffects<z.ZodUnion<[z.ZodString, z.ZodNumber]>, string | number, string | number>, string, string | number>>;
    abi: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
    abiOf: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
    args: z.ZodOptional<z.ZodArray<z.ZodLazy<any>, "many">>;
    libraries: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    salt: z.ZodOptional<z.ZodString>;
    value: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
    overrides: z.ZodOptional<z.ZodObject<{
        gasLimit: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        gasLimit?: string | undefined;
    }, {
        gasLimit?: string | undefined;
    }>>;
    depends: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
}>, "strip", z.ZodTypeAny, {
    artifact: string;
    value?: string | undefined;
    highlight?: boolean | undefined;
    create2?: string | boolean | undefined;
    from?: string | undefined;
    nonce?: string | undefined;
    abi?: string | undefined;
    abiOf?: string[] | undefined;
    args?: any[] | undefined;
    libraries?: Record<string, string> | undefined;
    salt?: string | undefined;
    overrides?: {
        gasLimit?: string | undefined;
    } | undefined;
    depends?: string[] | undefined;
}, {
    artifact: string;
    value?: string | undefined;
    highlight?: boolean | undefined;
    create2?: string | boolean | undefined;
    from?: string | undefined;
    nonce?: string | number | undefined;
    abi?: string | undefined;
    abiOf?: string[] | undefined;
    args?: any[] | undefined;
    libraries?: Record<string, string> | undefined;
    salt?: string | undefined;
    overrides?: {
        gasLimit?: string | undefined;
    } | undefined;
    depends?: string[] | undefined;
}>;
export declare const pullSchema: z.ZodObject<z.objectUtil.extendShape<{
    /**
     *  Source of the cannonfile package to import from.
     *  Can be a cannonfile operation name or package name
     */
    source: z.ZodEffects<z.ZodString, string, string>;
}, {
    chainId: z.ZodOptional<z.ZodNumber>;
    preset: z.ZodOptional<z.ZodString>;
    depends: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
}>, "strip", z.ZodTypeAny, {
    source: string;
    depends?: string[] | undefined;
    chainId?: number | undefined;
    preset?: string | undefined;
}, {
    source: string;
    depends?: string[] | undefined;
    chainId?: number | undefined;
    preset?: string | undefined;
}>;
export declare const invokeSchema: z.ZodObject<z.objectUtil.extendShape<{
    /**
     *  Names of the contract to call or contract operation that deployed the contract to call
     */
    target: z.ZodUnion<[z.ZodEffects<z.ZodString, string, string>, z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "atleastone">]>;
    /**
     *  Name of the function to call on the contract
     */
    func: z.ZodString;
}, {
    abi: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
    args: z.ZodOptional<z.ZodArray<z.ZodLazy<any>, "many">>;
    from: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
    fromCall: z.ZodOptional<z.ZodObject<{
        /**
         *  The name of a view function to call on this contract. The result will be used as the from input.
         */
        func: z.ZodString;
        /**
         *  The arguments to pass into the function being called.
         */
        args: z.ZodOptional<z.ZodArray<z.ZodLazy<any>, "many">>;
    }, "strip", z.ZodTypeAny, {
        func: string;
        args?: any[] | undefined;
    }, {
        func: string;
        args?: any[] | undefined;
    }>>;
    value: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
    overrides: z.ZodOptional<z.ZodObject<{
        /**
         *   Gas limit to send along with the transaction
         */
        gasLimit: z.ZodEffects<z.ZodString, string, string>;
    }, "strip", z.ZodTypeAny, {
        gasLimit: string;
    }, {
        gasLimit: string;
    }>>;
    var: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
        /**
         *   Name of the event to get data for
         */
        event: z.ZodString;
        /**
         *   Data argument of the event output
         */
        arg: z.ZodNumber;
        /**
         *   Number of matching contract events which should be seen by this event (default 1) (set to 0 to make optional)
         */
        expectCount: z.ZodOptional<z.ZodNumber>;
        /**
         *   Bypass error messages if an event is expected in the invoke operation but none are emitted in the transaction.
         */
        allowEmptyEvents: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        event: string;
        arg: number;
        expectCount?: number | undefined;
        allowEmptyEvents?: boolean | undefined;
    }, {
        event: string;
        arg: number;
        expectCount?: number | undefined;
        allowEmptyEvents?: boolean | undefined;
    }>>>;
    extra: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
        /**
         *   Name of the event to get data for
         */
        event: z.ZodString;
        /**
         *   Data argument of the event output
         */
        arg: z.ZodNumber;
        /**
         *   Number of matching contract events which should be seen by this event (default 1) (set to 0 to make optional)
         */
        expectCount: z.ZodOptional<z.ZodNumber>;
        /**
         *   Bypass error messages if an event is expected in the invoke operation but none are emitted in the transaction.
         */
        allowEmptyEvents: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        event: string;
        arg: number;
        expectCount?: number | undefined;
        allowEmptyEvents?: boolean | undefined;
    }, {
        event: string;
        arg: number;
        expectCount?: number | undefined;
        allowEmptyEvents?: boolean | undefined;
    }>>>;
    factory: z.ZodOptional<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
        /**
         *   Name of the event to get data for
         */
        event: z.ZodString;
        /**
         *   Data argument of the event output
         */
        arg: z.ZodNumber;
        /**
         *   Number of matching contract events which should be seen by this event (default 1) (set to 0 to make optional)
         */
        expectCount: z.ZodOptional<z.ZodNumber>;
        /**
         *   Name of the contract artifact
         */
        artifact: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        /**
         *  An array of contract artifacts that have already been deployed with Cannon.
         *  Used if the code for the deployed contract is not available in the artifacts.
         */
        abiOf: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
        /**
         *   Constructor or initializer args
         */
        constructorArgs: z.ZodOptional<z.ZodArray<z.ZodLazy<any>, "many">>;
        /**
         *   Bypass error messages if an event is expected in the invoke operation but none are emitted in the transaction.
         */
        allowEmptyEvents: z.ZodOptional<z.ZodBoolean>;
        /**
         *    Determines whether contract should get priority in displays
         */
        highlight: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        event: string;
        arg: number;
        artifact?: string | undefined;
        highlight?: boolean | undefined;
        abiOf?: string[] | undefined;
        expectCount?: number | undefined;
        allowEmptyEvents?: boolean | undefined;
        constructorArgs?: any[] | undefined;
    }, {
        event: string;
        arg: number;
        artifact?: string | undefined;
        highlight?: boolean | undefined;
        abiOf?: string[] | undefined;
        expectCount?: number | undefined;
        allowEmptyEvents?: boolean | undefined;
        constructorArgs?: any[] | undefined;
    }>>>>;
    depends: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
}>, "strip", z.ZodTypeAny, {
    target: string | [string, ...string[]];
    func: string;
    value?: string | undefined;
    from?: string | undefined;
    abi?: string | undefined;
    args?: any[] | undefined;
    overrides?: {
        gasLimit: string;
    } | undefined;
    depends?: string[] | undefined;
    fromCall?: {
        func: string;
        args?: any[] | undefined;
    } | undefined;
    var?: Record<string, {
        event: string;
        arg: number;
        expectCount?: number | undefined;
        allowEmptyEvents?: boolean | undefined;
    }> | undefined;
    extra?: Record<string, {
        event: string;
        arg: number;
        expectCount?: number | undefined;
        allowEmptyEvents?: boolean | undefined;
    }> | undefined;
    factory?: Record<string, {
        event: string;
        arg: number;
        artifact?: string | undefined;
        highlight?: boolean | undefined;
        abiOf?: string[] | undefined;
        expectCount?: number | undefined;
        allowEmptyEvents?: boolean | undefined;
        constructorArgs?: any[] | undefined;
    }> | undefined;
}, {
    target: string | [string, ...string[]];
    func: string;
    value?: string | undefined;
    from?: string | undefined;
    abi?: string | undefined;
    args?: any[] | undefined;
    overrides?: {
        gasLimit: string;
    } | undefined;
    depends?: string[] | undefined;
    fromCall?: {
        func: string;
        args?: any[] | undefined;
    } | undefined;
    var?: Record<string, {
        event: string;
        arg: number;
        expectCount?: number | undefined;
        allowEmptyEvents?: boolean | undefined;
    }> | undefined;
    extra?: Record<string, {
        event: string;
        arg: number;
        expectCount?: number | undefined;
        allowEmptyEvents?: boolean | undefined;
    }> | undefined;
    factory?: Record<string, {
        event: string;
        arg: number;
        artifact?: string | undefined;
        highlight?: boolean | undefined;
        abiOf?: string[] | undefined;
        expectCount?: number | undefined;
        allowEmptyEvents?: boolean | undefined;
        constructorArgs?: any[] | undefined;
    }> | undefined;
}>;
export declare const cloneSchema: z.ZodObject<z.objectUtil.extendShape<{
    /**
     *  Name of the package to provision
     */
    source: z.ZodEffects<z.ZodString, string, string>;
}, {
    chainId: z.ZodOptional<z.ZodNumber>;
    sourcePreset: z.ZodOptional<z.ZodString>;
    target: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
    targetPreset: z.ZodOptional<z.ZodString>;
    var: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    options: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    tags: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    depends: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
}>, "strip", z.ZodTypeAny, {
    source: string;
    options?: Record<string, string> | undefined;
    depends?: string[] | undefined;
    chainId?: number | undefined;
    target?: string | undefined;
    var?: Record<string, string> | undefined;
    sourcePreset?: string | undefined;
    targetPreset?: string | undefined;
    tags?: string[] | undefined;
}, {
    source: string;
    options?: Record<string, string> | undefined;
    depends?: string[] | undefined;
    chainId?: number | undefined;
    target?: string | undefined;
    var?: Record<string, string> | undefined;
    sourcePreset?: string | undefined;
    targetPreset?: string | undefined;
    tags?: string[] | undefined;
}>;
export declare const routerSchema: z.ZodObject<{
    /**
     * Set of contracts that will be passed to the router
     */
    contracts: z.ZodArray<z.ZodString, "many">;
    /**
     * Include a `receive` function on the router so that it can receive ETH (or, whatever the gas token is on your network).
     * NOTE: you can always define `payable` functions on your end-functions to receive ETH as well. This is only for receiving ETH like a regular EOA would.
     */
    includeReceive: z.ZodOptional<z.ZodBoolean>;
    /**
     *  Address to pass to the from call
     */
    from: z.ZodOptional<z.ZodString>;
    /**
     *   Used to force new copy of a contract (not actually used)
     */
    salt: z.ZodOptional<z.ZodString>;
    /**
     *  List of operations that this operation depends on, which Cannon will execute first. If unspecified, Cannon automatically detects dependencies.
     */
    depends: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    contracts: string[];
    from?: string | undefined;
    salt?: string | undefined;
    depends?: string[] | undefined;
    includeReceive?: boolean | undefined;
}, {
    contracts: string[];
    from?: string | undefined;
    salt?: string | undefined;
    depends?: string[] | undefined;
    includeReceive?: boolean | undefined;
}>;
export declare const varSchema: z.ZodObject<{
    /**
     *   The setting value to apply
     */
    defaultValue: z.ZodOptional<z.ZodString>;
    description: z.ZodOptional<z.ZodString>;
    /**
     *  List of operations that this operation depends on, which Cannon will execute first. If unspecified, Cannon automatically detects dependencies.
     */
    depends: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodString, z.objectOutputType<{
    /**
     *   The setting value to apply
     */
    defaultValue: z.ZodOptional<z.ZodString>;
    description: z.ZodOptional<z.ZodString>;
    /**
     *  List of operations that this operation depends on, which Cannon will execute first. If unspecified, Cannon automatically detects dependencies.
     */
    depends: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, z.ZodString, "strip">, z.objectInputType<{
    /**
     *   The setting value to apply
     */
    defaultValue: z.ZodOptional<z.ZodString>;
    description: z.ZodOptional<z.ZodString>;
    /**
     *  List of operations that this operation depends on, which Cannon will execute first. If unspecified, Cannon automatically detects dependencies.
     */
    depends: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, z.ZodString, "strip">>;
/**
 * @internal NOTE: if you edit this schema, please also edit the constructor of ChainDefinition in 'definition.ts' to account for non-operation components
 */
export declare const chainDefinitionSchema: z.ZodObject<z.objectUtil.extendShape<{
    /**
     * Name of the package
     */
    name: z.ZodEffects<z.ZodString, string, string>;
    /**
     *  Version of the package
     */
    version: z.ZodEffects<z.ZodString, string, string>;
    /**
     *  Preset of the package
     */
    preset: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
    /**
     * Whether or not source code from local package should be bundled in the package.
     * NOTE: If this is set to true, it will not be possible to verify your contracts on etherscan with cannon
     * If not specified, the value is treated as `false` (ie contract source codes included)
     */
    privateSourceCode: z.ZodOptional<z.ZodBoolean>;
}, {
    description: z.ZodOptional<z.ZodString>;
    keywords: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    setting: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
        description: z.ZodOptional<z.ZodString>;
        type: z.ZodOptional<z.ZodEnum<["number", "string", "boolean"]>>;
        defaultValue: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        type?: "string" | "number" | "boolean" | undefined;
        defaultValue?: string | undefined;
        description?: string | undefined;
    }, {
        type?: "string" | "number" | "boolean" | undefined;
        defaultValue?: string | undefined;
        description?: string | undefined;
    }>>>;
    pull: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<z.objectUtil.extendShape<{
        /**
         *  Source of the cannonfile package to import from.
         *  Can be a cannonfile operation name or package name
         */
        source: z.ZodEffects<z.ZodString, string, string>;
    }, {
        chainId: z.ZodOptional<z.ZodNumber>;
        preset: z.ZodOptional<z.ZodString>;
        depends: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
    }>, "strip", z.ZodTypeAny, {
        source: string;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        preset?: string | undefined;
    }, {
        source: string;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        preset?: string | undefined;
    }>>>;
    import: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<z.objectUtil.extendShape<{
        /**
         *  Source of the cannonfile package to import from.
         *  Can be a cannonfile operation name or package name
         */
        source: z.ZodEffects<z.ZodString, string, string>;
    }, {
        chainId: z.ZodOptional<z.ZodNumber>;
        preset: z.ZodOptional<z.ZodString>;
        depends: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
    }>, "strip", z.ZodTypeAny, {
        source: string;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        preset?: string | undefined;
    }, {
        source: string;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        preset?: string | undefined;
    }>>>;
    clone: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<z.objectUtil.extendShape<{
        /**
         *  Name of the package to provision
         */
        source: z.ZodEffects<z.ZodString, string, string>;
    }, {
        chainId: z.ZodOptional<z.ZodNumber>;
        sourcePreset: z.ZodOptional<z.ZodString>;
        target: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        targetPreset: z.ZodOptional<z.ZodString>;
        var: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
        options: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
        tags: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        depends: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
    }>, "strip", z.ZodTypeAny, {
        source: string;
        options?: Record<string, string> | undefined;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        target?: string | undefined;
        var?: Record<string, string> | undefined;
        sourcePreset?: string | undefined;
        targetPreset?: string | undefined;
        tags?: string[] | undefined;
    }, {
        source: string;
        options?: Record<string, string> | undefined;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        target?: string | undefined;
        var?: Record<string, string> | undefined;
        sourcePreset?: string | undefined;
        targetPreset?: string | undefined;
        tags?: string[] | undefined;
    }>>>;
    provision: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<z.objectUtil.extendShape<{
        /**
         *  Name of the package to provision
         */
        source: z.ZodEffects<z.ZodString, string, string>;
    }, {
        chainId: z.ZodOptional<z.ZodNumber>;
        sourcePreset: z.ZodOptional<z.ZodString>;
        target: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        targetPreset: z.ZodOptional<z.ZodString>;
        var: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
        options: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
        tags: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        depends: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
    }>, "strip", z.ZodTypeAny, {
        source: string;
        options?: Record<string, string> | undefined;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        target?: string | undefined;
        var?: Record<string, string> | undefined;
        sourcePreset?: string | undefined;
        targetPreset?: string | undefined;
        tags?: string[] | undefined;
    }, {
        source: string;
        options?: Record<string, string> | undefined;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        target?: string | undefined;
        var?: Record<string, string> | undefined;
        sourcePreset?: string | undefined;
        targetPreset?: string | undefined;
        tags?: string[] | undefined;
    }>>>;
    deploy: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<z.objectUtil.extendShape<{
        /**
         *    Artifact name of the target contract
         */
        artifact: z.ZodEffects<z.ZodString, string, string>;
    }, {
        highlight: z.ZodOptional<z.ZodBoolean>;
        create2: z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodEffects<z.ZodString, string, string>]>>;
        from: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        nonce: z.ZodOptional<z.ZodEffects<z.ZodEffects<z.ZodUnion<[z.ZodString, z.ZodNumber]>, string | number, string | number>, string, string | number>>;
        abi: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        abiOf: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
        args: z.ZodOptional<z.ZodArray<z.ZodLazy<any>, "many">>;
        libraries: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
        salt: z.ZodOptional<z.ZodString>;
        value: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        overrides: z.ZodOptional<z.ZodObject<{
            gasLimit: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            gasLimit?: string | undefined;
        }, {
            gasLimit?: string | undefined;
        }>>;
        depends: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
    }>, "strip", z.ZodTypeAny, {
        artifact: string;
        value?: string | undefined;
        highlight?: boolean | undefined;
        create2?: string | boolean | undefined;
        from?: string | undefined;
        nonce?: string | undefined;
        abi?: string | undefined;
        abiOf?: string[] | undefined;
        args?: any[] | undefined;
        libraries?: Record<string, string> | undefined;
        salt?: string | undefined;
        overrides?: {
            gasLimit?: string | undefined;
        } | undefined;
        depends?: string[] | undefined;
    }, {
        artifact: string;
        value?: string | undefined;
        highlight?: boolean | undefined;
        create2?: string | boolean | undefined;
        from?: string | undefined;
        nonce?: string | number | undefined;
        abi?: string | undefined;
        abiOf?: string[] | undefined;
        args?: any[] | undefined;
        libraries?: Record<string, string> | undefined;
        salt?: string | undefined;
        overrides?: {
            gasLimit?: string | undefined;
        } | undefined;
        depends?: string[] | undefined;
    }>>>;
    contract: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<z.objectUtil.extendShape<{
        /**
         *    Artifact name of the target contract
         */
        artifact: z.ZodEffects<z.ZodString, string, string>;
    }, {
        highlight: z.ZodOptional<z.ZodBoolean>;
        create2: z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodEffects<z.ZodString, string, string>]>>;
        from: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        nonce: z.ZodOptional<z.ZodEffects<z.ZodEffects<z.ZodUnion<[z.ZodString, z.ZodNumber]>, string | number, string | number>, string, string | number>>;
        abi: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        abiOf: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
        args: z.ZodOptional<z.ZodArray<z.ZodLazy<any>, "many">>;
        libraries: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
        salt: z.ZodOptional<z.ZodString>;
        value: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        overrides: z.ZodOptional<z.ZodObject<{
            gasLimit: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            gasLimit?: string | undefined;
        }, {
            gasLimit?: string | undefined;
        }>>;
        depends: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
    }>, "strip", z.ZodTypeAny, {
        artifact: string;
        value?: string | undefined;
        highlight?: boolean | undefined;
        create2?: string | boolean | undefined;
        from?: string | undefined;
        nonce?: string | undefined;
        abi?: string | undefined;
        abiOf?: string[] | undefined;
        args?: any[] | undefined;
        libraries?: Record<string, string> | undefined;
        salt?: string | undefined;
        overrides?: {
            gasLimit?: string | undefined;
        } | undefined;
        depends?: string[] | undefined;
    }, {
        artifact: string;
        value?: string | undefined;
        highlight?: boolean | undefined;
        create2?: string | boolean | undefined;
        from?: string | undefined;
        nonce?: string | number | undefined;
        abi?: string | undefined;
        abiOf?: string[] | undefined;
        args?: any[] | undefined;
        libraries?: Record<string, string> | undefined;
        salt?: string | undefined;
        overrides?: {
            gasLimit?: string | undefined;
        } | undefined;
        depends?: string[] | undefined;
    }>>>;
    invoke: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<z.objectUtil.extendShape<{
        /**
         *  Names of the contract to call or contract operation that deployed the contract to call
         */
        target: z.ZodUnion<[z.ZodEffects<z.ZodString, string, string>, z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "atleastone">]>;
        /**
         *  Name of the function to call on the contract
         */
        func: z.ZodString;
    }, {
        abi: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        args: z.ZodOptional<z.ZodArray<z.ZodLazy<any>, "many">>;
        from: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        fromCall: z.ZodOptional<z.ZodObject<{
            /**
             *  The name of a view function to call on this contract. The result will be used as the from input.
             */
            func: z.ZodString;
            /**
             *  The arguments to pass into the function being called.
             */
            args: z.ZodOptional<z.ZodArray<z.ZodLazy<any>, "many">>;
        }, "strip", z.ZodTypeAny, {
            func: string;
            args?: any[] | undefined;
        }, {
            func: string;
            args?: any[] | undefined;
        }>>;
        value: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        overrides: z.ZodOptional<z.ZodObject<{
            /**
             *   Gas limit to send along with the transaction
             */
            gasLimit: z.ZodEffects<z.ZodString, string, string>;
        }, "strip", z.ZodTypeAny, {
            gasLimit: string;
        }, {
            gasLimit: string;
        }>>;
        var: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
            /**
             *   Name of the event to get data for
             */
            event: z.ZodString;
            /**
             *   Data argument of the event output
             */
            arg: z.ZodNumber;
            /**
             *   Number of matching contract events which should be seen by this event (default 1) (set to 0 to make optional)
             */
            expectCount: z.ZodOptional<z.ZodNumber>;
            /**
             *   Bypass error messages if an event is expected in the invoke operation but none are emitted in the transaction.
             */
            allowEmptyEvents: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            event: string;
            arg: number;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
        }, {
            event: string;
            arg: number;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
        }>>>;
        extra: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
            /**
             *   Name of the event to get data for
             */
            event: z.ZodString;
            /**
             *   Data argument of the event output
             */
            arg: z.ZodNumber;
            /**
             *   Number of matching contract events which should be seen by this event (default 1) (set to 0 to make optional)
             */
            expectCount: z.ZodOptional<z.ZodNumber>;
            /**
             *   Bypass error messages if an event is expected in the invoke operation but none are emitted in the transaction.
             */
            allowEmptyEvents: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            event: string;
            arg: number;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
        }, {
            event: string;
            arg: number;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
        }>>>;
        factory: z.ZodOptional<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
            /**
             *   Name of the event to get data for
             */
            event: z.ZodString;
            /**
             *   Data argument of the event output
             */
            arg: z.ZodNumber;
            /**
             *   Number of matching contract events which should be seen by this event (default 1) (set to 0 to make optional)
             */
            expectCount: z.ZodOptional<z.ZodNumber>;
            /**
             *   Name of the contract artifact
             */
            artifact: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
            /**
             *  An array of contract artifacts that have already been deployed with Cannon.
             *  Used if the code for the deployed contract is not available in the artifacts.
             */
            abiOf: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
            /**
             *   Constructor or initializer args
             */
            constructorArgs: z.ZodOptional<z.ZodArray<z.ZodLazy<any>, "many">>;
            /**
             *   Bypass error messages if an event is expected in the invoke operation but none are emitted in the transaction.
             */
            allowEmptyEvents: z.ZodOptional<z.ZodBoolean>;
            /**
             *    Determines whether contract should get priority in displays
             */
            highlight: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            event: string;
            arg: number;
            artifact?: string | undefined;
            highlight?: boolean | undefined;
            abiOf?: string[] | undefined;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
            constructorArgs?: any[] | undefined;
        }, {
            event: string;
            arg: number;
            artifact?: string | undefined;
            highlight?: boolean | undefined;
            abiOf?: string[] | undefined;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
            constructorArgs?: any[] | undefined;
        }>>>>;
        depends: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodString, string, string>, "many">>;
    }>, "strip", z.ZodTypeAny, {
        target: string | [string, ...string[]];
        func: string;
        value?: string | undefined;
        from?: string | undefined;
        abi?: string | undefined;
        args?: any[] | undefined;
        overrides?: {
            gasLimit: string;
        } | undefined;
        depends?: string[] | undefined;
        fromCall?: {
            func: string;
            args?: any[] | undefined;
        } | undefined;
        var?: Record<string, {
            event: string;
            arg: number;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
        }> | undefined;
        extra?: Record<string, {
            event: string;
            arg: number;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
        }> | undefined;
        factory?: Record<string, {
            event: string;
            arg: number;
            artifact?: string | undefined;
            highlight?: boolean | undefined;
            abiOf?: string[] | undefined;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
            constructorArgs?: any[] | undefined;
        }> | undefined;
    }, {
        target: string | [string, ...string[]];
        func: string;
        value?: string | undefined;
        from?: string | undefined;
        abi?: string | undefined;
        args?: any[] | undefined;
        overrides?: {
            gasLimit: string;
        } | undefined;
        depends?: string[] | undefined;
        fromCall?: {
            func: string;
            args?: any[] | undefined;
        } | undefined;
        var?: Record<string, {
            event: string;
            arg: number;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
        }> | undefined;
        extra?: Record<string, {
            event: string;
            arg: number;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
        }> | undefined;
        factory?: Record<string, {
            event: string;
            arg: number;
            artifact?: string | undefined;
            highlight?: boolean | undefined;
            abiOf?: string[] | undefined;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
            constructorArgs?: any[] | undefined;
        }> | undefined;
    }>>>;
    router: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
        /**
         * Set of contracts that will be passed to the router
         */
        contracts: z.ZodArray<z.ZodString, "many">;
        /**
         * Include a `receive` function on the router so that it can receive ETH (or, whatever the gas token is on your network).
         * NOTE: you can always define `payable` functions on your end-functions to receive ETH as well. This is only for receiving ETH like a regular EOA would.
         */
        includeReceive: z.ZodOptional<z.ZodBoolean>;
        /**
         *  Address to pass to the from call
         */
        from: z.ZodOptional<z.ZodString>;
        /**
         *   Used to force new copy of a contract (not actually used)
         */
        salt: z.ZodOptional<z.ZodString>;
        /**
         *  List of operations that this operation depends on, which Cannon will execute first. If unspecified, Cannon automatically detects dependencies.
         */
        depends: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        contracts: string[];
        from?: string | undefined;
        salt?: string | undefined;
        depends?: string[] | undefined;
        includeReceive?: boolean | undefined;
    }, {
        contracts: string[];
        from?: string | undefined;
        salt?: string | undefined;
        depends?: string[] | undefined;
        includeReceive?: boolean | undefined;
    }>>>;
    var: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
        /**
         *   The setting value to apply
         */
        defaultValue: z.ZodOptional<z.ZodString>;
        description: z.ZodOptional<z.ZodString>;
        /**
         *  List of operations that this operation depends on, which Cannon will execute first. If unspecified, Cannon automatically detects dependencies.
         */
        depends: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodString, z.objectOutputType<{
        /**
         *   The setting value to apply
         */
        defaultValue: z.ZodOptional<z.ZodString>;
        description: z.ZodOptional<z.ZodString>;
        /**
         *  List of operations that this operation depends on, which Cannon will execute first. If unspecified, Cannon automatically detects dependencies.
         */
        depends: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, z.ZodString, "strip">, z.objectInputType<{
        /**
         *   The setting value to apply
         */
        defaultValue: z.ZodOptional<z.ZodString>;
        description: z.ZodOptional<z.ZodString>;
        /**
         *  List of operations that this operation depends on, which Cannon will execute first. If unspecified, Cannon automatically detects dependencies.
         */
        depends: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, z.ZodString, "strip">>>>;
}>, "strip", z.ZodTypeAny, {
    name: string;
    version: string;
    preset?: string | undefined;
    var?: Record<string, z.objectOutputType<{
        /**
         *   The setting value to apply
         */
        defaultValue: z.ZodOptional<z.ZodString>;
        description: z.ZodOptional<z.ZodString>;
        /**
         *  List of operations that this operation depends on, which Cannon will execute first. If unspecified, Cannon automatically detects dependencies.
         */
        depends: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, z.ZodString, "strip">> | undefined;
    description?: string | undefined;
    privateSourceCode?: boolean | undefined;
    keywords?: string[] | undefined;
    setting?: Record<string, {
        type?: "string" | "number" | "boolean" | undefined;
        defaultValue?: string | undefined;
        description?: string | undefined;
    }> | undefined;
    pull?: Record<string, {
        source: string;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        preset?: string | undefined;
    }> | undefined;
    import?: Record<string, {
        source: string;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        preset?: string | undefined;
    }> | undefined;
    clone?: Record<string, {
        source: string;
        options?: Record<string, string> | undefined;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        target?: string | undefined;
        var?: Record<string, string> | undefined;
        sourcePreset?: string | undefined;
        targetPreset?: string | undefined;
        tags?: string[] | undefined;
    }> | undefined;
    provision?: Record<string, {
        source: string;
        options?: Record<string, string> | undefined;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        target?: string | undefined;
        var?: Record<string, string> | undefined;
        sourcePreset?: string | undefined;
        targetPreset?: string | undefined;
        tags?: string[] | undefined;
    }> | undefined;
    deploy?: Record<string, {
        artifact: string;
        value?: string | undefined;
        highlight?: boolean | undefined;
        create2?: string | boolean | undefined;
        from?: string | undefined;
        nonce?: string | undefined;
        abi?: string | undefined;
        abiOf?: string[] | undefined;
        args?: any[] | undefined;
        libraries?: Record<string, string> | undefined;
        salt?: string | undefined;
        overrides?: {
            gasLimit?: string | undefined;
        } | undefined;
        depends?: string[] | undefined;
    }> | undefined;
    contract?: Record<string, {
        artifact: string;
        value?: string | undefined;
        highlight?: boolean | undefined;
        create2?: string | boolean | undefined;
        from?: string | undefined;
        nonce?: string | undefined;
        abi?: string | undefined;
        abiOf?: string[] | undefined;
        args?: any[] | undefined;
        libraries?: Record<string, string> | undefined;
        salt?: string | undefined;
        overrides?: {
            gasLimit?: string | undefined;
        } | undefined;
        depends?: string[] | undefined;
    }> | undefined;
    invoke?: Record<string, {
        target: string | [string, ...string[]];
        func: string;
        value?: string | undefined;
        from?: string | undefined;
        abi?: string | undefined;
        args?: any[] | undefined;
        overrides?: {
            gasLimit: string;
        } | undefined;
        depends?: string[] | undefined;
        fromCall?: {
            func: string;
            args?: any[] | undefined;
        } | undefined;
        var?: Record<string, {
            event: string;
            arg: number;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
        }> | undefined;
        extra?: Record<string, {
            event: string;
            arg: number;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
        }> | undefined;
        factory?: Record<string, {
            event: string;
            arg: number;
            artifact?: string | undefined;
            highlight?: boolean | undefined;
            abiOf?: string[] | undefined;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
            constructorArgs?: any[] | undefined;
        }> | undefined;
    }> | undefined;
    router?: Record<string, {
        contracts: string[];
        from?: string | undefined;
        salt?: string | undefined;
        depends?: string[] | undefined;
        includeReceive?: boolean | undefined;
    }> | undefined;
}, {
    name: string;
    version: string;
    preset?: string | undefined;
    var?: Record<string, z.objectInputType<{
        /**
         *   The setting value to apply
         */
        defaultValue: z.ZodOptional<z.ZodString>;
        description: z.ZodOptional<z.ZodString>;
        /**
         *  List of operations that this operation depends on, which Cannon will execute first. If unspecified, Cannon automatically detects dependencies.
         */
        depends: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, z.ZodString, "strip">> | undefined;
    description?: string | undefined;
    privateSourceCode?: boolean | undefined;
    keywords?: string[] | undefined;
    setting?: Record<string, {
        type?: "string" | "number" | "boolean" | undefined;
        defaultValue?: string | undefined;
        description?: string | undefined;
    }> | undefined;
    pull?: Record<string, {
        source: string;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        preset?: string | undefined;
    }> | undefined;
    import?: Record<string, {
        source: string;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        preset?: string | undefined;
    }> | undefined;
    clone?: Record<string, {
        source: string;
        options?: Record<string, string> | undefined;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        target?: string | undefined;
        var?: Record<string, string> | undefined;
        sourcePreset?: string | undefined;
        targetPreset?: string | undefined;
        tags?: string[] | undefined;
    }> | undefined;
    provision?: Record<string, {
        source: string;
        options?: Record<string, string> | undefined;
        depends?: string[] | undefined;
        chainId?: number | undefined;
        target?: string | undefined;
        var?: Record<string, string> | undefined;
        sourcePreset?: string | undefined;
        targetPreset?: string | undefined;
        tags?: string[] | undefined;
    }> | undefined;
    deploy?: Record<string, {
        artifact: string;
        value?: string | undefined;
        highlight?: boolean | undefined;
        create2?: string | boolean | undefined;
        from?: string | undefined;
        nonce?: string | number | undefined;
        abi?: string | undefined;
        abiOf?: string[] | undefined;
        args?: any[] | undefined;
        libraries?: Record<string, string> | undefined;
        salt?: string | undefined;
        overrides?: {
            gasLimit?: string | undefined;
        } | undefined;
        depends?: string[] | undefined;
    }> | undefined;
    contract?: Record<string, {
        artifact: string;
        value?: string | undefined;
        highlight?: boolean | undefined;
        create2?: string | boolean | undefined;
        from?: string | undefined;
        nonce?: string | number | undefined;
        abi?: string | undefined;
        abiOf?: string[] | undefined;
        args?: any[] | undefined;
        libraries?: Record<string, string> | undefined;
        salt?: string | undefined;
        overrides?: {
            gasLimit?: string | undefined;
        } | undefined;
        depends?: string[] | undefined;
    }> | undefined;
    invoke?: Record<string, {
        target: string | [string, ...string[]];
        func: string;
        value?: string | undefined;
        from?: string | undefined;
        abi?: string | undefined;
        args?: any[] | undefined;
        overrides?: {
            gasLimit: string;
        } | undefined;
        depends?: string[] | undefined;
        fromCall?: {
            func: string;
            args?: any[] | undefined;
        } | undefined;
        var?: Record<string, {
            event: string;
            arg: number;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
        }> | undefined;
        extra?: Record<string, {
            event: string;
            arg: number;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
        }> | undefined;
        factory?: Record<string, {
            event: string;
            arg: number;
            artifact?: string | undefined;
            highlight?: boolean | undefined;
            abiOf?: string[] | undefined;
            expectCount?: number | undefined;
            allowEmptyEvents?: boolean | undefined;
            constructorArgs?: any[] | undefined;
        }> | undefined;
    }> | undefined;
    router?: Record<string, {
        contracts: string[];
        from?: string | undefined;
        salt?: string | undefined;
        depends?: string[] | undefined;
        includeReceive?: boolean | undefined;
    }> | undefined;
}>;
//# sourceMappingURL=schemas.d.ts.map
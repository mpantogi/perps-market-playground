"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findContract = exports.handleTxnError = exports.traceActions = void 0;
const debug_1 = __importDefault(require("debug"));
/* eslint-disable no-case-declarations */
const viem = __importStar(require("viem"));
const actions_1 = require("viem/actions");
const trace_1 = require("../trace");
const UNKNOWN_ERROR = 'UNKNOWN_ERROR';
const debug = (0, debug_1.default)('cannon:builder:error');
function traceActions(artifacts) {
    return (client) => {
        return {
            estimateGas: async (args) => {
                try {
                    return await (0, actions_1.estimateGas)(client, args);
                }
                catch (err) {
                    await handleTxnError(artifacts, client, err, args);
                }
            },
            estimateContractGas: async (args) => {
                try {
                    return await (0, actions_1.estimateContractGas)(client, args);
                }
                catch (err) {
                    await handleTxnError(artifacts, client, err, {
                        account: args.account,
                        to: args.address,
                        value: args.value,
                        data: viem.encodeFunctionData(args),
                        chain: client.chain,
                    });
                }
            },
            prepareTransactionRequest: async (args) => {
                try {
                    return await (0, actions_1.prepareTransactionRequest)(client, args);
                }
                catch (err) {
                    await handleTxnError(artifacts, client, err, args);
                }
            },
            simulateContract: async (args) => {
                try {
                    return await (0, actions_1.simulateContract)(client, args);
                }
                catch (err) {
                    await handleTxnError(artifacts, client, err, {
                        account: args.account,
                        to: args.address,
                        chain: args.chain,
                        data: viem.encodeFunctionData(args),
                        value: args.value,
                    });
                }
            },
        };
    };
}
exports.traceActions = traceActions;
async function handleTxnError(artifacts, provider, err, txnData) {
    if (err instanceof CannonTraceError || (err?.toString()).includes('CannonTraceError')) {
        // error already parsed
        debug('skipping trace of error because already processed', err.toString());
        throw err;
    }
    debug('handle txn error received', err.toString(), JSON.stringify(err, null, 2));
    debug('the txn data', txnData);
    let errorCodeHex = null;
    let txnHash = null;
    let traces = [];
    if (viem.isHex(err.data)) {
        errorCodeHex = err.data;
    }
    if (viem.isHex(err.error?.data)) {
        errorCodeHex = err.error.data;
    }
    if (err.cause) {
        await handleTxnError(artifacts, provider, err.cause, txnData);
    }
    if (txnData && (await isAnvil(provider))) {
        const fullTxn = {
            gasLimit: 20000000, // should ensure we get an actual failed receipt
            ...txnData,
        };
        // then, run it for real so we can get a trace
        try {
            fullTxn.account = fullTxn.account || viem.zeroAddress;
            const accountAddr = typeof fullTxn.account === 'string' ? fullTxn.account : fullTxn.account.address;
            const fullProvider = provider.extend(viem.publicActions).extend(viem.walletActions);
            await fullProvider.request({ method: 'anvil_impersonateAccount', params: [accountAddr] });
            await fullProvider.request({
                method: 'anvil_setBalance',
                params: [accountAddr, viem.toHex(viem.parseEther('10000'))],
            });
            // TODO: reevaluate typings
            txnHash = await fullProvider.sendTransaction(fullTxn);
            await fullProvider.waitForTransactionReceipt({
                hash: txnHash,
                pollingInterval: 50,
            });
        }
        catch (err) {
            debug('warning: failed to force through transaction:', err);
        }
    }
    if (txnHash) {
        // try getting trace data
        try {
            traces = await provider.request({ method: 'trace_transaction', params: [txnHash] });
        }
        catch (err) {
            debug('warning: trace api unavailable', err);
        }
    }
    if (traces.length || txnHash || txnData || errorCodeHex) {
        throw new CannonTraceError(err, artifacts, errorCodeHex, traces);
    }
    else {
        throw err;
    }
}
exports.handleTxnError = handleTxnError;
class CannonTraceError extends Error {
    constructor(error, ctx, errorCodeHex, traces) {
        let contractName = 'unknown';
        let decodedMsg = error.message;
        if (errorCodeHex) {
            try {
                const r = findContract(ctx, ({ abi }) => {
                    try {
                        viem.decodeErrorResult({ abi, data: errorCodeHex });
                        return true;
                    }
                    catch (_) {
                        // intentionally empty
                    }
                    return false;
                });
                if (r !== null) {
                    contractName = r?.name;
                }
                decodedMsg = (0, trace_1.parseContractErrorReason)(r?.contract ?? null, errorCodeHex);
            }
            catch {
                // intentionally empty
            }
        }
        // now we can make ourselves a thing
        const message = [`transaction reverted in contract ${contractName}: ${decodedMsg}`];
        if (Array.isArray(traces) && traces.length) {
            message.push((0, trace_1.renderTrace)(ctx, traces));
        }
        super(message.join('\n\n'));
        this.code = UNKNOWN_ERROR;
        this.error = error;
    }
}
async function isAnvil(provider) {
    return (await provider.request({ method: 'web3_clientVersion' })).includes('anvil');
}
function findContract(ctx, condition, prefix = '') {
    for (const name in ctx.contracts) {
        if (condition(ctx.contracts[name])) {
            return {
                name: prefix + name,
                contract: ctx.contracts[name],
            };
        }
    }
    for (const name in ctx.imports) {
        const result = findContract(ctx.imports[name], condition, `${prefix}${name}.`);
        if (result) {
            return result;
        }
    }
    return null;
}
exports.findContract = findContract;
//# sourceMappingURL=index.js.map
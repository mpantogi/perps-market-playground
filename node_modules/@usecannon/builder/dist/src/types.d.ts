import * as viem from 'viem';
import { Abi, Address, Hash, Hex, SendTransactionParameters } from 'viem';
import type { RawChainDefinition } from './actions';
export type ContractArtifact = {
    contractName: string;
    sourceName: string;
    abi: Abi;
    bytecode: Hex;
    deployedBytecode: string;
    linkReferences: {
        [fileName: string]: {
            [contractName: string]: {
                start: number;
                length: number;
            }[];
        };
    };
    source?: {
        solcVersion: string;
        input: string;
    };
};
export type ContractData = {
    address: Address;
    abi: Abi;
    constructorArgs?: any[];
    linkedLibraries?: {
        [sourceName: string]: {
            [libName: string]: string;
        };
    };
    deployTxnHash: string;
    contractName: string;
    sourceName: string;
    deployedOn: string;
    highlight?: boolean;
    gasUsed: number;
    gasCost: string;
};
export type ContractMap = {
    [label: string]: ContractData;
};
export type TransactionMap = {
    [label: string]: {
        hash: Hash | '';
        events: EventMap;
        deployedOn: string;
        gasUsed: number;
        gasCost: string;
        signer: string;
    };
};
export type EventMap = {
    [name: string]: {
        args: string[];
    }[];
};
export interface PreChainBuilderContext {
    chainId: number;
    package: any;
    timestamp: string;
    overrideSettings: {
        [label: string]: string;
    };
}
export interface ChainBuilderContext extends PreChainBuilderContext {
    contracts: ContractMap;
    txns: TransactionMap;
    settings: {
        [label: string]: string;
    };
    extras?: {
        [label: string]: string;
    };
    imports: BundledChainBuilderOutputs;
    [shortContract: string]: any;
}
export declare const CannonHelperContext: {
    AddressZero: "0x0000000000000000000000000000000000000000";
    HashZero: "0x0000000000000000000000000000000000000000000000000000000000000000";
    MaxUint256: bigint;
    defaultAbiCoder: {
        encode: (a: string[], v: any[]) => `0x${string}`;
        decode: (a: string[], v: viem.Hex | viem.ByteArray) => unknown[];
    };
    zeroPad: (a: viem.Hex, s: number) => `0x${string}`;
    hexZeroPad: (a: viem.Hex, s: number) => `0x${string}`;
    hexlify: typeof viem.toHex;
    stripZeros: typeof viem.trim;
    formatBytes32String: (v: string) => `0x${string}`;
    parseBytes32String: (v: viem.Hex) => string;
    id: (v: string) => `0x${string}`;
    formatEther: typeof viem.formatEther;
    formatUnits: (s: bigint, units: number | string) => string;
    parseEther: typeof viem.parseEther;
    parseUnits: (s: string, units: number | string) => bigint;
    keccak256: typeof viem.keccak256;
    sha256: typeof viem.sha256;
    ripemd160: typeof viem.ripemd160;
    solidityPack: typeof viem.encodePacked;
    solidityKeccak256: (a: string[], v: any[]) => `0x${string}`;
    soliditySha256: (a: string[], v: any[]) => `0x${string}`;
    serializeTransaction: typeof viem.serializeTransaction;
    parseTransaction: typeof viem.parseTransaction;
    encodeFunctionData: typeof viem.encodeFunctionData;
    decodeFunctionData: typeof viem.decodeFunctionData;
    encodeFunctionResult: typeof viem.encodeFunctionResult;
    decodeFunctionResult: typeof viem.decodeFunctionResult;
};
export type ChainBuilderContextWithHelpers = ChainBuilderContext & typeof CannonHelperContext;
export type BuildOptions = {
    [val: string]: string;
};
export type StorageMode = 'all' | 'metadata' | 'none';
export type CannonSigner = {
    wallet: viem.WalletClient;
    address: Address;
};
export type Contract = Pick<viem.SimulateContractParameters, 'abi' | 'address'>;
export interface ChainBuilderRuntimeInfo {
    provider: viem.PublicClient;
    chainId: number;
    getSigner: (addr: viem.Address) => Promise<CannonSigner>;
    getDefaultSigner?: (txn: Omit<SendTransactionParameters, 'account' | 'chain'>, salt?: string) => Promise<CannonSigner>;
    getArtifact?: (name: string) => Promise<ContractArtifact>;
    snapshots: boolean;
    allowPartialDeploy: boolean;
    gasPrice?: string;
    gasFee?: string;
    priorityGasFee?: string;
}
export interface PackageState {
    name: string;
    version: string;
    currentLabel: string;
}
export type BundledOutput = {
    url: string;
    tags?: string[];
    target?: string;
    preset?: string;
} & ChainArtifacts;
export interface BundledChainBuilderOutputs {
    [module: string]: BundledOutput;
}
export type ChainArtifacts = Partial<Pick<ChainBuilderContext, 'imports' | 'contracts' | 'txns' | 'settings' | 'extras'>>;
export interface ChainBuilderOptions {
    [key: string]: string;
}
/**
 * The deployment info is the main output of the cannon build process, and what is ultimately the blob referenced by the registry when pulling a package.
 * It contains all the information
 * needed to interface with a deployment generated by cannon.
 */
export type DeploymentInfo = {
    generator: `cannon ${string}`;
    timestamp: number;
    def: RawChainDefinition;
    options: ChainBuilderOptions;
    status?: 'complete' | 'partial' | 'none';
    state: DeploymentState;
    meta: any;
    miscUrl: string;
    chainId?: number;
};
export type DeploymentManifest = {
    def: RawChainDefinition;
    npmPackage: any;
    upgradeFrom?: string;
    misc: {
        ipfsHash: string;
    };
    deploys: {
        [chainId: string]: {
            [preset: string]: {
                hash: string;
            };
        };
    };
};
/**
 * After executing a build step, this object is recorded to the DeploymentInfo for future reference.
 */
export type StepState = {
    version: number;
    hash: string | null;
    artifacts: ChainArtifacts;
    chainDump?: Hex | null;
};
export type DeploymentState = {
    [label: string]: StepState;
};
export declare function combineCtx(ctxs: ChainBuilderContext[]): ChainBuilderContext;
//# sourceMappingURL=types.d.ts.map
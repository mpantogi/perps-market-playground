"use strict";
/* eslint-env mocha */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.coreBootstrap = void 0;
const promises_1 = __importDefault(require("node:fs/promises"));
const hardhat_1 = __importDefault(require("hardhat"));
const node_path_1 = __importDefault(require("node:path"));
const ethers_1 = require("ethers");
const typechain_1 = require("typechain");
const get_hardhat_signers_1 = require("./get-hardhat-signers");
function coreBootstrap(params = { cannonfile: 'cannonfile.toml' }) {
    let outputs;
    let provider;
    let signers;
    before(async function prepareNode() {
        this.timeout(900000);
        const generatedPath = node_path_1.default.resolve(hardhat_1.default.config.paths.tests, 'generated');
        const typechainFolder = node_path_1.default.resolve(generatedPath, 'typechain');
        const writeDeployments = node_path_1.default.resolve(generatedPath, 'deployments');
        const cannonInfo = await hardhat_1.default.run('cannon:build', params);
        outputs = cannonInfo.outputs;
        // We have to manually write the deployments files instead of using the cannon:inspect
        // task because that task needs a local build to exist, but, we don't have it
        // on coverage tests because they use --network hardhat instead of --network cannon
        await _writeDeploymentsFromOutput(writeDeployments, cannonInfo.outputs.contracts);
        const allFiles = (0, typechain_1.glob)(hardhat_1.default.config.paths.root, [`${writeDeployments}/**/*.json`]);
        await (0, typechain_1.runTypeChain)({
            cwd: hardhat_1.default.config.paths.root,
            filesToProcess: allFiles,
            allFiles,
            target: 'ethers-v5',
            outDir: typechainFolder,
        });
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        provider = new hardhat_1.default.ethers.providers.Web3Provider(cannonInfo.provider);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        signers = await (0, get_hardhat_signers_1.getHardhatSigners)(hardhat_1.default, provider);
        for (const signer of signers) {
            await provider.send('hardhat_setBalance', [
                await signer.getAddress(),
                `0x${(1e22).toString(16)}`,
            ]);
        }
        try {
            await provider.send('anvil_setBlockTimestampInterval', [1]);
        }
        catch (err) {
            console.warn('failed when setting block timestamp interval', err);
        }
    });
    function getSigners() {
        if (!Array.isArray(signers))
            throw new Error('Node not initialized yet');
        return [...signers];
    }
    function getProvider() {
        if (!provider)
            throw new Error('Node not initialized yet');
        return provider;
    }
    function getExtras() {
        if (!outputs)
            throw new Error('Node not initialized yet');
        return outputs.extras;
    }
    function getContract(contractName, address) {
        if (!outputs)
            throw new Error('Node not initialized yet');
        const contract = _getContractFromOutputs(contractName, outputs, provider, address);
        const [owner] = Array.isArray(signers) ? signers : [];
        const Contract = owner ? contract.connect(owner) : contract;
        return Contract;
    }
    function createSnapshot() {
        let snapshotId;
        async function finaliseTxns() {
            const p = getProvider();
            const blockNumber = await p.getBlockNumber();
            const block = await p.getBlockWithTransactions(blockNumber);
            if (block?.transactions) {
                for await (const tx of block.transactions) {
                    try {
                        await tx.wait();
                    }
                    catch (e) {
                        console.log('Leftover transaction', tx);
                        console.error(e);
                        // I really don't care if you fail or not
                    }
                }
            }
        }
        before('create snapshot', async function () {
            await finaliseTxns();
            snapshotId = await provider.send('evm_snapshot', []);
        });
        return async function restoreSnapshot() {
            await finaliseTxns();
            await provider.send('evm_revert', [snapshotId]);
            snapshotId = await provider.send('evm_snapshot', []);
        };
    }
    return {
        getContract,
        getExtras,
        getSigners,
        getProvider,
        createSnapshot,
    };
}
exports.coreBootstrap = coreBootstrap;
function _getContractDataFromOutputs(contractName, outputs) {
    let contract;
    if (contractName.includes('.')) {
        const nestedContracts = contractName.split('.');
        // this logic handles deeply nested imports such as synthetix.oracle_manager.Proxy
        // which is really outputs.imports.synthetix.imports.oracle_manager.contracts.Proxy
        let imports = outputs.imports;
        for (const c of nestedContracts.slice(0, -2)) {
            if (!imports[c]) {
                throw new Error(`cannonfile does not includes an import named "${c}"`);
            }
            else {
                imports = imports[c].imports;
            }
        }
        contract =
            imports[nestedContracts[nestedContracts.length - 2]].contracts[nestedContracts[nestedContracts.length - 1]];
    }
    else {
        contract = outputs.contracts[contractName];
    }
    if (!contract) {
        throw new Error(`Contract "${contractName}" not found on cannon build`);
    }
    return contract;
}
function _getContractFromOutputs(contractName, outputs, provider, address) {
    const contract = _getContractDataFromOutputs(contractName, outputs);
    return new ethers_1.ethers.Contract(address || contract.address, contract.abi, // eslint-disable-line @typescript-eslint/no-explicit-any
    provider // eslint-disable-line @typescript-eslint/no-explicit-any
    );
}
async function _writeDeploymentsFromOutput(target, contracts) {
    await promises_1.default.mkdir(target, { recursive: true });
    await Promise.all(Object.entries(contracts).map(async ([contractName, contract]) => _writeJson(target, contractName, contract)));
}
async function _writeJson(folder, filename, data) {
    const filepath = node_path_1.default.resolve(folder, `${filename}.json`);
    return promises_1.default.writeFile(filepath, JSON.stringify(data, null, 2));
}
//# sourceMappingURL=tests.js.map
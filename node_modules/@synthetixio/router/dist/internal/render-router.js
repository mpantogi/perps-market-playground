"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSelectors = exports.renderRouter = void 0;
const mustache_1 = __importDefault(require("mustache"));
const abi_1 = require("@ethersproject/abi");
const keccak256_1 = require("@ethersproject/keccak256");
const errors_1 = require("./errors");
const router_function_filter_1 = require("./router-function-filter");
const router_1 = require("../templates/router");
const router_helper_1 = require("./router-helper");
const TAB = '    ';
function renderRouter({ routerName = 'Router', template = router_1.routerTemplate, functionFilter = router_function_filter_1.routerFunctionFilter, canReceivePlainETH = false, contracts, }) {
    if (!Array.isArray(contracts) || contracts.length === 0) {
        throw new Error(`No contracts found to render during "${routerName}" generation`);
    }
    const selectors = _getAllSelectors(contracts, functionFilter);
    _validateSelectors(selectors);
    const binaryData = _buildBinaryData(selectors);
    return mustache_1.default.render(template, {
        moduleName: routerName,
        modules: _renderModules(contracts),
        selectors: _renderSelectors(binaryData),
        // Note: Plain ETH transfers are disabled by default. Set this to true to
        // enable them. If there is ever a use case for this, it might be a good
        // idea to expose the boolean in the router tool's interface.
        receive: _renderReceive(canReceivePlainETH),
    });
}
exports.renderRouter = renderRouter;
function _getAllSelectors(contracts, functionFilter) {
    return contracts
        .flatMap(({ contractName, abi }) => getSelectors(abi, functionFilter).map((s) => ({
        contractName,
        ...s,
    })))
        .sort((a, b) => {
        return Number.parseInt(a.selector, 16) - Number.parseInt(b.selector, 16);
    });
}
function _renderReceive(canReceivePlainETH) {
    let receiveStr = '';
    if (canReceivePlainETH) {
        receiveStr += '\n    receive() external payable {}\n';
    }
    return receiveStr;
}
function _renderSelectors(binaryData) {
    let selectorsStr = '';
    function renderNode(node, indent = 0) {
        if (node.children.length > 0) {
            const childA = node.children[0];
            const childB = node.children[1];
            function findMidSelector(node) {
                if (node.selectors.length > 0) {
                    return node.selectors[0];
                }
                else {
                    return findMidSelector(node.children[0]);
                }
            }
            const midSelector = findMidSelector(childB);
            selectorsStr += `\n${TAB.repeat(4 + indent)}if lt(sig,${midSelector.selector}) {`;
            renderNode(childA, indent + 1);
            selectorsStr += `\n${TAB.repeat(4 + indent)}}`;
            renderNode(childB, indent);
        }
        else {
            selectorsStr += `\n${TAB.repeat(4 + indent)}switch sig`;
            for (const s of node.selectors) {
                selectorsStr += `\n${TAB.repeat(4 + indent)}case ${s.selector} { result := ${(0, router_helper_1.toPrivateConstantCase)(s.contractName)} } // ${s.contractName}.${s.name}()`;
            }
            selectorsStr += `\n${TAB.repeat(4 + indent)}leave`;
        }
    }
    renderNode(binaryData, 0);
    return selectorsStr.trim();
}
/**
 * Get a string of modules constants with its deployedAddresses.
 * E.g.:
 *   address private constant _ANOTHER_MODULE = 0xAA...;
 *   address private constant _OWNER_MODULE = 0x5c..;
 */
function _renderModules(contracts) {
    return contracts
        .map(({ contractName, deployedAddress }) => {
        const name = (0, router_helper_1.toPrivateConstantCase)(contractName);
        return `${TAB}address private constant ${name} = ${deployedAddress};`;
    })
        .join('\n')
        .trim();
}
function _buildBinaryData(selectors) {
    const maxSelectorsPerSwitchStatement = 9;
    function binarySplit(node) {
        if (node.selectors.length > maxSelectorsPerSwitchStatement) {
            const midIdx = Math.ceil(node.selectors.length / 2);
            const childA = binarySplit({
                selectors: node.selectors.splice(0, midIdx),
                children: [],
            });
            const childB = binarySplit({
                selectors: node.selectors.splice(-midIdx),
                children: [],
            });
            node.children.push(childA);
            node.children.push(childB);
            node.selectors = [];
        }
        return node;
    }
    const binaryData = {
        selectors,
        children: [],
    };
    const finalData = binarySplit(binaryData);
    return finalData;
}
function getSelectors(contractAbi, functionFilter = () => true) {
    return contractAbi
        .filter((fragment) => fragment.type === 'function' &&
        typeof fragment.name === 'string' &&
        functionFilter(fragment.name))
        .map((fragment) => {
        return {
            name: fragment.name,
            selector: _getFunctionSelector(fragment),
        };
    });
}
exports.getSelectors = getSelectors;
function _getFunctionSelector(fragment) {
    return (0, keccak256_1.keccak256)(Buffer.from(abi_1.Fragment.fromObject(fragment).format())).slice(0, 10);
}
function _validateSelectors(selectors) {
    const repeated = new Set(selectors.map((s) => s.selector).filter(_onlyRepeated));
    if (!repeated.size)
        return;
    const list = selectors
        .filter((s) => repeated.has(s.selector))
        .map((s) => `  ${s.selector} // ${s.contractName}.${s.name}()`)
        .join('\n');
    throw new errors_1.ContractValidationError(`The following contracts have repeated function selectors behind the same Router:\n${list}\n`);
}
function _onlyRepeated(value, index, self) {
    const last = self.lastIndexOf(value);
    return self.indexOf(value) !== last && index === last;
}
//# sourceMappingURL=render-router.js.map